// Generated by Melange
'use strict';

var Curry = require("melange.runtime/curry.js");
var Caml_option = require("melange.runtime/caml_option.js");
var Relude__Relude_List = require("./Relude_List.js");
var Relude__Relude_Extensions_Apply = require("./extensions/Relude_Extensions_Apply.js");
var Relude__Relude_Extensions_Monad = require("./extensions/Relude_Extensions_Monad.js");
var Relude__Relude_Extensions_Functor = require("./extensions/Relude_Extensions_Functor.js");
var Relude__Relude_Extensions_Applicative = require("./extensions/Relude_Extensions_Applicative.js");

function $$this(a) {
  return {
          TAG: /* This */0,
          _0: a
        };
}

function that(b) {
  return {
          TAG: /* That */1,
          _0: b
        };
}

function both(a, b) {
  return {
          TAG: /* Both */2,
          _0: a,
          _1: b
        };
}

function isThis(param) {
  switch (param.TAG | 0) {
    case /* This */0 :
        return true;
    case /* That */1 :
    case /* Both */2 :
        return false;
    
  }
}

function isThat(param) {
  switch (param.TAG | 0) {
    case /* That */1 :
        return true;
    case /* This */0 :
    case /* Both */2 :
        return false;
    
  }
}

function isBoth(param) {
  switch (param.TAG | 0) {
    case /* This */0 :
    case /* That */1 :
        return false;
    case /* Both */2 :
        return true;
    
  }
}

function getThis(a) {
  switch (a.TAG | 0) {
    case /* That */1 :
        return ;
    case /* This */0 :
    case /* Both */2 :
        return Caml_option.some(a._0);
    
  }
}

function getThat(b) {
  switch (b.TAG | 0) {
    case /* This */0 :
        return ;
    case /* That */1 :
        return Caml_option.some(b._0);
    case /* Both */2 :
        return Caml_option.some(b._1);
    
  }
}

function partition(iors) {
  return Relude__Relude_List.foldRight((function (ior, param) {
                  var boths = param[2];
                  var bs = param[1];
                  var as_ = param[0];
                  switch (ior.TAG | 0) {
                    case /* This */0 :
                        return [
                                {
                                  hd: ior._0,
                                  tl: as_
                                },
                                bs,
                                boths
                              ];
                    case /* That */1 :
                        return [
                                as_,
                                {
                                  hd: ior._0,
                                  tl: bs
                                },
                                boths
                              ];
                    case /* Both */2 :
                        return [
                                as_,
                                bs,
                                {
                                  hd: [
                                    ior._0,
                                    ior._1
                                  ],
                                  tl: boths
                                }
                              ];
                    
                  }
                }), [
                /* [] */0,
                /* [] */0,
                /* [] */0
              ])(iors);
}

function catThis(iors) {
  return Relude__Relude_List.foldRight((function (ior, acc) {
                  switch (ior.TAG | 0) {
                    case /* That */1 :
                        return acc;
                    case /* This */0 :
                    case /* Both */2 :
                        return {
                                hd: ior._0,
                                tl: acc
                              };
                    
                  }
                }), /* [] */0)(iors);
}

function catThat(iors) {
  return Relude__Relude_List.foldRight((function (ior, acc) {
                  switch (ior.TAG | 0) {
                    case /* This */0 :
                        return acc;
                    case /* That */1 :
                        return {
                                hd: ior._0,
                                tl: acc
                              };
                    case /* Both */2 :
                        return {
                                hd: ior._1,
                                tl: acc
                              };
                    
                  }
                }), /* [] */0)(iors);
}

function mapThis(f, fa) {
  switch (fa.TAG | 0) {
    case /* This */0 :
        return {
                TAG: /* This */0,
                _0: Curry._1(f, fa._0)
              };
    case /* That */1 :
        return fa;
    case /* Both */2 :
        return {
                TAG: /* Both */2,
                _0: Curry._1(f, fa._0),
                _1: fa._1
              };
    
  }
}

function mapThat(f, fa) {
  switch (fa.TAG | 0) {
    case /* This */0 :
        return fa;
    case /* That */1 :
        return {
                TAG: /* That */1,
                _0: Curry._1(f, fa._0)
              };
    case /* Both */2 :
        return {
                TAG: /* Both */2,
                _0: fa._0,
                _1: Curry._1(f, fa._1)
              };
    
  }
}

function tap(ifThis, ifThat, ifBoth, fa) {
  switch (fa.TAG | 0) {
    case /* This */0 :
        Curry._1(ifThis, fa._0);
        return fa;
    case /* That */1 :
        Curry._1(ifThat, fa._0);
        return fa;
    case /* Both */2 :
        Curry._2(ifBoth, fa._0, fa._1);
        return fa;
    
  }
}

function tapThis(ifThis, fa) {
  switch (fa.TAG | 0) {
    case /* This */0 :
        Curry._1(ifThis, fa._0);
        return fa;
    case /* That */1 :
    case /* Both */2 :
        return fa;
    
  }
}

function tapThat(ifThat, fa) {
  switch (fa.TAG | 0) {
    case /* That */1 :
        Curry._1(ifThat, fa._0);
        return fa;
    case /* This */0 :
    case /* Both */2 :
        return fa;
    
  }
}

function tapBoth(ifBoth, fa) {
  switch (fa.TAG | 0) {
    case /* This */0 :
    case /* That */1 :
        return fa;
    case /* Both */2 :
        Curry._2(ifBoth, fa._0, fa._1);
        return fa;
    
  }
}

function tapThisOrBoth(ifThis, fa) {
  switch (fa.TAG | 0) {
    case /* That */1 :
        return fa;
    case /* This */0 :
    case /* Both */2 :
        Curry._1(ifThis, fa._0);
        return fa;
    
  }
}

function tapThatOrBoth(ifThat, fa) {
  switch (fa.TAG | 0) {
    case /* This */0 :
        return fa;
    case /* That */1 :
        Curry._1(ifThat, fa._0);
        return fa;
    case /* Both */2 :
        Curry._1(ifThat, fa._1);
        return fa;
    
  }
}

function applyWithAppendThats(appendThats, ff, fa) {
  switch (ff.TAG | 0) {
    case /* This */0 :
        var f = ff._0;
        switch (fa.TAG | 0) {
          case /* This */0 :
              return {
                      TAG: /* This */0,
                      _0: Curry._1(f, fa._0)
                    };
          case /* That */1 :
              return {
                      TAG: /* That */1,
                      _0: fa._0
                    };
          case /* Both */2 :
              return {
                      TAG: /* Both */2,
                      _0: Curry._1(f, fa._0),
                      _1: fa._1
                    };
          
        }
    case /* That */1 :
        var b = ff._0;
        switch (fa.TAG | 0) {
          case /* This */0 :
              return {
                      TAG: /* That */1,
                      _0: b
                    };
          case /* That */1 :
              return {
                      TAG: /* That */1,
                      _0: Curry._2(appendThats, b, fa._0)
                    };
          case /* Both */2 :
              return {
                      TAG: /* That */1,
                      _0: Curry._2(appendThats, b, fa._1)
                    };
          
        }
    case /* Both */2 :
        var b1 = ff._1;
        var f$1 = ff._0;
        switch (fa.TAG | 0) {
          case /* This */0 :
              return {
                      TAG: /* Both */2,
                      _0: Curry._1(f$1, fa._0),
                      _1: b1
                    };
          case /* That */1 :
              return {
                      TAG: /* That */1,
                      _0: Curry._2(appendThats, b1, fa._0)
                    };
          case /* Both */2 :
              return {
                      TAG: /* Both */2,
                      _0: Curry._1(f$1, fa._0),
                      _1: Curry._2(appendThats, b1, fa._1)
                    };
          
        }
    
  }
}

function pure(a) {
  return {
          TAG: /* This */0,
          _0: a
        };
}

function bind(fa, f) {
  switch (fa.TAG | 0) {
    case /* That */1 :
        return fa;
    case /* This */0 :
    case /* Both */2 :
        return Curry._1(f, fa._0);
    
  }
}

function flatMap(f, fa) {
  return bind(fa, f);
}

function map2(appendThats, f, fa, fb) {
  return applyWithAppendThats(appendThats, mapThis(f, fa), fb);
}

function map3(appendThats, f, fa, fb, fc) {
  return applyWithAppendThats(appendThats, map2(appendThats, f, fa, fb), fc);
}

function map4(appendThats, f, fa, fb, fc, fd) {
  return applyWithAppendThats(appendThats, map3(appendThats, f, fa, fb, fc), fd);
}

function map5(appendThats, f, fa, fb, fc, fd, fe) {
  return applyWithAppendThats(appendThats, map4(appendThats, f, fa, fb, fc, fd), fe);
}

function fold(aToC, bToC, abToC, ior) {
  switch (ior.TAG | 0) {
    case /* This */0 :
        return Curry._1(aToC, ior._0);
    case /* That */1 :
        return Curry._1(bToC, ior._0);
    case /* Both */2 :
        return Curry._2(abToC, ior._0, ior._1);
    
  }
}

function toTuple(defaultA, defaultB, ior) {
  switch (ior.TAG | 0) {
    case /* This */0 :
        return [
                ior._0,
                defaultB
              ];
    case /* That */1 :
        return [
                defaultA,
                ior._0
              ];
    case /* Both */2 :
        return [
                ior._0,
                ior._1
              ];
    
  }
}

function merge(f, ior) {
  switch (ior.TAG | 0) {
    case /* This */0 :
    case /* That */1 :
        return ior._0;
    case /* Both */2 :
        return Curry._2(f, ior._0, ior._1);
    
  }
}

function mergeWith(aToC, bToC, ccToC, ior) {
  switch (ior.TAG | 0) {
    case /* This */0 :
        return Curry._1(aToC, ior._0);
    case /* That */1 :
        return Curry._1(bToC, ior._0);
    case /* Both */2 :
        return Curry._2(ccToC, Curry._1(aToC, ior._0), Curry._1(bToC, ior._1));
    
  }
}

function WithThats(Thats, That) {
  var Functor = {
    map: mapThis
  };
  var include = Relude__Relude_Extensions_Functor.FunctorExtensions(Functor);
  var apply = function (ff, fa) {
    return applyWithAppendThats(Thats.append, ff, fa);
  };
  var Apply = {
    map: mapThis,
    apply: apply
  };
  var include$1 = Relude__Relude_Extensions_Apply.ApplyExtensions(Apply);
  var Applicative = {
    map: mapThis,
    apply: apply,
    pure: pure
  };
  var include$2 = Relude__Relude_Extensions_Applicative.ApplicativeExtensions(Applicative);
  var Monad = {
    map: mapThis,
    apply: apply,
    pure: pure,
    flat_map: bind
  };
  var include$3 = Relude__Relude_Extensions_Monad.MonadExtensions(Monad);
  var include$4 = Relude__Relude_Extensions_Functor.FunctorInfix(Functor);
  var include$5 = Relude__Relude_Extensions_Apply.ApplyInfix(Apply);
  var include$6 = Relude__Relude_Extensions_Monad.MonadInfix(Monad);
  var Infix_FunctorExtensions = include$4.FunctorExtensions;
  var Infix_$less$$great = include$4.$less$$great;
  var Infix_$less$$$great = include$4.$less$$$great;
  var Infix_$less$ = include$4.$less$;
  var Infix_$$great = include$4.$$great;
  var Infix_$less$at$great = include$4.$less$at$great;
  var Infix_ApplyExtensions = include$5.ApplyExtensions;
  var Infix_$less$star$great = include$5.$less$star$great;
  var Infix_$less$star = include$5.$less$star;
  var Infix_$star$great = include$5.$star$great;
  var Infix_MonadExtensions = include$6.MonadExtensions;
  var Infix_$great$great$eq = include$6.$great$great$eq;
  var Infix_$eq$less$less = include$6.$eq$less$less;
  var Infix_$great$eq$great = include$6.$great$eq$great;
  var Infix_$less$eq$less = include$6.$less$eq$less;
  var Infix = {
    FunctorExtensions: Infix_FunctorExtensions,
    $less$$great: Infix_$less$$great,
    $less$$$great: Infix_$less$$$great,
    $less$: Infix_$less$,
    $$great: Infix_$$great,
    $less$at$great: Infix_$less$at$great,
    ApplyExtensions: Infix_ApplyExtensions,
    $less$star$great: Infix_$less$star$great,
    $less$star: Infix_$less$star,
    $star$great: Infix_$star$great,
    MonadExtensions: Infix_MonadExtensions,
    $great$great$eq: Infix_$great$great$eq,
    $eq$less$less: Infix_$eq$less$less,
    $great$eq$great: Infix_$great$eq$great,
    $less$eq$less: Infix_$less$eq$less
  };
  return {
          Functor: Functor,
          map: mapThis,
          BsFunctorExtensions: include.BsFunctorExtensions,
          flipMap: include.flipMap,
          $$void: include.$$void,
          voidRight: include.voidRight,
          voidLeft: include.voidLeft,
          flap: include.flap,
          Apply: Apply,
          apply: apply,
          BsApplyExtensions: include$1.BsApplyExtensions,
          applyFirst: include$1.applyFirst,
          applySecond: include$1.applySecond,
          map2: include$1.map2,
          map3: include$1.map3,
          map4: include$1.map4,
          map5: include$1.map5,
          tuple2: include$1.tuple2,
          tuple3: include$1.tuple3,
          tuple4: include$1.tuple4,
          tuple5: include$1.tuple5,
          mapTuple2: include$1.mapTuple2,
          mapTuple3: include$1.mapTuple3,
          mapTuple4: include$1.mapTuple4,
          mapTuple5: include$1.mapTuple5,
          Applicative: Applicative,
          pure: pure,
          BsApplicativeExtensions: include$2.BsApplicativeExtensions,
          liftA1: include$2.liftA1,
          all: include$2.all,
          Monad: Monad,
          bind: bind,
          BsMonadExtensions: include$3.BsMonadExtensions,
          flatMap: include$3.flatMap,
          flatten: include$3.flatten,
          composeKleisli: include$3.composeKleisli,
          flipComposeKleisli: include$3.flipComposeKleisli,
          liftM1: include$3.liftM1,
          when_: include$3.when_,
          unless: include$3.unless,
          Infix: Infix
        };
}

var map = mapThis;

exports.$$this = $$this;
exports.that = that;
exports.both = both;
exports.isThis = isThis;
exports.isThat = isThat;
exports.isBoth = isBoth;
exports.getThis = getThis;
exports.getThat = getThat;
exports.partition = partition;
exports.catThis = catThis;
exports.catThat = catThat;
exports.mapThis = mapThis;
exports.map = map;
exports.mapThat = mapThat;
exports.tap = tap;
exports.tapThis = tapThis;
exports.tapThat = tapThat;
exports.tapBoth = tapBoth;
exports.tapThisOrBoth = tapThisOrBoth;
exports.tapThatOrBoth = tapThatOrBoth;
exports.applyWithAppendThats = applyWithAppendThats;
exports.pure = pure;
exports.bind = bind;
exports.flatMap = flatMap;
exports.map2 = map2;
exports.map3 = map3;
exports.map4 = map4;
exports.map5 = map5;
exports.fold = fold;
exports.toTuple = toTuple;
exports.merge = merge;
exports.mergeWith = mergeWith;
exports.WithThats = WithThats;
/* Relude__Relude_List Not a pure module */
