// Generated by Melange
'use strict';

var Curry = require("melange.runtime/curry.js");
var Caml_option = require("melange.runtime/caml_option.js");
var Belt_MapString = require("melange.belt/./belt_MapString.js");
var Relude__Relude_Extensions_Apply = require("./extensions/Relude_Extensions_Apply.js");
var Relude__Relude_Extensions_Monad = require("./extensions/Relude_Extensions_Monad.js");
var Relude__Relude_Extensions_Functor = require("./extensions/Relude_Extensions_Functor.js");
var Relude__Relude_Extensions_Applicative = require("./extensions/Relude_Extensions_Applicative.js");

function identity(a) {
  return a;
}

function $$const(a, param) {
  return a;
}

function flip(f, b, a) {
  return Curry._2(f, a, b);
}

function compose(f, g, a) {
  return Curry._1(f, Curry._1(g, a));
}

function flipCompose(f, g, a) {
  return Curry._1(g, Curry._1(f, a));
}

function curry2(f, a, b) {
  return Curry._1(f, [
              a,
              b
            ]);
}

function curry3(f, a, b, c) {
  return Curry._1(f, [
              a,
              b,
              c
            ]);
}

function curry4(f, a, b, c, d) {
  return Curry._1(f, [
              a,
              b,
              c,
              d
            ]);
}

function curry5(f, a, b, c, d, e) {
  return Curry._1(f, [
              a,
              b,
              c,
              d,
              e
            ]);
}

function uncurry2(f, param) {
  return Curry._2(f, param[0], param[1]);
}

function uncurry3(f, param) {
  return Curry._3(f, param[0], param[1], param[2]);
}

function uncurry4(f, param) {
  return Curry._4(f, param[0], param[1], param[2], param[3]);
}

function uncurry5(f, param) {
  return Curry._5(f, param[0], param[1], param[2], param[3], param[4]);
}

function map(aToB, rToA, r) {
  return Curry._1(aToB, Curry._1(rToA, r));
}

function apply(rToAToB, rToA, r) {
  return Curry._2(rToAToB, r, Curry._1(rToA, r));
}

function pure(a, param) {
  return a;
}

function bind(rToA, arToB, r) {
  return Curry._2(arToB, Curry._1(rToA, r), r);
}

function flatMap(f, fa) {
  return function (param) {
    return Curry._2(f, Curry._1(fa, param), param);
  };
}

function memoize0(f) {
  var cached = {
    contents: undefined
  };
  return function (param) {
    var result = cached.contents;
    if (result !== undefined) {
      return Caml_option.valFromOption(result);
    }
    var result$1 = Curry._1(f, undefined);
    cached.contents = Caml_option.some(result$1);
    return result$1;
  };
}

function memoize1(makeKey, f) {
  var cache = {
    contents: undefined
  };
  return function (input) {
    var key = Curry._1(makeKey, input);
    var resultOpt = Belt_MapString.get(cache.contents, key);
    if (resultOpt !== undefined) {
      return Caml_option.valFromOption(resultOpt);
    }
    var result = Curry._1(f, input);
    cache.contents = Belt_MapString.set(cache.contents, key, result);
    return result;
  };
}

function before(times, f) {
  var callCount = {
    contents: 0
  };
  var lastResultOpt = {
    contents: undefined
  };
  return function (param) {
    var lastResult = lastResultOpt.contents;
    if (lastResult !== undefined) {
      if (callCount.contents >= times) {
        return Caml_option.valFromOption(lastResult);
      }
      var result = Curry._1(f, undefined);
      lastResultOpt.contents = Caml_option.some(result);
      callCount.contents = callCount.contents + 1 | 0;
      return result;
    }
    var result$1 = Curry._1(f, undefined);
    lastResultOpt.contents = Caml_option.some(result$1);
    callCount.contents = callCount.contents + 1 | 0;
    return result$1;
  };
}

function after(times, f) {
  var callCount = {
    contents: 0
  };
  return function (param) {
    if (callCount.contents < times) {
      callCount.contents = callCount.contents + 1 | 0;
      return ;
    } else {
      return Caml_option.some(Curry._1(f, undefined));
    }
  };
}

function once(f) {
  var lastResultOpt = {
    contents: undefined
  };
  return function (param) {
    var lastResult = lastResultOpt.contents;
    if (lastResult !== undefined) {
      return Caml_option.valFromOption(lastResult);
    }
    var result = Curry._1(f, undefined);
    lastResultOpt.contents = Caml_option.some(result);
    return result;
  };
}

function wrap(before, after, f, input) {
  return Curry._1(after, Curry._1(f, Curry._1(before, input)));
}

function negate(f, a) {
  return !Curry._1(f, a);
}

var Infix = {
  $less$less: compose,
  $great$great: flipCompose
};

function WithArgument(R) {
  var Functor = {
    map: map
  };
  var include = Relude__Relude_Extensions_Functor.FunctorExtensions(Functor);
  var Apply = {
    map: map,
    apply: apply
  };
  var include$1 = Relude__Relude_Extensions_Apply.ApplyExtensions(Apply);
  var Applicative = {
    map: map,
    apply: apply,
    pure: pure
  };
  var include$2 = Relude__Relude_Extensions_Applicative.ApplicativeExtensions(Applicative);
  var Monad = {
    map: map,
    apply: apply,
    pure: pure,
    flat_map: bind
  };
  var include$3 = Relude__Relude_Extensions_Monad.MonadExtensions(Monad);
  var include$4 = Relude__Relude_Extensions_Functor.FunctorInfix(Functor);
  var include$5 = Relude__Relude_Extensions_Apply.ApplyInfix(Apply);
  var include$6 = Relude__Relude_Extensions_Monad.MonadInfix(Monad);
  var Infix_FunctorExtensions = include$4.FunctorExtensions;
  var Infix_$less$$great = include$4.$less$$great;
  var Infix_$less$$$great = include$4.$less$$$great;
  var Infix_$less$ = include$4.$less$;
  var Infix_$$great = include$4.$$great;
  var Infix_$less$at$great = include$4.$less$at$great;
  var Infix_ApplyExtensions = include$5.ApplyExtensions;
  var Infix_$less$star$great = include$5.$less$star$great;
  var Infix_$less$star = include$5.$less$star;
  var Infix_$star$great = include$5.$star$great;
  var Infix_MonadExtensions = include$6.MonadExtensions;
  var Infix_$great$great$eq = include$6.$great$great$eq;
  var Infix_$eq$less$less = include$6.$eq$less$less;
  var Infix_$great$eq$great = include$6.$great$eq$great;
  var Infix_$less$eq$less = include$6.$less$eq$less;
  var Infix = {
    FunctorExtensions: Infix_FunctorExtensions,
    $less$$great: Infix_$less$$great,
    $less$$$great: Infix_$less$$$great,
    $less$: Infix_$less$,
    $$great: Infix_$$great,
    $less$at$great: Infix_$less$at$great,
    ApplyExtensions: Infix_ApplyExtensions,
    $less$star$great: Infix_$less$star$great,
    $less$star: Infix_$less$star,
    $star$great: Infix_$star$great,
    MonadExtensions: Infix_MonadExtensions,
    $great$great$eq: Infix_$great$great$eq,
    $eq$less$less: Infix_$eq$less$less,
    $great$eq$great: Infix_$great$eq$great,
    $less$eq$less: Infix_$less$eq$less,
    $less$less: compose,
    $great$great: flipCompose
  };
  return {
          Functor: Functor,
          map: map,
          BsFunctorExtensions: include.BsFunctorExtensions,
          flipMap: include.flipMap,
          $$void: include.$$void,
          voidRight: include.voidRight,
          voidLeft: include.voidLeft,
          flap: include.flap,
          Apply: Apply,
          apply: apply,
          BsApplyExtensions: include$1.BsApplyExtensions,
          applyFirst: include$1.applyFirst,
          applySecond: include$1.applySecond,
          map2: include$1.map2,
          map3: include$1.map3,
          map4: include$1.map4,
          map5: include$1.map5,
          tuple2: include$1.tuple2,
          tuple3: include$1.tuple3,
          tuple4: include$1.tuple4,
          tuple5: include$1.tuple5,
          mapTuple2: include$1.mapTuple2,
          mapTuple3: include$1.mapTuple3,
          mapTuple4: include$1.mapTuple4,
          mapTuple5: include$1.mapTuple5,
          Applicative: Applicative,
          pure: pure,
          BsApplicativeExtensions: include$2.BsApplicativeExtensions,
          liftA1: include$2.liftA1,
          all: include$2.all,
          Monad: Monad,
          bind: bind,
          BsMonadExtensions: include$3.BsMonadExtensions,
          flatMap: include$3.flatMap,
          flatten: include$3.flatten,
          composeKleisli: include$3.composeKleisli,
          flipComposeKleisli: include$3.flipComposeKleisli,
          liftM1: include$3.liftM1,
          when_: include$3.when_,
          unless: include$3.unless,
          Infix: Infix
        };
}

var id = identity;

var andThen = flipCompose;

exports.identity = identity;
exports.id = id;
exports.$$const = $$const;
exports.flip = flip;
exports.compose = compose;
exports.flipCompose = flipCompose;
exports.andThen = andThen;
exports.curry2 = curry2;
exports.curry3 = curry3;
exports.curry4 = curry4;
exports.curry5 = curry5;
exports.uncurry2 = uncurry2;
exports.uncurry3 = uncurry3;
exports.uncurry4 = uncurry4;
exports.uncurry5 = uncurry5;
exports.map = map;
exports.apply = apply;
exports.pure = pure;
exports.bind = bind;
exports.flatMap = flatMap;
exports.memoize0 = memoize0;
exports.memoize1 = memoize1;
exports.before = before;
exports.after = after;
exports.once = once;
exports.wrap = wrap;
exports.negate = negate;
exports.Infix = Infix;
exports.WithArgument = WithArgument;
/* Relude__Relude_Extensions_Apply Not a pure module */
