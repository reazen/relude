// Generated by Melange
'use strict';

var Curry = require("melange.runtime/curry.js");
var Relude__Relude_List = require("./Relude_List.js");
var Relude__Relude_Array = require("./Relude_Array.js");
var Relude__Relude_Identity = require("./Relude_Identity.js");
var Relude__Relude_Extensions_Apply = require("./extensions/Relude_Extensions_Apply.js");
var Relude__Relude_Extensions_Monad = require("./extensions/Relude_Extensions_Monad.js");
var Relude__Relude_Extensions_Functor = require("./extensions/Relude_Extensions_Functor.js");
var Relude__Relude_Extensions_Applicative = require("./extensions/Relude_Extensions_Applicative.js");

function WithEntry(Entry) {
  var Monoid = {
    append: Relude__Relude_List.concat,
    empty: /* [] */0
  };
  return {
          Monoid: Monoid
        };
}

var List = {
  WithEntry: WithEntry
};

function WithEntry$1(Entry) {
  var empty = [];
  var Monoid = {
    append: Relude__Relude_Array.concat,
    empty: empty
  };
  return {
          Monoid: Monoid
        };
}

var $$Array = {
  WithEntry: WithEntry$1
};

var WriterLog = {
  List: List,
  $$Array: $$Array
};

function WithMonad(Monad) {
  var make = function (mWriter) {
    return /* WriterT */{
            _0: mWriter
          };
  };
  var runWriterT = function (mWriter) {
    return mWriter._0;
  };
  var execWriterT = function (mWriter) {
    return Curry._2(Monad.map, (function (prim) {
                  return prim[1];
                }), mWriter._0);
  };
  var mapWriterT = function (mAToMB, mA) {
    return /* WriterT */{
            _0: Curry._1(mAToMB, mA._0)
          };
  };
  var tell = function (w) {
    return /* WriterT */{
            _0: Curry._1(Monad.pure, [
                  undefined,
                  w
                ])
          };
  };
  var listen = function (mAW) {
    return /* WriterT */{
            _0: Curry._2(Monad.map, (function (param) {
                    var w = param[1];
                    return [
                            [
                              param[0],
                              w
                            ],
                            w
                          ];
                  }), mAW._0)
          };
  };
  var pass = function (m) {
    return /* WriterT */{
            _0: Curry._2(Monad.map, (function (param) {
                    var match = param[0];
                    return [
                            match[0],
                            Curry._1(match[1], param[1])
                          ];
                  }), m._0)
          };
  };
  var listens = function (w1ToW2, writerTMAW1) {
    var m = listen(writerTMAW1);
    return /* WriterT */{
            _0: Curry._2(Monad.map, (function (param) {
                    var match = param[0];
                    var w1 = match[1];
                    return [
                            [
                              match[0],
                              Curry._1(w1ToW2, w1)
                            ],
                            w1
                          ];
                  }), m._0)
          };
  };
  var censor = function (wToW, mAW) {
    return pass(/* WriterT */{
                _0: Curry._2(Monad.map, (function (param) {
                        return [
                                [
                                  param[0],
                                  wToW
                                ],
                                param[1]
                              ];
                      }), mAW._0)
              });
  };
  var map = function (aToB, mAW) {
    return /* WriterT */{
            _0: Curry._2(Monad.map, (function (param) {
                    return [
                            Curry._1(aToB, param[0]),
                            param[1]
                          ];
                  }), mAW._0)
          };
  };
  var applyWithAppendLog = function (appendLog, mAToBW, mAW) {
    return /* WriterT */{
            _0: Curry._2(Monad.apply, Curry._2(Monad.map, (function (param, param$1) {
                        return [
                                Curry._1(param[0], param$1[0]),
                                Curry._2(appendLog, param[1], param$1[1])
                              ];
                      }), mAToBW._0), mAW._0)
          };
  };
  var pureWithEmptyLog = function (empty, a) {
    return /* WriterT */{
            _0: Curry._1(Monad.pure, [
                  a,
                  empty
                ])
          };
  };
  var bindWithAppendLog = function (appendLog, mAW, aToWriterTBW) {
    return /* WriterT */{
            _0: Curry._2(Monad.flat_map, mAW._0, (function (param) {
                    var w1 = param[1];
                    var mBW = Curry._1(aToWriterTBW, param[0]);
                    return Curry._2(Monad.map, (function (param) {
                                  return [
                                          param[0],
                                          Curry._2(appendLog, w1, param[1])
                                        ];
                                }), mBW._0);
                  }))
          };
  };
  var WithLog = function (Log) {
    var Functor = {
      map: map
    };
    var include = Relude__Relude_Extensions_Functor.FunctorExtensions(Functor);
    var apply = function (ff, fa) {
      return applyWithAppendLog(Log.Monoid.append, ff, fa);
    };
    var Apply = {
      map: map,
      apply: apply
    };
    var include$1 = Relude__Relude_Extensions_Apply.ApplyExtensions(Apply);
    var pure = function (a) {
      return pureWithEmptyLog(Log.Monoid.empty, a);
    };
    var Applicative = {
      map: map,
      apply: apply,
      pure: pure
    };
    var include$2 = Relude__Relude_Extensions_Applicative.ApplicativeExtensions(Applicative);
    var flat_map = function (fa, f) {
      return bindWithAppendLog(Log.Monoid.append, fa, f);
    };
    var Monad = {
      map: map,
      apply: apply,
      pure: pure,
      flat_map: flat_map
    };
    var include$3 = Relude__Relude_Extensions_Monad.MonadExtensions(Monad);
    var include$4 = Relude__Relude_Extensions_Functor.FunctorInfix(Functor);
    var include$5 = Relude__Relude_Extensions_Apply.ApplyInfix(Apply);
    var include$6 = Relude__Relude_Extensions_Monad.MonadInfix(Monad);
    var Infix_FunctorExtensions = include$4.FunctorExtensions;
    var Infix_$less$$great = include$4.$less$$great;
    var Infix_$less$$$great = include$4.$less$$$great;
    var Infix_$less$ = include$4.$less$;
    var Infix_$$great = include$4.$$great;
    var Infix_$less$at$great = include$4.$less$at$great;
    var Infix_ApplyExtensions = include$5.ApplyExtensions;
    var Infix_$less$star$great = include$5.$less$star$great;
    var Infix_$less$star = include$5.$less$star;
    var Infix_$star$great = include$5.$star$great;
    var Infix_MonadExtensions = include$6.MonadExtensions;
    var Infix_$great$great$eq = include$6.$great$great$eq;
    var Infix_$eq$less$less = include$6.$eq$less$less;
    var Infix_$great$eq$great = include$6.$great$eq$great;
    var Infix_$less$eq$less = include$6.$less$eq$less;
    var Infix = {
      FunctorExtensions: Infix_FunctorExtensions,
      $less$$great: Infix_$less$$great,
      $less$$$great: Infix_$less$$$great,
      $less$: Infix_$less$,
      $$great: Infix_$$great,
      $less$at$great: Infix_$less$at$great,
      ApplyExtensions: Infix_ApplyExtensions,
      $less$star$great: Infix_$less$star$great,
      $less$star: Infix_$less$star,
      $star$great: Infix_$star$great,
      MonadExtensions: Infix_MonadExtensions,
      $great$great$eq: Infix_$great$great$eq,
      $eq$less$less: Infix_$eq$less$less,
      $great$eq$great: Infix_$great$eq$great,
      $less$eq$less: Infix_$less$eq$less
    };
    return {
            make: make,
            runWriterT: runWriterT,
            execWriterT: execWriterT,
            mapWriterT: mapWriterT,
            tell: tell,
            listen: listen,
            listens: listens,
            pass: pass,
            censor: censor,
            Functor: Functor,
            map: map,
            BsFunctorExtensions: include.BsFunctorExtensions,
            flipMap: include.flipMap,
            $$void: include.$$void,
            voidRight: include.voidRight,
            voidLeft: include.voidLeft,
            flap: include.flap,
            Apply: Apply,
            apply: apply,
            BsApplyExtensions: include$1.BsApplyExtensions,
            applyFirst: include$1.applyFirst,
            applySecond: include$1.applySecond,
            map2: include$1.map2,
            map3: include$1.map3,
            map4: include$1.map4,
            map5: include$1.map5,
            tuple2: include$1.tuple2,
            tuple3: include$1.tuple3,
            tuple4: include$1.tuple4,
            tuple5: include$1.tuple5,
            mapTuple2: include$1.mapTuple2,
            mapTuple3: include$1.mapTuple3,
            mapTuple4: include$1.mapTuple4,
            mapTuple5: include$1.mapTuple5,
            Applicative: Applicative,
            pure: pure,
            BsApplicativeExtensions: include$2.BsApplicativeExtensions,
            liftA1: include$2.liftA1,
            all: include$2.all,
            Monad: Monad,
            bind: flat_map,
            BsMonadExtensions: include$3.BsMonadExtensions,
            flatMap: include$3.flatMap,
            flatten: include$3.flatten,
            composeKleisli: include$3.composeKleisli,
            flipComposeKleisli: include$3.flipComposeKleisli,
            liftM1: include$3.liftM1,
            when_: include$3.when_,
            unless: include$3.unless,
            Infix: Infix
          };
  };
  return {
          make: make,
          runWriterT: runWriterT,
          execWriterT: execWriterT,
          mapWriterT: mapWriterT,
          tell: tell,
          listen: listen,
          pass: pass,
          listens: listens,
          censor: censor,
          map: map,
          applyWithAppendLog: applyWithAppendLog,
          pureWithEmptyLog: pureWithEmptyLog,
          bindWithAppendLog: bindWithAppendLog,
          WithLog: WithLog
        };
}

function WithMonadAndLog(Monad, Log) {
  var make = function (mWriter) {
    return /* WriterT */{
            _0: mWriter
          };
  };
  var runWriterT = function (mWriter) {
    return mWriter._0;
  };
  var execWriterT = function (mWriter) {
    return Curry._2(Monad.map, (function (prim) {
                  return prim[1];
                }), mWriter._0);
  };
  var mapWriterT = function (mAToMB, mA) {
    return /* WriterT */{
            _0: Curry._1(mAToMB, mA._0)
          };
  };
  var tell = function (w) {
    return /* WriterT */{
            _0: Curry._1(Monad.pure, [
                  undefined,
                  w
                ])
          };
  };
  var listen = function (mAW) {
    return /* WriterT */{
            _0: Curry._2(Monad.map, (function (param) {
                    var w = param[1];
                    return [
                            [
                              param[0],
                              w
                            ],
                            w
                          ];
                  }), mAW._0)
          };
  };
  var pass = function (m) {
    return /* WriterT */{
            _0: Curry._2(Monad.map, (function (param) {
                    var match = param[0];
                    return [
                            match[0],
                            Curry._1(match[1], param[1])
                          ];
                  }), m._0)
          };
  };
  var listens = function (w1ToW2, writerTMAW1) {
    var m = listen(writerTMAW1);
    return /* WriterT */{
            _0: Curry._2(Monad.map, (function (param) {
                    var match = param[0];
                    var w1 = match[1];
                    return [
                            [
                              match[0],
                              Curry._1(w1ToW2, w1)
                            ],
                            w1
                          ];
                  }), m._0)
          };
  };
  var censor = function (wToW, mAW) {
    return pass(/* WriterT */{
                _0: Curry._2(Monad.map, (function (param) {
                        return [
                                [
                                  param[0],
                                  wToW
                                ],
                                param[1]
                              ];
                      }), mAW._0)
              });
  };
  var map = function (aToB, mAW) {
    return /* WriterT */{
            _0: Curry._2(Monad.map, (function (param) {
                    return [
                            Curry._1(aToB, param[0]),
                            param[1]
                          ];
                  }), mAW._0)
          };
  };
  var applyWithAppendLog = function (appendLog, mAToBW, mAW) {
    return /* WriterT */{
            _0: Curry._2(Monad.apply, Curry._2(Monad.map, (function (param, param$1) {
                        return [
                                Curry._1(param[0], param$1[0]),
                                Curry._2(appendLog, param[1], param$1[1])
                              ];
                      }), mAToBW._0), mAW._0)
          };
  };
  var pureWithEmptyLog = function (empty, a) {
    return /* WriterT */{
            _0: Curry._1(Monad.pure, [
                  a,
                  empty
                ])
          };
  };
  var bindWithAppendLog = function (appendLog, mAW, aToWriterTBW) {
    return /* WriterT */{
            _0: Curry._2(Monad.flat_map, mAW._0, (function (param) {
                    var w1 = param[1];
                    var mBW = Curry._1(aToWriterTBW, param[0]);
                    return Curry._2(Monad.map, (function (param) {
                                  return [
                                          param[0],
                                          Curry._2(appendLog, w1, param[1])
                                        ];
                                }), mBW._0);
                  }))
          };
  };
  var WithLog = function (Log) {
    var Functor = {
      map: map
    };
    var include = Relude__Relude_Extensions_Functor.FunctorExtensions(Functor);
    var apply = function (ff, fa) {
      return applyWithAppendLog(Log.Monoid.append, ff, fa);
    };
    var Apply = {
      map: map,
      apply: apply
    };
    var include$1 = Relude__Relude_Extensions_Apply.ApplyExtensions(Apply);
    var pure = function (a) {
      return pureWithEmptyLog(Log.Monoid.empty, a);
    };
    var Applicative = {
      map: map,
      apply: apply,
      pure: pure
    };
    var include$2 = Relude__Relude_Extensions_Applicative.ApplicativeExtensions(Applicative);
    var flat_map = function (fa, f) {
      return bindWithAppendLog(Log.Monoid.append, fa, f);
    };
    var Monad = {
      map: map,
      apply: apply,
      pure: pure,
      flat_map: flat_map
    };
    var include$3 = Relude__Relude_Extensions_Monad.MonadExtensions(Monad);
    var include$4 = Relude__Relude_Extensions_Functor.FunctorInfix(Functor);
    var include$5 = Relude__Relude_Extensions_Apply.ApplyInfix(Apply);
    var include$6 = Relude__Relude_Extensions_Monad.MonadInfix(Monad);
    var Infix_FunctorExtensions = include$4.FunctorExtensions;
    var Infix_$less$$great = include$4.$less$$great;
    var Infix_$less$$$great = include$4.$less$$$great;
    var Infix_$less$ = include$4.$less$;
    var Infix_$$great = include$4.$$great;
    var Infix_$less$at$great = include$4.$less$at$great;
    var Infix_ApplyExtensions = include$5.ApplyExtensions;
    var Infix_$less$star$great = include$5.$less$star$great;
    var Infix_$less$star = include$5.$less$star;
    var Infix_$star$great = include$5.$star$great;
    var Infix_MonadExtensions = include$6.MonadExtensions;
    var Infix_$great$great$eq = include$6.$great$great$eq;
    var Infix_$eq$less$less = include$6.$eq$less$less;
    var Infix_$great$eq$great = include$6.$great$eq$great;
    var Infix_$less$eq$less = include$6.$less$eq$less;
    var Infix = {
      FunctorExtensions: Infix_FunctorExtensions,
      $less$$great: Infix_$less$$great,
      $less$$$great: Infix_$less$$$great,
      $less$: Infix_$less$,
      $$great: Infix_$$great,
      $less$at$great: Infix_$less$at$great,
      ApplyExtensions: Infix_ApplyExtensions,
      $less$star$great: Infix_$less$star$great,
      $less$star: Infix_$less$star,
      $star$great: Infix_$star$great,
      MonadExtensions: Infix_MonadExtensions,
      $great$great$eq: Infix_$great$great$eq,
      $eq$less$less: Infix_$eq$less$less,
      $great$eq$great: Infix_$great$eq$great,
      $less$eq$less: Infix_$less$eq$less
    };
    return {
            make: make,
            runWriterT: runWriterT,
            execWriterT: execWriterT,
            mapWriterT: mapWriterT,
            tell: tell,
            listen: listen,
            listens: listens,
            pass: pass,
            censor: censor,
            Functor: Functor,
            map: map,
            BsFunctorExtensions: include.BsFunctorExtensions,
            flipMap: include.flipMap,
            $$void: include.$$void,
            voidRight: include.voidRight,
            voidLeft: include.voidLeft,
            flap: include.flap,
            Apply: Apply,
            apply: apply,
            BsApplyExtensions: include$1.BsApplyExtensions,
            applyFirst: include$1.applyFirst,
            applySecond: include$1.applySecond,
            map2: include$1.map2,
            map3: include$1.map3,
            map4: include$1.map4,
            map5: include$1.map5,
            tuple2: include$1.tuple2,
            tuple3: include$1.tuple3,
            tuple4: include$1.tuple4,
            tuple5: include$1.tuple5,
            mapTuple2: include$1.mapTuple2,
            mapTuple3: include$1.mapTuple3,
            mapTuple4: include$1.mapTuple4,
            mapTuple5: include$1.mapTuple5,
            Applicative: Applicative,
            pure: pure,
            BsApplicativeExtensions: include$2.BsApplicativeExtensions,
            liftA1: include$2.liftA1,
            all: include$2.all,
            Monad: Monad,
            bind: flat_map,
            BsMonadExtensions: include$3.BsMonadExtensions,
            flatMap: include$3.flatMap,
            flatten: include$3.flatten,
            composeKleisli: include$3.composeKleisli,
            flipComposeKleisli: include$3.flipComposeKleisli,
            liftM1: include$3.liftM1,
            when_: include$3.when_,
            unless: include$3.unless,
            Infix: Infix
          };
  };
  var WithMonad = {
    make: make,
    runWriterT: runWriterT,
    execWriterT: execWriterT,
    mapWriterT: mapWriterT,
    tell: tell,
    listen: listen,
    pass: pass,
    listens: listens,
    censor: censor,
    map: map,
    applyWithAppendLog: applyWithAppendLog,
    pureWithEmptyLog: pureWithEmptyLog,
    bindWithAppendLog: bindWithAppendLog,
    WithLog: WithLog
  };
  var Functor = {
    map: map
  };
  var include = Relude__Relude_Extensions_Functor.FunctorExtensions(Functor);
  var apply = function (ff, fa) {
    return applyWithAppendLog(Log.Monoid.append, ff, fa);
  };
  var Apply = {
    map: map,
    apply: apply
  };
  var include$1 = Relude__Relude_Extensions_Apply.ApplyExtensions(Apply);
  var pure = function (a) {
    return pureWithEmptyLog(Log.Monoid.empty, a);
  };
  var Applicative = {
    map: map,
    apply: apply,
    pure: pure
  };
  var include$2 = Relude__Relude_Extensions_Applicative.ApplicativeExtensions(Applicative);
  var flat_map = function (fa, f) {
    return bindWithAppendLog(Log.Monoid.append, fa, f);
  };
  var Monad$1 = {
    map: map,
    apply: apply,
    pure: pure,
    flat_map: flat_map
  };
  var include$3 = Relude__Relude_Extensions_Monad.MonadExtensions(Monad$1);
  var include$4 = Relude__Relude_Extensions_Functor.FunctorInfix(Functor);
  var include$5 = Relude__Relude_Extensions_Apply.ApplyInfix(Apply);
  var include$6 = Relude__Relude_Extensions_Monad.MonadInfix(Monad$1);
  var Infix_FunctorExtensions = include$4.FunctorExtensions;
  var Infix_$less$$great = include$4.$less$$great;
  var Infix_$less$$$great = include$4.$less$$$great;
  var Infix_$less$ = include$4.$less$;
  var Infix_$$great = include$4.$$great;
  var Infix_$less$at$great = include$4.$less$at$great;
  var Infix_ApplyExtensions = include$5.ApplyExtensions;
  var Infix_$less$star$great = include$5.$less$star$great;
  var Infix_$less$star = include$5.$less$star;
  var Infix_$star$great = include$5.$star$great;
  var Infix_MonadExtensions = include$6.MonadExtensions;
  var Infix_$great$great$eq = include$6.$great$great$eq;
  var Infix_$eq$less$less = include$6.$eq$less$less;
  var Infix_$great$eq$great = include$6.$great$eq$great;
  var Infix_$less$eq$less = include$6.$less$eq$less;
  var Infix = {
    FunctorExtensions: Infix_FunctorExtensions,
    $less$$great: Infix_$less$$great,
    $less$$$great: Infix_$less$$$great,
    $less$: Infix_$less$,
    $$great: Infix_$$great,
    $less$at$great: Infix_$less$at$great,
    ApplyExtensions: Infix_ApplyExtensions,
    $less$star$great: Infix_$less$star$great,
    $less$star: Infix_$less$star,
    $star$great: Infix_$star$great,
    MonadExtensions: Infix_MonadExtensions,
    $great$great$eq: Infix_$great$great$eq,
    $eq$less$less: Infix_$eq$less$less,
    $great$eq$great: Infix_$great$eq$great,
    $less$eq$less: Infix_$less$eq$less
  };
  var include_BsFunctorExtensions = include.BsFunctorExtensions;
  var include_flipMap = include.flipMap;
  var include_void = include.$$void;
  var include_voidRight = include.voidRight;
  var include_voidLeft = include.voidLeft;
  var include_flap = include.flap;
  var include_BsApplyExtensions = include$1.BsApplyExtensions;
  var include_applyFirst = include$1.applyFirst;
  var include_applySecond = include$1.applySecond;
  var include_map2 = include$1.map2;
  var include_map3 = include$1.map3;
  var include_map4 = include$1.map4;
  var include_map5 = include$1.map5;
  var include_tuple2 = include$1.tuple2;
  var include_tuple3 = include$1.tuple3;
  var include_tuple4 = include$1.tuple4;
  var include_tuple5 = include$1.tuple5;
  var include_mapTuple2 = include$1.mapTuple2;
  var include_mapTuple3 = include$1.mapTuple3;
  var include_mapTuple4 = include$1.mapTuple4;
  var include_mapTuple5 = include$1.mapTuple5;
  var include_BsApplicativeExtensions = include$2.BsApplicativeExtensions;
  var include_liftA1 = include$2.liftA1;
  var include_all = include$2.all;
  var include_BsMonadExtensions = include$3.BsMonadExtensions;
  var include_flatMap = include$3.flatMap;
  var include_flatten = include$3.flatten;
  var include_composeKleisli = include$3.composeKleisli;
  var include_flipComposeKleisli = include$3.flipComposeKleisli;
  var include_liftM1 = include$3.liftM1;
  var include_when_ = include$3.when_;
  var include_unless = include$3.unless;
  return {
          WithMonad: WithMonad,
          make: make,
          runWriterT: runWriterT,
          execWriterT: execWriterT,
          mapWriterT: mapWriterT,
          tell: tell,
          listen: listen,
          listens: listens,
          pass: pass,
          censor: censor,
          Functor: Functor,
          map: map,
          BsFunctorExtensions: include_BsFunctorExtensions,
          flipMap: include_flipMap,
          $$void: include_void,
          voidRight: include_voidRight,
          voidLeft: include_voidLeft,
          flap: include_flap,
          Apply: Apply,
          apply: apply,
          BsApplyExtensions: include_BsApplyExtensions,
          applyFirst: include_applyFirst,
          applySecond: include_applySecond,
          map2: include_map2,
          map3: include_map3,
          map4: include_map4,
          map5: include_map5,
          tuple2: include_tuple2,
          tuple3: include_tuple3,
          tuple4: include_tuple4,
          tuple5: include_tuple5,
          mapTuple2: include_mapTuple2,
          mapTuple3: include_mapTuple3,
          mapTuple4: include_mapTuple4,
          mapTuple5: include_mapTuple5,
          Applicative: Applicative,
          pure: pure,
          BsApplicativeExtensions: include_BsApplicativeExtensions,
          liftA1: include_liftA1,
          all: include_all,
          Monad: Monad$1,
          bind: flat_map,
          BsMonadExtensions: include_BsMonadExtensions,
          flatMap: include_flatMap,
          flatten: include_flatten,
          composeKleisli: include_composeKleisli,
          flipComposeKleisli: include_flipComposeKleisli,
          liftM1: include_liftM1,
          when_: include_when_,
          unless: include_unless,
          Infix: Infix
        };
}

function make(mWriter) {
  return /* WriterT */{
          _0: mWriter
        };
}

function runWriterT(mWriter) {
  return mWriter._0;
}

function execWriterT(mWriter) {
  return Curry._2(Relude__Relude_Identity.Monad.map, (function (prim) {
                return prim[1];
              }), mWriter._0);
}

function mapWriterT(mAToMB, mA) {
  return /* WriterT */{
          _0: Curry._1(mAToMB, mA._0)
        };
}

function tell(w) {
  return /* WriterT */{
          _0: Curry._1(Relude__Relude_Identity.Monad.pure, [
                undefined,
                w
              ])
        };
}

function listen(mAW) {
  return /* WriterT */{
          _0: Curry._2(Relude__Relude_Identity.Monad.map, (function (param) {
                  var w = param[1];
                  return [
                          [
                            param[0],
                            w
                          ],
                          w
                        ];
                }), mAW._0)
        };
}

function pass(m) {
  return /* WriterT */{
          _0: Curry._2(Relude__Relude_Identity.Monad.map, (function (param) {
                  var match = param[0];
                  return [
                          match[0],
                          Curry._1(match[1], param[1])
                        ];
                }), m._0)
        };
}

function listens(w1ToW2, writerTMAW1) {
  var m = listen(writerTMAW1);
  return /* WriterT */{
          _0: Curry._2(Relude__Relude_Identity.Monad.map, (function (param) {
                  var match = param[0];
                  var w1 = match[1];
                  return [
                          [
                            match[0],
                            Curry._1(w1ToW2, w1)
                          ],
                          w1
                        ];
                }), m._0)
        };
}

function censor(wToW, mAW) {
  return pass(/* WriterT */{
              _0: Curry._2(Relude__Relude_Identity.Monad.map, (function (param) {
                      return [
                              [
                                param[0],
                                wToW
                              ],
                              param[1]
                            ];
                    }), mAW._0)
            });
}

function map(aToB, mAW) {
  return /* WriterT */{
          _0: Curry._2(Relude__Relude_Identity.Monad.map, (function (param) {
                  return [
                          Curry._1(aToB, param[0]),
                          param[1]
                        ];
                }), mAW._0)
        };
}

function applyWithAppendLog(appendLog, mAToBW, mAW) {
  return /* WriterT */{
          _0: Curry._2(Relude__Relude_Identity.Monad.apply, Curry._2(Relude__Relude_Identity.Monad.map, (function (param, param$1) {
                      return [
                              Curry._1(param[0], param$1[0]),
                              Curry._2(appendLog, param[1], param$1[1])
                            ];
                    }), mAToBW._0), mAW._0)
        };
}

function pureWithEmptyLog(empty, a) {
  return /* WriterT */{
          _0: Curry._1(Relude__Relude_Identity.Monad.pure, [
                a,
                empty
              ])
        };
}

function bindWithAppendLog(appendLog, mAW, aToWriterTBW) {
  return /* WriterT */{
          _0: Curry._2(Relude__Relude_Identity.Monad.flat_map, mAW._0, (function (param) {
                  var w1 = param[1];
                  var mBW = Curry._1(aToWriterTBW, param[0]);
                  return Curry._2(Relude__Relude_Identity.Monad.map, (function (param) {
                                return [
                                        param[0],
                                        Curry._2(appendLog, w1, param[1])
                                      ];
                              }), mBW._0);
                }))
        };
}

function WithLog(Log) {
  var Functor = {
    map: map
  };
  var include = Relude__Relude_Extensions_Functor.FunctorExtensions(Functor);
  var apply = function (ff, fa) {
    return applyWithAppendLog(Log.Monoid.append, ff, fa);
  };
  var Apply = {
    map: map,
    apply: apply
  };
  var include$1 = Relude__Relude_Extensions_Apply.ApplyExtensions(Apply);
  var pure = function (a) {
    return pureWithEmptyLog(Log.Monoid.empty, a);
  };
  var Applicative = {
    map: map,
    apply: apply,
    pure: pure
  };
  var include$2 = Relude__Relude_Extensions_Applicative.ApplicativeExtensions(Applicative);
  var flat_map = function (fa, f) {
    return bindWithAppendLog(Log.Monoid.append, fa, f);
  };
  var Monad = {
    map: map,
    apply: apply,
    pure: pure,
    flat_map: flat_map
  };
  var include$3 = Relude__Relude_Extensions_Monad.MonadExtensions(Monad);
  var include$4 = Relude__Relude_Extensions_Functor.FunctorInfix(Functor);
  var include$5 = Relude__Relude_Extensions_Apply.ApplyInfix(Apply);
  var include$6 = Relude__Relude_Extensions_Monad.MonadInfix(Monad);
  var Infix_FunctorExtensions = include$4.FunctorExtensions;
  var Infix_$less$$great = include$4.$less$$great;
  var Infix_$less$$$great = include$4.$less$$$great;
  var Infix_$less$ = include$4.$less$;
  var Infix_$$great = include$4.$$great;
  var Infix_$less$at$great = include$4.$less$at$great;
  var Infix_ApplyExtensions = include$5.ApplyExtensions;
  var Infix_$less$star$great = include$5.$less$star$great;
  var Infix_$less$star = include$5.$less$star;
  var Infix_$star$great = include$5.$star$great;
  var Infix_MonadExtensions = include$6.MonadExtensions;
  var Infix_$great$great$eq = include$6.$great$great$eq;
  var Infix_$eq$less$less = include$6.$eq$less$less;
  var Infix_$great$eq$great = include$6.$great$eq$great;
  var Infix_$less$eq$less = include$6.$less$eq$less;
  var Infix = {
    FunctorExtensions: Infix_FunctorExtensions,
    $less$$great: Infix_$less$$great,
    $less$$$great: Infix_$less$$$great,
    $less$: Infix_$less$,
    $$great: Infix_$$great,
    $less$at$great: Infix_$less$at$great,
    ApplyExtensions: Infix_ApplyExtensions,
    $less$star$great: Infix_$less$star$great,
    $less$star: Infix_$less$star,
    $star$great: Infix_$star$great,
    MonadExtensions: Infix_MonadExtensions,
    $great$great$eq: Infix_$great$great$eq,
    $eq$less$less: Infix_$eq$less$less,
    $great$eq$great: Infix_$great$eq$great,
    $less$eq$less: Infix_$less$eq$less
  };
  return {
          make: make,
          runWriterT: runWriterT,
          execWriterT: execWriterT,
          mapWriterT: mapWriterT,
          tell: tell,
          listen: listen,
          listens: listens,
          pass: pass,
          censor: censor,
          Functor: Functor,
          map: map,
          BsFunctorExtensions: include.BsFunctorExtensions,
          flipMap: include.flipMap,
          $$void: include.$$void,
          voidRight: include.voidRight,
          voidLeft: include.voidLeft,
          flap: include.flap,
          Apply: Apply,
          apply: apply,
          BsApplyExtensions: include$1.BsApplyExtensions,
          applyFirst: include$1.applyFirst,
          applySecond: include$1.applySecond,
          map2: include$1.map2,
          map3: include$1.map3,
          map4: include$1.map4,
          map5: include$1.map5,
          tuple2: include$1.tuple2,
          tuple3: include$1.tuple3,
          tuple4: include$1.tuple4,
          tuple5: include$1.tuple5,
          mapTuple2: include$1.mapTuple2,
          mapTuple3: include$1.mapTuple3,
          mapTuple4: include$1.mapTuple4,
          mapTuple5: include$1.mapTuple5,
          Applicative: Applicative,
          pure: pure,
          BsApplicativeExtensions: include$2.BsApplicativeExtensions,
          liftA1: include$2.liftA1,
          all: include$2.all,
          Monad: Monad,
          bind: flat_map,
          BsMonadExtensions: include$3.BsMonadExtensions,
          flatMap: include$3.flatMap,
          flatten: include$3.flatten,
          composeKleisli: include$3.composeKleisli,
          flipComposeKleisli: include$3.flipComposeKleisli,
          liftM1: include$3.liftM1,
          when_: include$3.when_,
          unless: include$3.unless,
          Infix: Infix
        };
}

var Writer = {
  make: make,
  runWriterT: runWriterT,
  execWriterT: execWriterT,
  mapWriterT: mapWriterT,
  tell: tell,
  listen: listen,
  pass: pass,
  listens: listens,
  censor: censor,
  map: map,
  applyWithAppendLog: applyWithAppendLog,
  pureWithEmptyLog: pureWithEmptyLog,
  bindWithAppendLog: bindWithAppendLog,
  WithLog: WithLog
};

exports.WriterLog = WriterLog;
exports.WithMonad = WithMonad;
exports.WithMonadAndLog = WithMonadAndLog;
exports.Writer = Writer;
/* Relude__Relude_List Not a pure module */
