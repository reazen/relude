// Generated by Melange
'use strict';

var Curry = require("melange.runtime/curry.js");
var Caml_option = require("melange.runtime/caml_option.js");
var Relude__Relude_Option = require("./Relude_Option.js");
var Relude__Relude_Extensions_Apply = require("./extensions/Relude_Extensions_Apply.js");
var Relude__Relude_Extensions_Monad = require("./extensions/Relude_Extensions_Monad.js");
var Relude__Relude_Extensions_Functor = require("./extensions/Relude_Extensions_Functor.js");
var Relude__Relude_Extensions_Applicative = require("./extensions/Relude_Extensions_Applicative.js");

function WithMonad(M) {
  var make = function (mOptionA) {
    return /* OptionT */{
            _0: mOptionA
          };
  };
  var runOptionT = function (mOptionA) {
    return mOptionA._0;
  };
  var mapOptionT = function (mOptionAToMOptionB, mOptionA) {
    return /* OptionT */{
            _0: Curry._1(mOptionAToMOptionB, mOptionA._0)
          };
  };
  var fromOption = function (optionA) {
    return /* OptionT */{
            _0: Curry._1(M.pure, optionA)
          };
  };
  var liftF = function (mA) {
    return /* OptionT */{
            _0: Curry._2(M.map, (function (a) {
                    return Caml_option.some(a);
                  }), mA)
          };
  };
  var map = function (aToB, mOptionA) {
    return /* OptionT */{
            _0: Curry._2(M.map, (function (optionA) {
                    return Relude__Relude_Option.map(aToB, optionA);
                  }), mOptionA._0)
          };
  };
  var subflatMap = function (aToB, mOptionA) {
    return /* OptionT */{
            _0: Curry._2(M.map, (function (optionA) {
                    return Curry._2(Relude__Relude_Option.flatMap, aToB, optionA);
                  }), mOptionA._0)
          };
  };
  var Functor = {
    map: map
  };
  var include = Relude__Relude_Extensions_Functor.FunctorExtensions(Functor);
  var apply = function (mOptionAToB, mOptionA) {
    return /* OptionT */{
            _0: Curry._2(M.apply, Curry._2(M.map, Relude__Relude_Option.apply, mOptionAToB._0), mOptionA._0)
          };
  };
  var Apply = {
    map: map,
    apply: apply
  };
  var include$1 = Relude__Relude_Extensions_Apply.ApplyExtensions(Apply);
  var pure = function (a) {
    return /* OptionT */{
            _0: Curry._1(M.pure, Caml_option.some(a))
          };
  };
  var Applicative = {
    map: map,
    apply: apply,
    pure: pure
  };
  var include$2 = Relude__Relude_Extensions_Applicative.ApplicativeExtensions(Applicative);
  var bind = function (mOptionA, aToOptionTB) {
    return /* OptionT */{
            _0: Curry._2(M.flat_map, mOptionA._0, (function (optionA) {
                    if (optionA !== undefined) {
                      return Curry._1(aToOptionTB, Caml_option.valFromOption(optionA))._0;
                    } else {
                      return Curry._1(M.pure, undefined);
                    }
                  }))
          };
  };
  var semiflatMap = function (aToMB, optionTA) {
    return bind(optionTA, (function (a) {
                  return liftF(Curry._1(aToMB, a));
                }));
  };
  var Monad = {
    map: map,
    apply: apply,
    pure: pure,
    flat_map: bind
  };
  var include$3 = Relude__Relude_Extensions_Monad.MonadExtensions(Monad);
  var include$4 = Relude__Relude_Extensions_Functor.FunctorInfix(Functor);
  var include$5 = Relude__Relude_Extensions_Apply.ApplyInfix(Apply);
  var include$6 = Relude__Relude_Extensions_Monad.MonadInfix(Monad);
  var Infix_FunctorExtensions = include$4.FunctorExtensions;
  var Infix_$less$$great = include$4.$less$$great;
  var Infix_$less$$$great = include$4.$less$$$great;
  var Infix_$less$ = include$4.$less$;
  var Infix_$$great = include$4.$$great;
  var Infix_$less$at$great = include$4.$less$at$great;
  var Infix_ApplyExtensions = include$5.ApplyExtensions;
  var Infix_$less$star$great = include$5.$less$star$great;
  var Infix_$less$star = include$5.$less$star;
  var Infix_$star$great = include$5.$star$great;
  var Infix_MonadExtensions = include$6.MonadExtensions;
  var Infix_$great$great$eq = include$6.$great$great$eq;
  var Infix_$eq$less$less = include$6.$eq$less$less;
  var Infix_$great$eq$great = include$6.$great$eq$great;
  var Infix_$less$eq$less = include$6.$less$eq$less;
  var Infix = {
    FunctorExtensions: Infix_FunctorExtensions,
    $less$$great: Infix_$less$$great,
    $less$$$great: Infix_$less$$$great,
    $less$: Infix_$less$,
    $$great: Infix_$$great,
    $less$at$great: Infix_$less$at$great,
    ApplyExtensions: Infix_ApplyExtensions,
    $less$star$great: Infix_$less$star$great,
    $less$star: Infix_$less$star,
    $star$great: Infix_$star$great,
    MonadExtensions: Infix_MonadExtensions,
    $great$great$eq: Infix_$great$great$eq,
    $eq$less$less: Infix_$eq$less$less,
    $great$eq$great: Infix_$great$eq$great,
    $less$eq$less: Infix_$less$eq$less
  };
  return {
          make: make,
          runOptionT: runOptionT,
          mapOptionT: mapOptionT,
          fromOption: fromOption,
          liftF: liftF,
          map: map,
          subflatMap: subflatMap,
          Functor: Functor,
          BsFunctorExtensions: include.BsFunctorExtensions,
          flipMap: include.flipMap,
          $$void: include.$$void,
          voidRight: include.voidRight,
          voidLeft: include.voidLeft,
          flap: include.flap,
          apply: apply,
          Apply: Apply,
          BsApplyExtensions: include$1.BsApplyExtensions,
          applyFirst: include$1.applyFirst,
          applySecond: include$1.applySecond,
          map2: include$1.map2,
          map3: include$1.map3,
          map4: include$1.map4,
          map5: include$1.map5,
          tuple2: include$1.tuple2,
          tuple3: include$1.tuple3,
          tuple4: include$1.tuple4,
          tuple5: include$1.tuple5,
          mapTuple2: include$1.mapTuple2,
          mapTuple3: include$1.mapTuple3,
          mapTuple4: include$1.mapTuple4,
          mapTuple5: include$1.mapTuple5,
          pure: pure,
          Applicative: Applicative,
          BsApplicativeExtensions: include$2.BsApplicativeExtensions,
          liftA1: include$2.liftA1,
          all: include$2.all,
          bind: bind,
          semiflatMap: semiflatMap,
          Monad: Monad,
          BsMonadExtensions: include$3.BsMonadExtensions,
          flatMap: include$3.flatMap,
          flatten: include$3.flatten,
          composeKleisli: include$3.composeKleisli,
          flipComposeKleisli: include$3.flipComposeKleisli,
          liftM1: include$3.liftM1,
          when_: include$3.when_,
          unless: include$3.unless,
          Infix: Infix
        };
}

exports.WithMonad = WithMonad;
/* Relude__Relude_Option Not a pure module */
