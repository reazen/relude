// Generated by Melange
'use strict';

var Curry = require("melange.runtime/curry.js");
var Caml_option = require("melange.runtime/caml_option.js");
var Stdlib__List = require("melange/./list.js");

function listAppend(value, list) {
  return Stdlib__List.concat({
              hd: list,
              tl: {
                hd: {
                  hd: value,
                  tl: /* [] */0
                },
                tl: /* [] */0
              }
            });
}

function EnumExtensions(E) {
  var fromToAsList = function (start, finish) {
    var _acc = /* [] */0;
    var _current = start;
    while(true) {
      var current = _current;
      var acc = _acc;
      var match = Curry._2(E.compare, current, finish);
      if (match === "greater_than") {
        var prev = Curry._1(E.pred, current);
        if (prev === undefined) {
          return listAppend(current, acc);
        }
        _current = Caml_option.valFromOption(prev);
        _acc = listAppend(current, acc);
        continue ;
      }
      if (match !== "less_than") {
        return listAppend(current, acc);
      }
      var next = Curry._1(E.succ, current);
      if (next === undefined) {
        return listAppend(current, acc);
      }
      _current = Caml_option.valFromOption(next);
      _acc = listAppend(current, acc);
      continue ;
    };
  };
  var upFromAsList = function (start) {
    var next = Curry._1(E.succ, start);
    if (next !== undefined) {
      var _acc = /* [] */0;
      var _current = Caml_option.valFromOption(next);
      while(true) {
        var current = _current;
        var acc = _acc;
        var next$1 = Curry._1(E.succ, current);
        if (next$1 === undefined) {
          return listAppend(current, acc);
        }
        _current = Caml_option.valFromOption(next$1);
        _acc = listAppend(current, acc);
        continue ;
      };
    } else {
      return /* [] */0;
    }
  };
  var upFromIncludingAsList = function (start) {
    var _acc = /* [] */0;
    var _current = start;
    while(true) {
      var current = _current;
      var acc = _acc;
      var next = Curry._1(E.succ, current);
      if (next === undefined) {
        return listAppend(current, acc);
      }
      _current = Caml_option.valFromOption(next);
      _acc = listAppend(current, acc);
      continue ;
    };
  };
  var downFromAsList = function (start) {
    var next = Curry._1(E.pred, start);
    if (next !== undefined) {
      var _acc = /* [] */0;
      var _current = Caml_option.valFromOption(next);
      while(true) {
        var current = _current;
        var acc = _acc;
        var prev = Curry._1(E.pred, current);
        if (prev === undefined) {
          return listAppend(current, acc);
        }
        _current = Caml_option.valFromOption(prev);
        _acc = listAppend(current, acc);
        continue ;
      };
    } else {
      return /* [] */0;
    }
  };
  var downFromIncludingAsList = function (start) {
    var _acc = /* [] */0;
    var _current = start;
    while(true) {
      var current = _current;
      var acc = _acc;
      var prev = Curry._1(E.pred, current);
      if (prev === undefined) {
        return listAppend(current, acc);
      }
      _current = Caml_option.valFromOption(prev);
      _acc = listAppend(current, acc);
      continue ;
    };
  };
  return {
          fromToAsList: fromToAsList,
          upFromAsList: upFromAsList,
          upFromIncludingAsList: upFromIncludingAsList,
          downFromAsList: downFromAsList,
          downFromIncludingAsList: downFromIncludingAsList
        };
}

exports.listAppend = listAppend;
exports.EnumExtensions = EnumExtensions;
/* No side effect */
