// Generated by Melange
'use strict';

var Curry = require("melange.runtime/curry.js");
var Caml_option = require("melange.runtime/caml_option.js");
var Stdlib__Map = require("melange/./map.js");
var Stdlib__List = require("melange/./list.js");
var Bastet__String = require("bastet/./String.js");
var Relude__Relude_List_Instances = require("../list/Relude_List_Instances.js");
var Relude__Relude_Extensions_Enum = require("./Relude_Extensions_Enum.js");
var Relude__Relude_Option_Instances = require("../option/Relude_Option_Instances.js");

function listAppend(value, list) {
  return Stdlib__List.concat({
              hd: list,
              tl: {
                hd: {
                  hd: value,
                  tl: /* [] */0
                },
                tl: /* [] */0
              }
            });
}

function BoundedEnumExtensions(E) {
  var include = Relude__Relude_Extensions_Enum.EnumExtensions({
        eq: E.eq,
        compare: E.compare,
        succ: E.succ,
        pred: E.pred
      });
  var upFromIncludingAsList = include.upFromIncludingAsList;
  var fromThenToAsList = function (start, next, finish) {
    var startInt = Curry._1(E.fromEnum, start);
    var nextInt = Curry._1(E.fromEnum, next);
    var stepInt = nextInt - startInt | 0;
    var _acc = /* [] */0;
    var _current = start;
    var _currentInt = startInt;
    while(true) {
      var currentInt = _currentInt;
      var current = _current;
      var acc = _acc;
      var match = Curry._2(E.compare, current, finish);
      if (!(match === "less_than" || match === "greater_than")) {
        return listAppend(current, acc);
      }
      var nextInt$1 = currentInt + stepInt | 0;
      var next$1 = Curry._1(E.toEnum, nextInt$1);
      if (next$1 === undefined) {
        return listAppend(current, acc);
      }
      _currentInt = nextInt$1;
      _current = Caml_option.valFromOption(next$1);
      _acc = listAppend(current, acc);
      continue ;
    };
  };
  var inverseMapEqBy = function (eqA, eToA) {
    var lookupList = Relude__Relude_List_Instances.map(function (e) {
            return [
                    Curry._1(eToA, e),
                    e
                  ];
          })(Curry._1(upFromIncludingAsList, E.bottom));
    return function (a) {
      return Relude__Relude_Option_Instances.map((function (prim) {
                    return prim[1];
                  }), Curry._2(Relude__Relude_List_Instances.find, (function (param) {
                        return Curry._2(eqA, param[0], a);
                      }), lookupList));
    };
  };
  var inverseMapEq = function (eqA, eToA) {
    return inverseMapEqBy(eqA.eq, eToA);
  };
  var inverseMapOrdBy = function (compareA, eToA) {
    var compare = function (a, b) {
      var match = Curry._2(compareA, a, b);
      if (match === "greater_than") {
        return 1;
      } else if (match === "less_than") {
        return -1;
      } else {
        return 0;
      }
    };
    var M = Stdlib__Map.Make({
          compare: compare
        });
    var lookupMap = Relude__Relude_List_Instances.foldRight((function (e, acc) {
              return Curry._3(M.add, Curry._1(eToA, e), e, acc);
            }), M.empty)(Curry._1(upFromIncludingAsList, E.bottom));
    return function (a) {
      return Curry._2(M.find_opt, a, lookupMap);
    };
  };
  var inverseMapOrd = function (ordA, eToA) {
    return inverseMapOrdBy(ordA.compare, eToA);
  };
  var inverseMapString = function (eToString) {
    return inverseMapOrdBy(Bastet__String.Ord.compare, eToString);
  };
  return {
          fromToAsList: include.fromToAsList,
          upFromAsList: include.upFromAsList,
          upFromIncludingAsList: upFromIncludingAsList,
          downFromAsList: include.downFromAsList,
          downFromIncludingAsList: include.downFromIncludingAsList,
          fromThenToAsList: fromThenToAsList,
          inverseMapEqBy: inverseMapEqBy,
          inverseMapEq: inverseMapEq,
          inverseMapOrdBy: inverseMapOrdBy,
          inverseMapOrd: inverseMapOrd,
          inverseMapString: inverseMapString
        };
}

exports.listAppend = listAppend;
exports.BoundedEnumExtensions = BoundedEnumExtensions;
/* Bastet__String Not a pure module */
