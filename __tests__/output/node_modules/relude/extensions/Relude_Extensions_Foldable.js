// Generated by Melange
'use strict';

var Curry = require("melange.runtime/curry.js");
var Belt_Array = require("melange.belt/./belt_Array.js");
var Caml_option = require("melange.runtime/caml_option.js");
var Bastet__Functions = require("bastet/./Functions.js");
var Relude__Relude_Ord = require("../Relude_Ord.js");

function optionAlt(a, b) {
  if (a !== undefined) {
    return a;
  } else {
    return b;
  }
}

function FoldableExtensions(F) {
  var BsFoldableExtensions = Bastet__Functions.Foldable(F);
  var any = function (f, xs) {
    return Curry._3(F.fold_left, (function (v, x) {
                  if (v) {
                    return true;
                  } else {
                    return Curry._1(f, x);
                  }
                }), false, xs);
  };
  var all = function (f, xs) {
    return Curry._3(F.fold_left, (function (v, x) {
                  if (v) {
                    return Curry._1(f, x);
                  } else {
                    return false;
                  }
                }), true, xs);
  };
  var containsBy = function (f, x, xs) {
    return any(Curry._1(f, x), xs);
  };
  var contains = function (eqA, x, xs) {
    return any(Curry._1(eqA.eq, x), xs);
  };
  var indexOfBy = function (f, x, xs) {
    return Curry._3(F.fold_left, (function (param, y) {
                    var i = param[0];
                    return [
                            i + 1 | 0,
                            optionAlt(param[1], Curry._2(f, x, y) ? i : undefined)
                          ];
                  }), [
                  0,
                  undefined
                ], xs)[1];
  };
  var indexOf = function (eqA, x, xs) {
    return indexOfBy(eqA.eq, x, xs);
  };
  var minBy = function (f, xs) {
    return Curry._3(F.fold_left, (function (min, x) {
                  if (min !== undefined) {
                    return Caml_option.some(Relude__Relude_Ord.minBy(f, x, Caml_option.valFromOption(min)));
                  } else {
                    return Caml_option.some(x);
                  }
                }), undefined, xs);
  };
  var min = function (ordA, xs) {
    return minBy(ordA.compare, xs);
  };
  var maxBy = function (f, xs) {
    return Curry._3(F.fold_left, (function (min, x) {
                  if (min === undefined) {
                    return Caml_option.some(x);
                  }
                  var y = Caml_option.valFromOption(min);
                  if (Curry._2(f, x, y) === "greater_than") {
                    return Caml_option.some(x);
                  } else {
                    return Caml_option.some(y);
                  }
                }), undefined, xs);
  };
  var max = function (ordA, xs) {
    return maxBy(ordA.compare, xs);
  };
  var countBy = function (f, xs) {
    return Curry._3(F.fold_left, (function (count, x) {
                  if (Curry._1(f, x)) {
                    return count + 1 | 0;
                  } else {
                    return count;
                  }
                }), 0, xs);
  };
  var length = function (xs) {
    return countBy((function (param) {
                  return true;
                }), xs);
  };
  var forEach = function (f, xs) {
    Curry._3(F.fold_left, (function (param, x) {
            Curry._1(f, x);
          }), undefined, xs);
  };
  var forEachWithIndex = function (f, xs) {
    Curry._3(F.fold_left, (function (i, x) {
            Curry._2(f, x, i);
            return i + 1 | 0;
          }), 0, xs);
  };
  var find = function (f) {
    return Curry._2(F.fold_left, (function (v, x) {
                  return optionAlt(v, Curry._1(f, x) ? Caml_option.some(x) : undefined);
                }), undefined);
  };
  var findWithIndex = function (f, xs) {
    return Curry._3(F.fold_left, (function (param, x) {
                    var i = param[0];
                    return [
                            i + 1 | 0,
                            optionAlt(param[1], Curry._2(f, x, i) ? Caml_option.some(x) : undefined)
                          ];
                  }), [
                  0,
                  undefined
                ], xs)[1];
  };
  var toList = function (fa) {
    return Curry._3(F.fold_right, (function (a, acc) {
                  return {
                          hd: a,
                          tl: acc
                        };
                }), /* [] */0, fa);
  };
  var toArray = function (fa) {
    return Curry._3(F.fold_left, (function (acc, a) {
                  return Belt_Array.concat(acc, [a]);
                }), [], fa);
  };
  var FoldableSemigroupExtensions = function (S) {
    var BsFoldableSemigroupExtensions = Curry._1(BsFoldableExtensions.Semigroup, S);
    return {
            BsFoldableSemigroupExtensions: BsFoldableSemigroupExtensions,
            surroundMap: BsFoldableSemigroupExtensions.surround_map,
            surround: BsFoldableSemigroupExtensions.surround
          };
  };
  var FoldableMonoidExtensions = function (M) {
    var BsFoldableMonoidExtensions = Curry._1(BsFoldableExtensions.Monoid, M);
    var foldMap = BsFoldableMonoidExtensions.FM.fold_map;
    var intercalate = function (sep, xs) {
      return Curry._3(F.fold_left, (function (param, x) {
                      if (param[0]) {
                        return [
                                false,
                                x
                              ];
                      } else {
                        return [
                                false,
                                Curry._2(M.append, param[1], Curry._2(M.append, sep, x))
                              ];
                      }
                    }), [
                    true,
                    M.empty
                  ], xs)[1];
    };
    return {
            BsFoldableMonoidExtensions: BsFoldableMonoidExtensions,
            foldMap: foldMap,
            foldWithMonoid: BsFoldableMonoidExtensions.fold,
            intercalate: intercalate
          };
  };
  var foldMap = function (monoidA, f, xs) {
    var BsFoldableMonoidExtensions = Curry._1(BsFoldableExtensions.Monoid, monoidA);
    var foldMap$1 = BsFoldableMonoidExtensions.FM.fold_map;
    return Curry._2(foldMap$1, f, xs);
  };
  var foldWithMonoid = function (monoidA, xs) {
    var BsFoldableMonoidExtensions = Curry._1(BsFoldableExtensions.Monoid, monoidA);
    return Curry._1(BsFoldableMonoidExtensions.fold, xs);
  };
  var intercalate = function (monoidA, sep, xs) {
    Curry._1(BsFoldableExtensions.Monoid, monoidA);
    return Curry._3(F.fold_left, (function (param, x) {
                    if (param[0]) {
                      return [
                              false,
                              x
                            ];
                    } else {
                      return [
                              false,
                              Curry._2(monoidA.append, param[1], Curry._2(monoidA.append, sep, x))
                            ];
                    }
                  }), [
                  true,
                  monoidA.empty
                ], xs)[1];
  };
  var FoldableApplicativeExtensions = function (A) {
    var BsFoldableApplicativeExtensions = Curry._1(BsFoldableExtensions.Applicative, A);
    return {
            BsFoldableApplicativeExtensions: BsFoldableApplicativeExtensions,
            traverse_: BsFoldableApplicativeExtensions.traverse$p,
            sequence_: BsFoldableApplicativeExtensions.sequence$p
          };
  };
  var FoldableMonadExtensions = function (M) {
    var BsFoldableMonadExtensions = Curry._1(BsFoldableExtensions.Monad, M);
    return {
            BsFoldableMonadExtensions: BsFoldableMonadExtensions,
            foldWithMonad: BsFoldableMonadExtensions.fold_monad
          };
  };
  var FoldableEqExtensions = function (E) {
    var contains = function (param, param$1) {
      return any(Curry._1(E.eq, param), param$1);
    };
    var indexOf = function (param, param$1) {
      return indexOfBy(E.eq, param, param$1);
    };
    return {
            contains: contains,
            indexOf: indexOf
          };
  };
  var FoldableOrdExtensions = function (O) {
    var min = function (param) {
      return minBy(O.compare, param);
    };
    var max = function (param) {
      return maxBy(O.compare, param);
    };
    return {
            min: min,
            max: max
          };
  };
  return {
          BsFoldableExtensions: BsFoldableExtensions,
          any: any,
          all: all,
          containsBy: containsBy,
          contains: contains,
          indexOfBy: indexOfBy,
          indexOf: indexOf,
          minBy: minBy,
          min: min,
          maxBy: maxBy,
          max: max,
          countBy: countBy,
          length: length,
          size: length,
          count: length,
          forEach: forEach,
          forEachWithIndex: forEachWithIndex,
          find: find,
          findWithIndex: findWithIndex,
          toList: toList,
          toArray: toArray,
          FoldableSemigroupExtensions: FoldableSemigroupExtensions,
          FoldableMonoidExtensions: FoldableMonoidExtensions,
          foldMap: foldMap,
          foldWithMonoid: foldWithMonoid,
          intercalate: intercalate,
          FoldableApplicativeExtensions: FoldableApplicativeExtensions,
          FoldableMonadExtensions: FoldableMonadExtensions,
          FoldableEqExtensions: FoldableEqExtensions,
          FoldableOrdExtensions: FoldableOrdExtensions
        };
}

exports.optionAlt = optionAlt;
exports.FoldableExtensions = FoldableExtensions;
/* Bastet__Functions Not a pure module */
