// Generated by Melange
'use strict';

var Curry = require("melange.runtime/curry.js");
var Caml_option = require("melange.runtime/caml_option.js");
var Relude__Relude_Extensions_Alt = require("./extensions/Relude_Extensions_Alt.js");
var Relude__Relude_Extensions_Apply = require("./extensions/Relude_Extensions_Apply.js");
var Relude__Relude_Extensions_Monad = require("./extensions/Relude_Extensions_Monad.js");
var Relude__Relude_Extensions_Functor = require("./extensions/Relude_Extensions_Functor.js");
var Relude__Relude_Extensions_Applicative = require("./extensions/Relude_Extensions_Applicative.js");

function reloading(a) {
  return {
          TAG: /* Reloading */0,
          _0: a
        };
}

function complete(a) {
  return {
          TAG: /* Complete */1,
          _0: a
        };
}

function isInit(param) {
  if (typeof param === "number" && !param) {
    return true;
  } else {
    return false;
  }
}

function isLoading(param) {
  if (typeof param === "number" && param) {
    return true;
  } else {
    return false;
  }
}

function isReloading(param) {
  if (typeof param === "number" || param.TAG !== /* Reloading */0) {
    return false;
  } else {
    return true;
  }
}

function isComplete(param) {
  if (typeof param === "number" || param.TAG !== /* Complete */1) {
    return false;
  } else {
    return true;
  }
}

function isBusy(param) {
  if (typeof param === "number") {
    if (param === /* Init */0) {
      return false;
    } else {
      return true;
    }
  } else if (param.TAG === /* Reloading */0) {
    return true;
  } else {
    return false;
  }
}

function isIdle(fa) {
  return !isBusy(fa);
}

function isEmpty(param) {
  if (typeof param === "number") {
    return true;
  } else {
    return false;
  }
}

function isNotEmpty(param) {
  if (typeof param === "number") {
    return false;
  } else {
    return true;
  }
}

function toBusy(a) {
  if (typeof a === "number") {
    if (a === /* Init */0) {
      return /* Loading */1;
    } else {
      return a;
    }
  } else if (a.TAG === /* Reloading */0) {
    return a;
  } else {
    return {
            TAG: /* Reloading */0,
            _0: a._0
          };
  }
}

function toIdle(a) {
  if (typeof a === "number") {
    if (a === /* Init */0) {
      return a;
    } else {
      return /* Init */0;
    }
  } else if (a.TAG === /* Reloading */0) {
    return {
            TAG: /* Complete */1,
            _0: a._0
          };
  } else {
    return a;
  }
}

function getValue(v) {
  if (typeof v === "number") {
    return ;
  } else {
    return Caml_option.some(v._0);
  }
}

function getReloading(a) {
  if (typeof a === "number" || a.TAG !== /* Reloading */0) {
    return ;
  } else {
    return Caml_option.some(a._0);
  }
}

function getComplete(a) {
  if (typeof a === "number" || a.TAG !== /* Complete */1) {
    return ;
  } else {
    return Caml_option.some(a._0);
  }
}

function fold(initValue, loadingValue, onReloading, onComplete, fa) {
  if (typeof fa === "number") {
    if (fa === /* Init */0) {
      return initValue;
    } else {
      return loadingValue;
    }
  } else if (fa.TAG === /* Reloading */0) {
    return Curry._1(onReloading, fa._0);
  } else {
    return Curry._1(onComplete, fa._0);
  }
}

function foldLazy(onInit, onLoading, onReloading, onComplete, fa) {
  if (typeof fa === "number") {
    if (fa === /* Init */0) {
      return Curry._1(onInit, undefined);
    } else {
      return Curry._1(onLoading, undefined);
    }
  } else if (fa.TAG === /* Reloading */0) {
    return Curry._1(onReloading, fa._0);
  } else {
    return Curry._1(onComplete, fa._0);
  }
}

function foldByValue(defaultValue, onValue, fa) {
  return fold(defaultValue, defaultValue, onValue, onValue, fa);
}

function foldByValueLazy(onNoValue, onValue, fa) {
  return foldLazy(onNoValue, onNoValue, onValue, onValue, fa);
}

function map(f, fa) {
  if (typeof fa === "number") {
    if (fa === /* Init */0) {
      return /* Init */0;
    } else {
      return /* Loading */1;
    }
  } else if (fa.TAG === /* Reloading */0) {
    return {
            TAG: /* Reloading */0,
            _0: Curry._1(f, fa._0)
          };
  } else {
    return {
            TAG: /* Complete */1,
            _0: Curry._1(f, fa._0)
          };
  }
}

var Functor = {
  map: map
};

var include = Relude__Relude_Extensions_Functor.FunctorExtensions(Functor);

function tap(ifInit, ifLoading, ifReloading, ifComplete, fa) {
  if (typeof fa === "number") {
    if (fa === /* Init */0) {
      Curry._1(ifInit, undefined);
      return fa;
    }
    Curry._1(ifLoading, undefined);
    return fa;
  } else {
    if (fa.TAG === /* Reloading */0) {
      Curry._1(ifReloading, fa._0);
      return fa;
    }
    Curry._1(ifComplete, fa._0);
    return fa;
  }
}

function tapInit(ifInit, fa) {
  if (typeof fa === "number" && !fa) {
    Curry._1(ifInit, undefined);
    return fa;
  } else {
    return fa;
  }
}

function tapLoading(ifLoading, fa) {
  if (typeof fa === "number" && fa) {
    Curry._1(ifLoading, undefined);
    return fa;
  } else {
    return fa;
  }
}

function tapReloading(ifReloading, fa) {
  if (typeof fa === "number") {
    return fa;
  }
  if (fa.TAG !== /* Reloading */0) {
    return fa;
  }
  Curry._1(ifReloading, fa._0);
  return fa;
}

function tapComplete(ifComplete, fa) {
  if (typeof fa === "number") {
    return fa;
  }
  if (fa.TAG !== /* Complete */1) {
    return fa;
  }
  Curry._1(ifComplete, fa._0);
  return fa;
}

function tapEmpty(ifEmpty, fa) {
  if (typeof fa === "number") {
    Curry._1(ifEmpty, undefined);
    return fa;
  } else {
    return fa;
  }
}

function tapNotEmpty(ifNotEmpty, fa) {
  if (typeof fa === "number") {
    return fa;
  } else {
    Curry._1(ifNotEmpty, fa._0);
    return fa;
  }
}

function tapByValue(ifEmpty, ifNotEmpty, fa) {
  if (typeof fa === "number") {
    Curry._1(ifEmpty, undefined);
    return fa;
  } else {
    Curry._1(ifNotEmpty, fa._0);
    return fa;
  }
}

function apply(ff, fa) {
  if (typeof ff === "number") {
    if (ff === /* Init */0 && !(typeof fa === "number" && fa)) {
      return /* Init */0;
    } else {
      return /* Loading */1;
    }
  }
  if (ff.TAG === /* Reloading */0) {
    if (typeof fa === "number") {
      if (fa) {
        return /* Loading */1;
      } else {
        return /* Init */0;
      }
    } else {
      return {
              TAG: /* Reloading */0,
              _0: Curry._1(ff._0, fa._0)
            };
    }
  }
  var f = ff._0;
  if (typeof fa === "number") {
    if (fa === /* Init */0) {
      return /* Init */0;
    } else {
      return /* Loading */1;
    }
  } else if (fa.TAG === /* Reloading */0) {
    return {
            TAG: /* Reloading */0,
            _0: Curry._1(f, fa._0)
          };
  } else {
    return {
            TAG: /* Complete */1,
            _0: Curry._1(f, fa._0)
          };
  }
}

var Apply = {
  map: map,
  apply: apply
};

var include$1 = Relude__Relude_Extensions_Apply.ApplyExtensions(Apply);

function pure(a) {
  return {
          TAG: /* Complete */1,
          _0: a
        };
}

var Applicative = {
  map: map,
  apply: apply,
  pure: pure
};

var include$2 = Relude__Relude_Extensions_Applicative.ApplicativeExtensions(Applicative);

function bind(fa, f) {
  if (typeof fa === "number") {
    if (fa) {
      return /* Loading */1;
    } else {
      return /* Init */0;
    }
  } else {
    return Curry._1(f, fa._0);
  }
}

var Monad = {
  map: map,
  apply: apply,
  pure: pure,
  flat_map: bind
};

var include$3 = Relude__Relude_Extensions_Monad.MonadExtensions(Monad);

function alt(fa, fb) {
  if (typeof fa === "number") {
    if (fa === /* Init */0) {
      if (typeof fb === "number") {
        if (fb) {
          return /* Loading */1;
        } else {
          return /* Init */0;
        }
      } else {
        return fb;
      }
    } else if (typeof fb === "number") {
      return /* Loading */1;
    } else {
      return fb;
    }
  } else if (fa.TAG === /* Reloading */0 && !(typeof fb === "number" || fb.TAG !== /* Complete */1)) {
    return fb;
  } else {
    return fa;
  }
}

var Alt = {
  map: map,
  alt: alt
};

var include$4 = Relude__Relude_Extensions_Alt.AltExtensions(Alt);

function eqBy(innerEq, a, b) {
  if (typeof a === "number") {
    if (a === /* Init */0) {
      if (typeof b === "number" && !b) {
        return true;
      } else {
        return false;
      }
    } else if (typeof b === "number" && b) {
      return true;
    } else {
      return false;
    }
  } else if (a.TAG === /* Reloading */0) {
    if (typeof b === "number" || b.TAG !== /* Reloading */0) {
      return false;
    } else {
      return Curry._2(innerEq, a._0, b._0);
    }
  } else if (typeof b === "number" || b.TAG !== /* Complete */1) {
    return false;
  } else {
    return Curry._2(innerEq, a._0, b._0);
  }
}

function Eq(E) {
  var eq = function (param, param$1) {
    return eqBy(E.eq, param, param$1);
  };
  return {
          eq: eq
        };
}

function showBy(showA, fa) {
  if (typeof fa === "number") {
    if (fa === /* Init */0) {
      return "Init";
    } else {
      return "Loading";
    }
  } else if (fa.TAG === /* Reloading */0) {
    return "Reloading(" + (Curry._1(showA, fa._0) + ")");
  } else {
    return "Complete(" + (Curry._1(showA, fa._0) + ")");
  }
}

function Show(S) {
  var show = function (param) {
    return showBy(S.show, param);
  };
  return {
          show: show
        };
}

var include$5 = Relude__Relude_Extensions_Functor.FunctorInfix(Functor);

var include$6 = Relude__Relude_Extensions_Alt.AltInfix(Alt);

var include$7 = Relude__Relude_Extensions_Apply.ApplyInfix(Apply);

var include$8 = Relude__Relude_Extensions_Monad.MonadInfix(Monad);

var Infix_FunctorExtensions = include$5.FunctorExtensions;

var Infix_$less$$great = include$5.$less$$great;

var Infix_$less$$$great = include$5.$less$$$great;

var Infix_$less$ = include$5.$less$;

var Infix_$$great = include$5.$$great;

var Infix_$less$at$great = include$5.$less$at$great;

var Infix_$less$pipe$great = include$6.$less$pipe$great;

var Infix_ApplyExtensions = include$7.ApplyExtensions;

var Infix_$less$star$great = include$7.$less$star$great;

var Infix_$less$star = include$7.$less$star;

var Infix_$star$great = include$7.$star$great;

var Infix_MonadExtensions = include$8.MonadExtensions;

var Infix_$great$great$eq = include$8.$great$great$eq;

var Infix_$eq$less$less = include$8.$eq$less$less;

var Infix_$great$eq$great = include$8.$great$eq$great;

var Infix_$less$eq$less = include$8.$less$eq$less;

var Infix = {
  FunctorExtensions: Infix_FunctorExtensions,
  $less$$great: Infix_$less$$great,
  $less$$$great: Infix_$less$$$great,
  $less$: Infix_$less$,
  $$great: Infix_$$great,
  $less$at$great: Infix_$less$at$great,
  $less$pipe$great: Infix_$less$pipe$great,
  ApplyExtensions: Infix_ApplyExtensions,
  $less$star$great: Infix_$less$star$great,
  $less$star: Infix_$less$star,
  $star$great: Infix_$star$great,
  MonadExtensions: Infix_MonadExtensions,
  $great$great$eq: Infix_$great$great$eq,
  $eq$less$less: Infix_$eq$less$less,
  $great$eq$great: Infix_$great$eq$great,
  $less$eq$less: Infix_$less$eq$less
};

var init = /* Init */0;

var loading = /* Loading */1;

var BsFunctorExtensions = include.BsFunctorExtensions;

var flipMap = include.flipMap;

var $$void = include.$$void;

var voidRight = include.voidRight;

var voidLeft = include.voidLeft;

var flap = include.flap;

var BsApplyExtensions = include$1.BsApplyExtensions;

var applyFirst = include$1.applyFirst;

var applySecond = include$1.applySecond;

var map2 = include$1.map2;

var map3 = include$1.map3;

var map4 = include$1.map4;

var map5 = include$1.map5;

var tuple2 = include$1.tuple2;

var tuple3 = include$1.tuple3;

var tuple4 = include$1.tuple4;

var tuple5 = include$1.tuple5;

var mapTuple2 = include$1.mapTuple2;

var mapTuple3 = include$1.mapTuple3;

var mapTuple4 = include$1.mapTuple4;

var mapTuple5 = include$1.mapTuple5;

var BsApplicativeExtensions = include$2.BsApplicativeExtensions;

var liftA1 = include$2.liftA1;

var all = include$2.all;

var BsMonadExtensions = include$3.BsMonadExtensions;

var flatMap = include$3.flatMap;

var flatten = include$3.flatten;

var composeKleisli = include$3.composeKleisli;

var flipComposeKleisli = include$3.flipComposeKleisli;

var liftM1 = include$3.liftM1;

var when_ = include$3.when_;

var unless = include$3.unless;

var orElse = include$4.orElse;

exports.init = init;
exports.loading = loading;
exports.reloading = reloading;
exports.complete = complete;
exports.isInit = isInit;
exports.isLoading = isLoading;
exports.isReloading = isReloading;
exports.isComplete = isComplete;
exports.isBusy = isBusy;
exports.isIdle = isIdle;
exports.isEmpty = isEmpty;
exports.isNotEmpty = isNotEmpty;
exports.toBusy = toBusy;
exports.toIdle = toIdle;
exports.getValue = getValue;
exports.getReloading = getReloading;
exports.getComplete = getComplete;
exports.fold = fold;
exports.foldLazy = foldLazy;
exports.foldByValue = foldByValue;
exports.foldByValueLazy = foldByValueLazy;
exports.map = map;
exports.Functor = Functor;
exports.BsFunctorExtensions = BsFunctorExtensions;
exports.flipMap = flipMap;
exports.$$void = $$void;
exports.voidRight = voidRight;
exports.voidLeft = voidLeft;
exports.flap = flap;
exports.tap = tap;
exports.tapInit = tapInit;
exports.tapLoading = tapLoading;
exports.tapReloading = tapReloading;
exports.tapComplete = tapComplete;
exports.tapEmpty = tapEmpty;
exports.tapNotEmpty = tapNotEmpty;
exports.tapByValue = tapByValue;
exports.apply = apply;
exports.Apply = Apply;
exports.BsApplyExtensions = BsApplyExtensions;
exports.applyFirst = applyFirst;
exports.applySecond = applySecond;
exports.map2 = map2;
exports.map3 = map3;
exports.map4 = map4;
exports.map5 = map5;
exports.tuple2 = tuple2;
exports.tuple3 = tuple3;
exports.tuple4 = tuple4;
exports.tuple5 = tuple5;
exports.mapTuple2 = mapTuple2;
exports.mapTuple3 = mapTuple3;
exports.mapTuple4 = mapTuple4;
exports.mapTuple5 = mapTuple5;
exports.pure = pure;
exports.Applicative = Applicative;
exports.BsApplicativeExtensions = BsApplicativeExtensions;
exports.liftA1 = liftA1;
exports.all = all;
exports.bind = bind;
exports.Monad = Monad;
exports.BsMonadExtensions = BsMonadExtensions;
exports.flatMap = flatMap;
exports.flatten = flatten;
exports.composeKleisli = composeKleisli;
exports.flipComposeKleisli = flipComposeKleisli;
exports.liftM1 = liftM1;
exports.when_ = when_;
exports.unless = unless;
exports.alt = alt;
exports.Alt = Alt;
exports.orElse = orElse;
exports.eqBy = eqBy;
exports.Eq = Eq;
exports.showBy = showBy;
exports.Show = Show;
exports.Infix = Infix;
/* include Not a pure module */
