// Generated by Melange
'use strict';

var Curry = require("melange.runtime/curry.js");
var Caml_int32 = require("melange.runtime/caml_int32.js");
var Bastet__Default = require("bastet/./Default.js");
var Relude__Relude_Int = require("./Relude_Int.js");
var Relude__Relude_List = require("./Relude_List.js");
var Relude__Relude_Option = require("./Relude_Option.js");
var Relude__Relude_Function = require("./Relude_Function.js");
var Relude__Relude_NonEmpty = require("./Relude_NonEmpty.js");
var Relude__Relude_List_Base = require("./list/Relude_List_Base.js");
var Relude__Relude_Array_Base = require("./array/Relude_Array_Base.js");
var Relude__Relude_Extensions_Apply = require("./extensions/Relude_Extensions_Apply.js");
var Relude__Relude_Extensions_Functor = require("./extensions/Relude_Extensions_Functor.js");
var Relude__Relude_Extensions_Foldable = require("./extensions/Relude_Extensions_Foldable.js");
var Relude__Relude_Extensions_Applicative = require("./extensions/Relude_Extensions_Applicative.js");

function WithSequence(S) {
  var make = function (left, focus, right) {
    return /* Zipper */{
            _0: left,
            _1: focus,
            _2: right
          };
  };
  var makeWithLeft = function (left, focus) {
    return /* Zipper */{
            _0: left,
            _1: focus,
            _2: Curry._1(S.emptyLazy, undefined)
          };
  };
  var makeWithRight = function (focus, right) {
    return /* Zipper */{
            _0: Curry._1(S.emptyLazy, undefined),
            _1: focus,
            _2: right
          };
  };
  var makeWithRightArray = function (focus, array) {
    return makeWithRight(focus, Curry._1(S.fromArray, array));
  };
  var makeWithRightList = function (focus, list) {
    return makeWithRight(focus, Curry._1(S.fromList, list));
  };
  var makeWithFocus = function (focus) {
    return /* Zipper */{
            _0: Curry._1(S.emptyLazy, undefined),
            _1: focus,
            _2: Curry._1(S.emptyLazy, undefined)
          };
  };
  var fromSequence = function (sequence) {
    var head = Curry._1(S.head, sequence);
    var tail = Curry._1(S.tail, sequence);
    return Curry._3(Relude__Relude_Option.map2, makeWithRight, head, tail);
  };
  var fromArray = function (array) {
    return Relude__Relude_Option.map((function (param) {
                  return Relude__Relude_Function.uncurry2(makeWithRightArray, param);
                }), Relude__Relude_Array_Base.uncons(array));
  };
  var fromList = function (array) {
    return Relude__Relude_Option.map((function (param) {
                  return Relude__Relude_Function.uncurry2(makeWithRightList, param);
                }), Relude__Relude_List_Base.uncons(array));
  };
  var fromNonEmptyArray = function (param) {
    return makeWithRight(param._0, Curry._1(S.fromArray, param._1));
  };
  var fromNonEmptyList = function (param) {
    return makeWithRight(param._0, Curry._1(S.fromList, param._1));
  };
  var map = function (f, param) {
    return /* Zipper */{
            _0: Curry._2(S.Functor.map, f, param._0),
            _1: Curry._1(f, param._1),
            _2: Curry._2(S.Functor.map, f, param._2)
          };
  };
  var Functor = {
    map: map
  };
  var include = Relude__Relude_Extensions_Functor.FunctorExtensions(Functor);
  var apply = function (param, param$1) {
    return /* Zipper */{
            _0: Curry._3(S.zipWith, (function (a) {
                    return a;
                  }), param._0, param$1._0),
            _1: Curry._1(param._1, param$1._1),
            _2: Curry._3(S.zipWith, (function (a) {
                    return a;
                  }), param._2, param$1._2)
          };
  };
  var Apply = {
    map: map,
    apply: apply
  };
  var include$1 = Relude__Relude_Extensions_Apply.ApplyExtensions(Apply);
  var Applicative = {
    map: map,
    apply: apply,
    pure: makeWithFocus
  };
  var include$2 = Relude__Relude_Extensions_Applicative.ApplicativeExtensions(Applicative);
  var foldLeft = function (f, acc, param) {
    var flipF = function (a, b) {
      return Curry._2(f, b, a);
    };
    var accL = Curry._3(S.Foldable.fold_right, flipF, acc, param._0);
    var accF = Curry._2(f, accL, param._1);
    return Curry._3(S.Foldable.fold_left, f, accF, param._2);
  };
  var foldRight = function (f, acc, param) {
    var flipF = function (b, a) {
      return Curry._2(f, a, b);
    };
    var accR = Curry._3(S.Foldable.fold_right, f, acc, param._2);
    var accF = Curry._2(f, param._1, accR);
    return Curry._3(S.Foldable.fold_left, flipF, accF, param._0);
  };
  var Foldable_Fold_Map = function (funarg) {
    var D = Bastet__Default.Fold_Map(funarg, {
          fold_left: foldLeft,
          fold_right: foldRight
        });
    return {
            fold_map: D.fold_map_default_left
          };
  };
  var Foldable_Fold_Map_Any = function (funarg) {
    var D = Bastet__Default.Fold_Map_Any(funarg, {
          fold_left: foldLeft,
          fold_right: foldRight
        });
    return {
            fold_map: D.fold_map_default_left
          };
  };
  var Foldable_Fold_Map_Plus = function (funarg) {
    var D = Bastet__Default.Fold_Map_Plus(funarg, {
          fold_left: foldLeft,
          fold_right: foldRight
        });
    return {
            fold_map: D.fold_map_default_left
          };
  };
  var Foldable = {
    fold_left: foldLeft,
    fold_right: foldRight,
    Fold_Map: Foldable_Fold_Map,
    Fold_Map_Any: Foldable_Fold_Map_Any,
    Fold_Map_Plus: Foldable_Fold_Map_Plus
  };
  var include$3 = Relude__Relude_Extensions_Foldable.FoldableExtensions(Foldable);
  var length = include$3.length;
  var Traversable = function (A) {
    var $less$$great = A.map;
    var $less$star$great = A.apply;
    var STraversable = Curry._1(S.Traversable, A);
    var traverse = function (f, param) {
      return Curry._2($less$star$great, Curry._2($less$star$great, Curry._2($less$$great, make, Curry._2(STraversable.traverse, f, param._0)), Curry._1(f, param._1)), Curry._2(STraversable.traverse, f, param._2));
    };
    var sequence = function (fa) {
      return traverse((function (a) {
                    return a;
                  }), fa);
    };
    return {
            map: map,
            fold_left: foldLeft,
            fold_right: foldRight,
            Fold_Map: Foldable_Fold_Map,
            Fold_Map_Any: Foldable_Fold_Map_Any,
            Fold_Map_Plus: Foldable_Fold_Map_Plus,
            traverse: traverse,
            sequence: sequence
          };
  };
  var toSequence = function (param) {
    return Curry._2(S.concat, Curry._2(S.append, param._1, Curry._1(S.reverse, param._0)), param._2);
  };
  var toArray = function (zipper) {
    return Curry._1(S.toArray, toSequence(zipper));
  };
  var toList = function (zipper) {
    return Curry._1(S.toList, toSequence(zipper));
  };
  var toNonEmptyArray = function (param) {
    var right = param._2;
    var focus = param._1;
    return Relude__Relude_Option.foldLazy((function (param) {
                  return Relude__Relude_NonEmpty.$$Array.make(focus, Curry._1(S.toArray, right));
                }), (function (param) {
                  return Relude__Relude_NonEmpty.$$Array.make(param[0], Curry._1(S.toArray, Curry._2(S.concat, Curry._2(S.append, focus, param[1]), right)));
                }), Curry._1(S.uncons, Curry._1(S.reverse, param._0)));
  };
  var toNonEmptyList = function (param) {
    var right = param._2;
    var focus = param._1;
    return Relude__Relude_Option.foldLazy((function (param) {
                  return Relude__Relude_NonEmpty.List.make(focus, Curry._1(S.toList, right));
                }), (function (param) {
                  return Relude__Relude_NonEmpty.List.make(param[0], Curry._1(S.toList, Curry._2(S.concat, Curry._2(S.append, focus, param[1]), right)));
                }), Curry._1(S.uncons, Curry._1(S.reverse, param._0)));
  };
  var concatWithKeepLeftFocus = function (prefix, suffix) {
    return /* Zipper */{
            _0: prefix._0,
            _1: prefix._1,
            _2: Curry._2(S.concat, prefix._2, toSequence(suffix))
          };
  };
  var concatWithKeepRightFocus = function (prefix, suffix) {
    return /* Zipper */{
            _0: Curry._2(S.concat, suffix._0, Curry._1(S.reverse, toSequence(prefix))),
            _1: suffix._1,
            _2: suffix._2
          };
  };
  var append = concatWithKeepLeftFocus;
  var Semigroup_Any = {
    append: append
  };
  var reverse = function (param) {
    return /* Zipper */{
            _0: param._2,
            _1: param._1,
            _2: param._0
          };
  };
  var zipWith = function (f, param, param$1) {
    return /* Zipper */{
            _0: Curry._3(S.zipWith, f, param._0, param$1._0),
            _1: Curry._2(f, param._1, param$1._1),
            _2: Curry._3(S.zipWith, f, param._2, param$1._2)
          };
  };
  var zip = function (z1, z2) {
    return zipWith((function (a, b) {
                  return [
                          a,
                          b
                        ];
                }), z1, z2);
  };
  var zipWithIndex = function (param) {
    var right = param._2;
    var left = param._0;
    var leftLength = Curry._1(S.length, left);
    var rightLength = Curry._1(S.length, right);
    var totalLength = (leftLength + 1 | 0) + rightLength | 0;
    var leftRange = Relude__Relude_List.reverse(Relude__Relude_Int.rangeAsList(0, leftLength));
    var rightRange = Relude__Relude_Int.rangeAsList(leftLength + 1 | 0, totalLength);
    return /* Zipper */{
            _0: Curry._2(S.zip, left, Curry._1(S.fromList, leftRange)),
            _1: [
              param._1,
              leftLength
            ],
            _2: Curry._2(S.zip, right, Curry._1(S.fromList, rightRange))
          };
  };
  var getFocus = function (param) {
    return param._1;
  };
  var setFocusBy = function (f, param) {
    return /* Zipper */{
            _0: param._0,
            _1: Curry._1(f, param._1),
            _2: param._2
          };
  };
  var setFocus = function (focus, param) {
    return /* Zipper */{
            _0: param._0,
            _1: focus,
            _2: param._2
          };
  };
  var getLeft = function (param) {
    return param._0;
  };
  var setLeft = function (left, param) {
    return /* Zipper */{
            _0: left,
            _1: param._1,
            _2: param._2
          };
  };
  var getLeftInOrder = function (param) {
    return Curry._1(S.reverse, param._0);
  };
  var setLeftFromInOrder = function (left, param) {
    return /* Zipper */{
            _0: Curry._1(S.reverse, left),
            _1: param._1,
            _2: param._2
          };
  };
  var getRight = function (param) {
    return param._2;
  };
  var setRight = function (right, param) {
    return /* Zipper */{
            _0: param._0,
            _1: param._1,
            _2: right
          };
  };
  var peekLeft = function (param) {
    return Curry._1(S.head, param._0);
  };
  var peekRight = function (param) {
    return Curry._1(S.head, param._2);
  };
  var isAtStart = function (param) {
    return Curry._1(S.isEmpty, param._0);
  };
  var isAtEnd = function (param) {
    return Curry._1(S.isEmpty, param._2);
  };
  var isAtIndex = function (target, z) {
    return getFocus(zipWithIndex(z))[1] === target;
  };
  var isAtItemBy = function (eq, target, z) {
    return Curry._2(eq, getFocus(z), target);
  };
  var isAtItem = function (eq, item, zipper) {
    return Curry._2(eq.eq, getFocus(zipper), item);
  };
  var moveLeft = function (param) {
    var right = param._2;
    var focus = param._1;
    return Relude__Relude_Option.map((function (param) {
                  return /* Zipper */{
                          _0: param[1],
                          _1: param[0],
                          _2: Curry._2(S.prepend, focus, right)
                        };
                }), Curry._1(S.uncons, param._0));
  };
  var moveRight = function (param) {
    var focus = param._1;
    var left = param._0;
    return Relude__Relude_Option.map((function (param) {
                  return /* Zipper */{
                          _0: Curry._2(S.prepend, focus, left),
                          _1: param[0],
                          _2: param[1]
                        };
                }), Curry._1(S.uncons, param._2));
  };
  var moveLeftWithClamp = function (z) {
    return Relude__Relude_Option.getOrElse(z, moveLeft(z));
  };
  var moveRightWithClamp = function (z) {
    return Relude__Relude_Option.getOrElse(z, moveRight(z));
  };
  var moveStart = function (z) {
    var right = z._2;
    var focus = z._1;
    return Relude__Relude_Option.foldLazy((function (param) {
                  return z;
                }), (function (param) {
                  return /* Zipper */{
                          _0: Curry._1(S.emptyLazy, undefined),
                          _1: param[0],
                          _2: Curry._2(S.concat, Curry._2(S.append, focus, param[1]), right)
                        };
                }), Curry._1(S.uncons, Curry._1(S.reverse, z._0)));
  };
  var moveEnd = function (z) {
    var focus = z._1;
    var left = z._0;
    return Relude__Relude_Option.foldLazy((function (param) {
                  return z;
                }), (function (param) {
                  return /* Zipper */{
                          _0: Curry._2(S.concat, param[1], Curry._2(S.prepend, focus, left)),
                          _1: param[0],
                          _2: Curry._1(S.emptyLazy, undefined)
                        };
                }), Curry._1(S.uncons, Curry._1(S.reverse, z._2)));
  };
  var moveLeftWithWrap = function (z) {
    return Relude__Relude_Option.getOrElseLazy((function (param) {
                  return moveEnd(z);
                }), moveLeft(z));
  };
  var moveRightWithWrap = function (z) {
    return Relude__Relude_Option.getOrElseLazy((function (param) {
                  return moveStart(z);
                }), moveRight(z));
  };
  var moveLeftTimes = function (times, z) {
    if (times < 0) {
      return ;
    }
    if (times === 0) {
      return z;
    }
    var partial_arg = times - 1 | 0;
    return Curry._2(Relude__Relude_Option.flatMap, (function (param) {
                  return moveLeftTimes(partial_arg, param);
                }), moveLeft(z));
  };
  var moveRightTimes = function (times, z) {
    if (times < 0) {
      return ;
    }
    if (times === 0) {
      return z;
    }
    var partial_arg = times - 1 | 0;
    return Curry._2(Relude__Relude_Option.flatMap, (function (param) {
                  return moveRightTimes(partial_arg, param);
                }), moveRight(z));
  };
  var moveLeftTimesWithClamp = function (times, z) {
    return Relude__Relude_Option.getOrElseLazy((function (param) {
                  return moveStart(z);
                }), moveLeftTimes(times, z));
  };
  var moveRightTimesWithClamp = function (times, z) {
    return Relude__Relude_Option.getOrElseLazy((function (param) {
                  return moveEnd(z);
                }), moveRightTimes(times, z));
  };
  var moveToIndex = function (target, z) {
    var match = zipWithIndex(z);
    var index = match._1[1];
    if (index === target) {
      return z;
    } else if (index < target) {
      return Curry._2(Relude__Relude_Option.flatMap, (function (param) {
                    return moveToIndex(target, param);
                  }), moveRight(z));
    } else {
      return Curry._2(Relude__Relude_Option.flatMap, (function (param) {
                    return moveToIndex(target, param);
                  }), moveLeft(z));
    }
  };
  var moveToIndexWithMod = function (target, z) {
    var modTarget = Caml_int32.mod_(target, Curry._1(length, z));
    return Relude__Relude_Option.getOrThrow(moveToIndex(modTarget, z));
  };
  var moveToIndexWithClamp = function (target, z) {
    var maxIndex = Curry._1(length, z) - 1 | 0;
    var newTarget = target < 0 ? 0 : (
        target > maxIndex ? maxIndex : target
      );
    return Relude__Relude_Option.getOrThrow(moveToIndex(newTarget, z));
  };
  var findLeftBy = function (checkFocusOpt, f) {
    var checkFocus = checkFocusOpt !== undefined ? checkFocusOpt : true;
    return function (z) {
      if (checkFocus && Curry._1(f, z._1)) {
        return z;
      } else {
        return Curry._2(Relude__Relude_Option.flatMap, findLeftBy(true, f), moveLeft(z));
      }
    };
  };
  var findRightBy = function (checkFocusOpt, f) {
    var checkFocus = checkFocusOpt !== undefined ? checkFocusOpt : true;
    return function (z) {
      if (checkFocus && Curry._1(f, z._1)) {
        return z;
      } else {
        return Curry._2(Relude__Relude_Option.flatMap, findRightBy(true, f), moveRight(z));
      }
    };
  };
  var findBy = function (checkFocusOpt, f) {
    var checkFocus = checkFocusOpt !== undefined ? checkFocusOpt : true;
    return function (z) {
      return Relude__Relude_Option.orElseLazy((function (param) {
                    return findRightBy(false, f)(z);
                  }), findLeftBy(checkFocus, f)(z));
    };
  };
  var findItemLeftBy = function (checkFocusOpt, eq) {
    var checkFocus = checkFocusOpt !== undefined ? checkFocusOpt : true;
    return function (item, zipper) {
      var p = Curry._1(eq, item);
      return findLeftBy(checkFocus, p)(zipper);
    };
  };
  var findItemRightBy = function (checkFocusOpt, eq) {
    var checkFocus = checkFocusOpt !== undefined ? checkFocusOpt : true;
    return function (item, zipper) {
      var p = Curry._1(eq, item);
      return findRightBy(checkFocus, p)(zipper);
    };
  };
  var findItemBy = function (checkFocusOpt, eq) {
    var checkFocus = checkFocusOpt !== undefined ? checkFocusOpt : true;
    return function (item, zipper) {
      var arg = findItemLeftBy(checkFocus, eq)(item, zipper);
      var param = function (param$1) {
        return findItemRightBy(false, eq)(item, zipper);
      };
      return Relude__Relude_Option.orElseLazy(param, arg);
    };
  };
  var findItemLeft = function (eq, checkFocusOpt, item) {
    var checkFocus = checkFocusOpt !== undefined ? checkFocusOpt : true;
    return function (zipper) {
      return findItemLeftBy(checkFocus, eq.eq)(item, zipper);
    };
  };
  var findItemRight = function (eq, checkFocusOpt, item) {
    var checkFocus = checkFocusOpt !== undefined ? checkFocusOpt : true;
    return function (zipper) {
      return findItemRightBy(checkFocus, eq.eq)(item, zipper);
    };
  };
  var findItem = function (eq, checkFocusOpt, item) {
    var checkFocus = checkFocusOpt !== undefined ? checkFocusOpt : true;
    return function (zipper) {
      return Relude__Relude_Option.orElseLazy((function (param) {
                    return findItemRight(eq, false, item)(zipper);
                  }), findItemLeft(eq, checkFocus, item)(zipper));
    };
  };
  var insertWithPushLeft = function (item, param) {
    return /* Zipper */{
            _0: Curry._2(S.prepend, param._1, param._0),
            _1: item,
            _2: param._2
          };
  };
  var insertWithPushRight = function (item, param) {
    return /* Zipper */{
            _0: param._0,
            _1: item,
            _2: Curry._2(S.prepend, param._1, param._2)
          };
  };
  var deleteWithPullLeft = function (param) {
    var right = param._2;
    return Relude__Relude_Option.map((function (param) {
                  return /* Zipper */{
                          _0: param[1],
                          _1: param[0],
                          _2: right
                        };
                }), Curry._1(S.uncons, param._0));
  };
  var deleteWithPullRight = function (param) {
    var left = param._0;
    return Relude__Relude_Option.map((function (param) {
                  return /* Zipper */{
                          _0: left,
                          _1: param[0],
                          _2: param[1]
                        };
                }), Curry._1(S.uncons, param._2));
  };
  var deleteWithPullLeftOrRight = function (z) {
    return Relude__Relude_Option.orElseLazy((function (param) {
                  return deleteWithPullRight(z);
                }), deleteWithPullLeft(z));
  };
  var showBy = function (showA, param) {
    return "Zipper(" + (Curry._2(S.showBy, showA, param._0) + (", " + (Curry._1(showA, param._1) + (", " + (Curry._2(S.showBy, showA, param._2) + ")")))));
  };
  var show = function (showA, xs) {
    return showBy(showA.show, xs);
  };
  var Show = function (ShowA) {
    var show = function (xs) {
      return showBy(ShowA.show, xs);
    };
    return {
            show: show
          };
  };
  var eqBy = function (eqA, param, param$1) {
    if (Curry._3(S.eqBy, eqA, param._0, param$1._0) && Curry._2(eqA, param._1, param$1._1)) {
      return Curry._3(S.eqBy, eqA, param._2, param$1._2);
    } else {
      return false;
    }
  };
  var eq = function (eqA, xs, ys) {
    return eqBy(eqA.eq, xs, ys);
  };
  var Eq = function (EqA) {
    var eq = function (xs, ys) {
      return eqBy(EqA.eq, xs, ys);
    };
    return {
            eq: eq
          };
  };
  var include$4 = Relude__Relude_Extensions_Functor.FunctorInfix(Functor);
  var include$5 = Relude__Relude_Extensions_Apply.ApplyInfix(Apply);
  var Infix_FunctorExtensions = include$4.FunctorExtensions;
  var Infix_$less$$great = include$4.$less$$great;
  var Infix_$less$$$great = include$4.$less$$$great;
  var Infix_$less$ = include$4.$less$;
  var Infix_$$great = include$4.$$great;
  var Infix_$less$at$great = include$4.$less$at$great;
  var Infix_ApplyExtensions = include$5.ApplyExtensions;
  var Infix_$less$star$great = include$5.$less$star$great;
  var Infix_$less$star = include$5.$less$star;
  var Infix_$star$great = include$5.$star$great;
  var Infix = {
    FunctorExtensions: Infix_FunctorExtensions,
    $less$$great: Infix_$less$$great,
    $less$$$great: Infix_$less$$$great,
    $less$: Infix_$less$,
    $$great: Infix_$$great,
    $less$at$great: Infix_$less$at$great,
    ApplyExtensions: Infix_ApplyExtensions,
    $less$star$great: Infix_$less$star$great,
    $less$star: Infix_$less$star,
    $star$great: Infix_$star$great
  };
  return {
          make: make,
          makeWithLeft: makeWithLeft,
          makeWithRight: makeWithRight,
          makeWithRightArray: makeWithRightArray,
          makeWithRightList: makeWithRightList,
          makeWithFocus: makeWithFocus,
          fromSequence: fromSequence,
          fromArray: fromArray,
          fromList: fromList,
          fromNonEmptyArray: fromNonEmptyArray,
          fromNea: fromNonEmptyArray,
          fromNonEmptyList: fromNonEmptyList,
          fromNel: fromNonEmptyList,
          map: map,
          Functor: Functor,
          BsFunctorExtensions: include.BsFunctorExtensions,
          flipMap: include.flipMap,
          $$void: include.$$void,
          voidRight: include.voidRight,
          voidLeft: include.voidLeft,
          flap: include.flap,
          apply: apply,
          Apply: Apply,
          BsApplyExtensions: include$1.BsApplyExtensions,
          applyFirst: include$1.applyFirst,
          applySecond: include$1.applySecond,
          map2: include$1.map2,
          map3: include$1.map3,
          map4: include$1.map4,
          map5: include$1.map5,
          tuple2: include$1.tuple2,
          tuple3: include$1.tuple3,
          tuple4: include$1.tuple4,
          tuple5: include$1.tuple5,
          mapTuple2: include$1.mapTuple2,
          mapTuple3: include$1.mapTuple3,
          mapTuple4: include$1.mapTuple4,
          mapTuple5: include$1.mapTuple5,
          pure: makeWithFocus,
          Applicative: Applicative,
          BsApplicativeExtensions: include$2.BsApplicativeExtensions,
          liftA1: include$2.liftA1,
          when_: include$2.when_,
          unless: include$2.unless,
          foldLeft: foldLeft,
          foldRight: foldRight,
          Foldable: Foldable,
          BsFoldableExtensions: include$3.BsFoldableExtensions,
          any: include$3.any,
          all: include$3.all,
          containsBy: include$3.containsBy,
          contains: include$3.contains,
          indexOfBy: include$3.indexOfBy,
          indexOf: include$3.indexOf,
          minBy: include$3.minBy,
          min: include$3.min,
          maxBy: include$3.maxBy,
          max: include$3.max,
          countBy: include$3.countBy,
          length: length,
          size: include$3.size,
          count: include$3.count,
          forEach: include$3.forEach,
          forEachWithIndex: include$3.forEachWithIndex,
          find: include$3.find,
          findWithIndex: include$3.findWithIndex,
          FoldableSemigroupExtensions: include$3.FoldableSemigroupExtensions,
          FoldableMonoidExtensions: include$3.FoldableMonoidExtensions,
          foldMap: include$3.foldMap,
          foldWithMonoid: include$3.foldWithMonoid,
          intercalate: include$3.intercalate,
          FoldableApplicativeExtensions: include$3.FoldableApplicativeExtensions,
          FoldableMonadExtensions: include$3.FoldableMonadExtensions,
          FoldableEqExtensions: include$3.FoldableEqExtensions,
          FoldableOrdExtensions: include$3.FoldableOrdExtensions,
          Traversable: Traversable,
          toSequence: toSequence,
          toArray: toArray,
          toList: toList,
          toNonEmptyArray: toNonEmptyArray,
          toNea: toNonEmptyArray,
          toNonEmptyList: toNonEmptyList,
          toNel: toNonEmptyList,
          concatWithKeepLeftFocus: concatWithKeepLeftFocus,
          concat: concatWithKeepLeftFocus,
          concatWithKeepRightFocus: concatWithKeepRightFocus,
          Semigroup_Any: Semigroup_Any,
          reverse: reverse,
          zipWith: zipWith,
          zip: zip,
          zipWithIndex: zipWithIndex,
          getFocus: getFocus,
          setFocusBy: setFocusBy,
          setFocus: setFocus,
          getLeft: getLeft,
          setLeft: setLeft,
          getLeftInOrder: getLeftInOrder,
          setLeftFromInOrder: setLeftFromInOrder,
          getRight: getRight,
          setRight: setRight,
          peekLeft: peekLeft,
          peekRight: peekRight,
          isAtStart: isAtStart,
          isAtEnd: isAtEnd,
          isAtIndex: isAtIndex,
          isAtItemBy: isAtItemBy,
          isAtItem: isAtItem,
          moveLeft: moveLeft,
          moveRight: moveRight,
          moveLeftWithClamp: moveLeftWithClamp,
          moveRightWithClamp: moveRightWithClamp,
          moveStart: moveStart,
          moveEnd: moveEnd,
          moveLeftWithWrap: moveLeftWithWrap,
          moveRightWithWrap: moveRightWithWrap,
          moveLeftTimes: moveLeftTimes,
          moveRightTimes: moveRightTimes,
          moveLeftTimesWithClamp: moveLeftTimesWithClamp,
          moveRightTimesWithClamp: moveRightTimesWithClamp,
          moveToIndex: moveToIndex,
          moveToIndexWithMod: moveToIndexWithMod,
          moveToIndexWithClamp: moveToIndexWithClamp,
          findLeftBy: findLeftBy,
          findRightBy: findRightBy,
          findBy: findBy,
          findItemLeftBy: findItemLeftBy,
          findItemRightBy: findItemRightBy,
          findItemBy: findItemBy,
          findItemLeft: findItemLeft,
          findItemRight: findItemRight,
          findItem: findItem,
          insertWithPushLeft: insertWithPushLeft,
          insertWithPushRight: insertWithPushRight,
          deleteWithPullLeft: deleteWithPullLeft,
          deleteWithPullRight: deleteWithPullRight,
          deleteWithPullLeftOrRight: deleteWithPullLeftOrRight,
          showBy: showBy,
          show: show,
          Show: Show,
          eqBy: eqBy,
          eq: eq,
          Eq: Eq,
          Infix: Infix
        };
}

exports.WithSequence = WithSequence;
/* Bastet__Default Not a pure module */
