// Generated by Melange
'use strict';

var Curry = require("melange.runtime/curry.js");
var Relude__Relude_Result = require("./Relude_Result.js");
var Relude__Relude_Extensions_Apply = require("./extensions/Relude_Extensions_Apply.js");
var Relude__Relude_Extensions_Monad = require("./extensions/Relude_Extensions_Monad.js");
var Relude__Relude_Extensions_Functor = require("./extensions/Relude_Extensions_Functor.js");
var Relude__Relude_Extensions_Bifunctor = require("./extensions/Relude_Extensions_Bifunctor.js");
var Relude__Relude_Extensions_Applicative = require("./extensions/Relude_Extensions_Applicative.js");

function WithMonad(M) {
  var make = function (mResult) {
    return /* ResultT */{
            _0: mResult
          };
  };
  var runResultT = function (mResult) {
    return mResult._0;
  };
  var withResultT = function (e1ToE2, mResultE1) {
    return /* ResultT */{
            _0: Curry._2(M.map, (function (resultE1) {
                    return Curry._2(Relude__Relude_Result.mapError, e1ToE2, resultE1);
                  }), mResultE1._0)
          };
  };
  var mapResultT = function (mResultAToMResultB, mResultA) {
    return /* ResultT */{
            _0: Curry._1(mResultAToMResultB, mResultA._0)
          };
  };
  var fromResult = function (result) {
    return /* ResultT */{
            _0: Curry._1(M.pure, result)
          };
  };
  var liftF = function (mA) {
    return /* ResultT */{
            _0: Curry._2(M.map, (function (a) {
                    return {
                            TAG: /* Ok */0,
                            _0: a
                          };
                  }), mA)
          };
  };
  var map = function (aToB, mResultA) {
    return /* ResultT */{
            _0: Curry._2(M.map, (function (resultA) {
                    return Relude__Relude_Result.map(aToB, resultA);
                  }), mResultA._0)
          };
  };
  var subflatMap = function (aToB, mResultA) {
    return /* ResultT */{
            _0: Curry._2(M.map, (function (resultA) {
                    return Relude__Relude_Result.flatMap(aToB, resultA);
                  }), mResultA._0)
          };
  };
  var cond = function (aToBool, success, err, mResultA) {
    return /* ResultT */{
            _0: Curry._2(M.map, (function (resultA) {
                    return Relude__Relude_Result.flatMap((function (a) {
                                  if (Curry._1(aToBool, a)) {
                                    return Relude__Relude_Result.pure(success);
                                  } else {
                                    return Relude__Relude_Result.error(err);
                                  }
                                }), resultA);
                  }), mResultA._0)
          };
  };
  var condError = function (aToBool, err, mResultA) {
    return /* ResultT */{
            _0: Curry._2(M.map, (function (resultA) {
                    return Relude__Relude_Result.flatMap((function (a) {
                                  if (Curry._1(aToBool, a)) {
                                    return Relude__Relude_Result.pure(a);
                                  } else {
                                    return Relude__Relude_Result.error(err);
                                  }
                                }), resultA);
                  }), mResultA._0)
          };
  };
  var bimap = function (aToB, e1ToE2, mResultAE1) {
    return /* ResultT */{
            _0: Curry._2(M.map, (function (resultAE1) {
                    return Relude__Relude_Result.bimap(aToB, e1ToE2, resultAE1);
                  }), mResultAE1._0)
          };
  };
  var apply = function (mResultAToB, mResultA) {
    return /* ResultT */{
            _0: Curry._2(M.apply, Curry._2(M.map, Relude__Relude_Result.apply, mResultAToB._0), mResultA._0)
          };
  };
  var pure = function (a) {
    return /* ResultT */{
            _0: Curry._1(M.pure, Relude__Relude_Result.ok(a))
          };
  };
  var bind = function (mResultA, aToResultTB) {
    return /* ResultT */{
            _0: Curry._2(M.flat_map, mResultA._0, (function (resultA) {
                    if (resultA.TAG === /* Ok */0) {
                      return Curry._1(aToResultTB, resultA._0)._0;
                    } else {
                      return Curry._1(M.pure, resultA);
                    }
                  }))
          };
  };
  var semiflatMap = function (aToMB, resultTA) {
    return bind(resultTA, (function (a) {
                  return liftF(Curry._1(aToMB, a));
                }));
  };
  var WithError = function (E) {
    var Functor = {
      map: map
    };
    var include = Relude__Relude_Extensions_Functor.FunctorExtensions(Functor);
    var Bifunctor = {
      bimap: bimap
    };
    var include$1 = Relude__Relude_Extensions_Bifunctor.BifunctorExtensions(Bifunctor);
    var Apply = {
      map: map,
      apply: apply
    };
    var include$2 = Relude__Relude_Extensions_Apply.ApplyExtensions(Apply);
    var Applicative = {
      map: map,
      apply: apply,
      pure: pure
    };
    var include$3 = Relude__Relude_Extensions_Applicative.ApplicativeExtensions(Applicative);
    var Monad = {
      map: map,
      apply: apply,
      pure: pure,
      flat_map: bind
    };
    var include$4 = Relude__Relude_Extensions_Monad.MonadExtensions(Monad);
    var include$5 = Relude__Relude_Extensions_Functor.FunctorInfix(Functor);
    var include$6 = Relude__Relude_Extensions_Bifunctor.BifunctorInfix(Bifunctor);
    var include$7 = Relude__Relude_Extensions_Apply.ApplyInfix(Apply);
    var include$8 = Relude__Relude_Extensions_Monad.MonadInfix(Monad);
    var Infix_FunctorExtensions = include$5.FunctorExtensions;
    var Infix_$less$$great = include$5.$less$$great;
    var Infix_$less$$$great = include$5.$less$$$great;
    var Infix_$less$ = include$5.$less$;
    var Infix_$$great = include$5.$$great;
    var Infix_$less$at$great = include$5.$less$at$great;
    var Infix_$less$less$$great$great = include$6.$less$less$$great$great;
    var Infix_ApplyExtensions = include$7.ApplyExtensions;
    var Infix_$less$star$great = include$7.$less$star$great;
    var Infix_$less$star = include$7.$less$star;
    var Infix_$star$great = include$7.$star$great;
    var Infix_MonadExtensions = include$8.MonadExtensions;
    var Infix_$great$great$eq = include$8.$great$great$eq;
    var Infix_$eq$less$less = include$8.$eq$less$less;
    var Infix_$great$eq$great = include$8.$great$eq$great;
    var Infix_$less$eq$less = include$8.$less$eq$less;
    var Infix = {
      FunctorExtensions: Infix_FunctorExtensions,
      $less$$great: Infix_$less$$great,
      $less$$$great: Infix_$less$$$great,
      $less$: Infix_$less$,
      $$great: Infix_$$great,
      $less$at$great: Infix_$less$at$great,
      $less$less$$great$great: Infix_$less$less$$great$great,
      ApplyExtensions: Infix_ApplyExtensions,
      $less$star$great: Infix_$less$star$great,
      $less$star: Infix_$less$star,
      $star$great: Infix_$star$great,
      MonadExtensions: Infix_MonadExtensions,
      $great$great$eq: Infix_$great$great$eq,
      $eq$less$less: Infix_$eq$less$less,
      $great$eq$great: Infix_$great$eq$great,
      $less$eq$less: Infix_$less$eq$less
    };
    return {
            make: make,
            runResultT: runResultT,
            withResultT: withResultT,
            mapResultT: mapResultT,
            fromResult: fromResult,
            liftF: liftF,
            subflatMap: subflatMap,
            semiflatMap: semiflatMap,
            cond: cond,
            condError: condError,
            Functor: Functor,
            map: map,
            BsFunctorExtensions: include.BsFunctorExtensions,
            flipMap: include.flipMap,
            $$void: include.$$void,
            voidRight: include.voidRight,
            voidLeft: include.voidLeft,
            flap: include.flap,
            Bifunctor: Bifunctor,
            bimap: bimap,
            mapLeft: include$1.mapLeft,
            mapRight: include$1.mapRight,
            mapError: include$1.mapError,
            Apply: Apply,
            apply: apply,
            BsApplyExtensions: include$2.BsApplyExtensions,
            applyFirst: include$2.applyFirst,
            applySecond: include$2.applySecond,
            map2: include$2.map2,
            map3: include$2.map3,
            map4: include$2.map4,
            map5: include$2.map5,
            tuple2: include$2.tuple2,
            tuple3: include$2.tuple3,
            tuple4: include$2.tuple4,
            tuple5: include$2.tuple5,
            mapTuple2: include$2.mapTuple2,
            mapTuple3: include$2.mapTuple3,
            mapTuple4: include$2.mapTuple4,
            mapTuple5: include$2.mapTuple5,
            Applicative: Applicative,
            pure: pure,
            BsApplicativeExtensions: include$3.BsApplicativeExtensions,
            liftA1: include$3.liftA1,
            all: include$3.all,
            Monad: Monad,
            bind: bind,
            BsMonadExtensions: include$4.BsMonadExtensions,
            flatMap: include$4.flatMap,
            flatten: include$4.flatten,
            composeKleisli: include$4.composeKleisli,
            flipComposeKleisli: include$4.flipComposeKleisli,
            liftM1: include$4.liftM1,
            when_: include$4.when_,
            unless: include$4.unless,
            Infix: Infix
          };
  };
  return {
          make: make,
          runResultT: runResultT,
          withResultT: withResultT,
          mapResultT: mapResultT,
          fromResult: fromResult,
          liftF: liftF,
          map: map,
          subflatMap: subflatMap,
          cond: cond,
          condError: condError,
          mapError: withResultT,
          bimap: bimap,
          apply: apply,
          pure: pure,
          bind: bind,
          semiflatMap: semiflatMap,
          WithError: WithError
        };
}

function WithMonadAndError(M, E) {
  var make = function (mResult) {
    return /* ResultT */{
            _0: mResult
          };
  };
  var runResultT = function (mResult) {
    return mResult._0;
  };
  var withResultT = function (e1ToE2, mResultE1) {
    return /* ResultT */{
            _0: Curry._2(M.map, (function (resultE1) {
                    return Curry._2(Relude__Relude_Result.mapError, e1ToE2, resultE1);
                  }), mResultE1._0)
          };
  };
  var mapResultT = function (mResultAToMResultB, mResultA) {
    return /* ResultT */{
            _0: Curry._1(mResultAToMResultB, mResultA._0)
          };
  };
  var fromResult = function (result) {
    return /* ResultT */{
            _0: Curry._1(M.pure, result)
          };
  };
  var liftF = function (mA) {
    return /* ResultT */{
            _0: Curry._2(M.map, (function (a) {
                    return {
                            TAG: /* Ok */0,
                            _0: a
                          };
                  }), mA)
          };
  };
  var map = function (aToB, mResultA) {
    return /* ResultT */{
            _0: Curry._2(M.map, (function (resultA) {
                    return Relude__Relude_Result.map(aToB, resultA);
                  }), mResultA._0)
          };
  };
  var subflatMap = function (aToB, mResultA) {
    return /* ResultT */{
            _0: Curry._2(M.map, (function (resultA) {
                    return Relude__Relude_Result.flatMap(aToB, resultA);
                  }), mResultA._0)
          };
  };
  var cond = function (aToBool, success, err, mResultA) {
    return /* ResultT */{
            _0: Curry._2(M.map, (function (resultA) {
                    return Relude__Relude_Result.flatMap((function (a) {
                                  if (Curry._1(aToBool, a)) {
                                    return Relude__Relude_Result.pure(success);
                                  } else {
                                    return Relude__Relude_Result.error(err);
                                  }
                                }), resultA);
                  }), mResultA._0)
          };
  };
  var condError = function (aToBool, err, mResultA) {
    return /* ResultT */{
            _0: Curry._2(M.map, (function (resultA) {
                    return Relude__Relude_Result.flatMap((function (a) {
                                  if (Curry._1(aToBool, a)) {
                                    return Relude__Relude_Result.pure(a);
                                  } else {
                                    return Relude__Relude_Result.error(err);
                                  }
                                }), resultA);
                  }), mResultA._0)
          };
  };
  var bimap = function (aToB, e1ToE2, mResultAE1) {
    return /* ResultT */{
            _0: Curry._2(M.map, (function (resultAE1) {
                    return Relude__Relude_Result.bimap(aToB, e1ToE2, resultAE1);
                  }), mResultAE1._0)
          };
  };
  var apply = function (mResultAToB, mResultA) {
    return /* ResultT */{
            _0: Curry._2(M.apply, Curry._2(M.map, Relude__Relude_Result.apply, mResultAToB._0), mResultA._0)
          };
  };
  var pure = function (a) {
    return /* ResultT */{
            _0: Curry._1(M.pure, Relude__Relude_Result.ok(a))
          };
  };
  var bind = function (mResultA, aToResultTB) {
    return /* ResultT */{
            _0: Curry._2(M.flat_map, mResultA._0, (function (resultA) {
                    if (resultA.TAG === /* Ok */0) {
                      return Curry._1(aToResultTB, resultA._0)._0;
                    } else {
                      return Curry._1(M.pure, resultA);
                    }
                  }))
          };
  };
  var semiflatMap = function (aToMB, resultTA) {
    return bind(resultTA, (function (a) {
                  return liftF(Curry._1(aToMB, a));
                }));
  };
  var WithError = function (E) {
    var Functor = {
      map: map
    };
    var include = Relude__Relude_Extensions_Functor.FunctorExtensions(Functor);
    var Bifunctor = {
      bimap: bimap
    };
    var include$1 = Relude__Relude_Extensions_Bifunctor.BifunctorExtensions(Bifunctor);
    var Apply = {
      map: map,
      apply: apply
    };
    var include$2 = Relude__Relude_Extensions_Apply.ApplyExtensions(Apply);
    var Applicative = {
      map: map,
      apply: apply,
      pure: pure
    };
    var include$3 = Relude__Relude_Extensions_Applicative.ApplicativeExtensions(Applicative);
    var Monad = {
      map: map,
      apply: apply,
      pure: pure,
      flat_map: bind
    };
    var include$4 = Relude__Relude_Extensions_Monad.MonadExtensions(Monad);
    var include$5 = Relude__Relude_Extensions_Functor.FunctorInfix(Functor);
    var include$6 = Relude__Relude_Extensions_Bifunctor.BifunctorInfix(Bifunctor);
    var include$7 = Relude__Relude_Extensions_Apply.ApplyInfix(Apply);
    var include$8 = Relude__Relude_Extensions_Monad.MonadInfix(Monad);
    var Infix_FunctorExtensions = include$5.FunctorExtensions;
    var Infix_$less$$great = include$5.$less$$great;
    var Infix_$less$$$great = include$5.$less$$$great;
    var Infix_$less$ = include$5.$less$;
    var Infix_$$great = include$5.$$great;
    var Infix_$less$at$great = include$5.$less$at$great;
    var Infix_$less$less$$great$great = include$6.$less$less$$great$great;
    var Infix_ApplyExtensions = include$7.ApplyExtensions;
    var Infix_$less$star$great = include$7.$less$star$great;
    var Infix_$less$star = include$7.$less$star;
    var Infix_$star$great = include$7.$star$great;
    var Infix_MonadExtensions = include$8.MonadExtensions;
    var Infix_$great$great$eq = include$8.$great$great$eq;
    var Infix_$eq$less$less = include$8.$eq$less$less;
    var Infix_$great$eq$great = include$8.$great$eq$great;
    var Infix_$less$eq$less = include$8.$less$eq$less;
    var Infix = {
      FunctorExtensions: Infix_FunctorExtensions,
      $less$$great: Infix_$less$$great,
      $less$$$great: Infix_$less$$$great,
      $less$: Infix_$less$,
      $$great: Infix_$$great,
      $less$at$great: Infix_$less$at$great,
      $less$less$$great$great: Infix_$less$less$$great$great,
      ApplyExtensions: Infix_ApplyExtensions,
      $less$star$great: Infix_$less$star$great,
      $less$star: Infix_$less$star,
      $star$great: Infix_$star$great,
      MonadExtensions: Infix_MonadExtensions,
      $great$great$eq: Infix_$great$great$eq,
      $eq$less$less: Infix_$eq$less$less,
      $great$eq$great: Infix_$great$eq$great,
      $less$eq$less: Infix_$less$eq$less
    };
    return {
            make: make,
            runResultT: runResultT,
            withResultT: withResultT,
            mapResultT: mapResultT,
            fromResult: fromResult,
            liftF: liftF,
            subflatMap: subflatMap,
            semiflatMap: semiflatMap,
            cond: cond,
            condError: condError,
            Functor: Functor,
            map: map,
            BsFunctorExtensions: include.BsFunctorExtensions,
            flipMap: include.flipMap,
            $$void: include.$$void,
            voidRight: include.voidRight,
            voidLeft: include.voidLeft,
            flap: include.flap,
            Bifunctor: Bifunctor,
            bimap: bimap,
            mapLeft: include$1.mapLeft,
            mapRight: include$1.mapRight,
            mapError: include$1.mapError,
            Apply: Apply,
            apply: apply,
            BsApplyExtensions: include$2.BsApplyExtensions,
            applyFirst: include$2.applyFirst,
            applySecond: include$2.applySecond,
            map2: include$2.map2,
            map3: include$2.map3,
            map4: include$2.map4,
            map5: include$2.map5,
            tuple2: include$2.tuple2,
            tuple3: include$2.tuple3,
            tuple4: include$2.tuple4,
            tuple5: include$2.tuple5,
            mapTuple2: include$2.mapTuple2,
            mapTuple3: include$2.mapTuple3,
            mapTuple4: include$2.mapTuple4,
            mapTuple5: include$2.mapTuple5,
            Applicative: Applicative,
            pure: pure,
            BsApplicativeExtensions: include$3.BsApplicativeExtensions,
            liftA1: include$3.liftA1,
            all: include$3.all,
            Monad: Monad,
            bind: bind,
            BsMonadExtensions: include$4.BsMonadExtensions,
            flatMap: include$4.flatMap,
            flatten: include$4.flatten,
            composeKleisli: include$4.composeKleisli,
            flipComposeKleisli: include$4.flipComposeKleisli,
            liftM1: include$4.liftM1,
            when_: include$4.when_,
            unless: include$4.unless,
            Infix: Infix
          };
  };
  var WithMonad = {
    make: make,
    runResultT: runResultT,
    withResultT: withResultT,
    mapResultT: mapResultT,
    fromResult: fromResult,
    liftF: liftF,
    map: map,
    subflatMap: subflatMap,
    cond: cond,
    condError: condError,
    mapError: withResultT,
    bimap: bimap,
    apply: apply,
    pure: pure,
    bind: bind,
    semiflatMap: semiflatMap,
    WithError: WithError
  };
  var Functor = {
    map: map
  };
  var include = Relude__Relude_Extensions_Functor.FunctorExtensions(Functor);
  var Bifunctor = {
    bimap: bimap
  };
  var include$1 = Relude__Relude_Extensions_Bifunctor.BifunctorExtensions(Bifunctor);
  var Apply = {
    map: map,
    apply: apply
  };
  var include$2 = Relude__Relude_Extensions_Apply.ApplyExtensions(Apply);
  var Applicative = {
    map: map,
    apply: apply,
    pure: pure
  };
  var include$3 = Relude__Relude_Extensions_Applicative.ApplicativeExtensions(Applicative);
  var Monad = {
    map: map,
    apply: apply,
    pure: pure,
    flat_map: bind
  };
  var include$4 = Relude__Relude_Extensions_Monad.MonadExtensions(Monad);
  var include$5 = Relude__Relude_Extensions_Functor.FunctorInfix(Functor);
  var include$6 = Relude__Relude_Extensions_Bifunctor.BifunctorInfix(Bifunctor);
  var include$7 = Relude__Relude_Extensions_Apply.ApplyInfix(Apply);
  var include$8 = Relude__Relude_Extensions_Monad.MonadInfix(Monad);
  var Infix_FunctorExtensions = include$5.FunctorExtensions;
  var Infix_$less$$great = include$5.$less$$great;
  var Infix_$less$$$great = include$5.$less$$$great;
  var Infix_$less$ = include$5.$less$;
  var Infix_$$great = include$5.$$great;
  var Infix_$less$at$great = include$5.$less$at$great;
  var Infix_$less$less$$great$great = include$6.$less$less$$great$great;
  var Infix_ApplyExtensions = include$7.ApplyExtensions;
  var Infix_$less$star$great = include$7.$less$star$great;
  var Infix_$less$star = include$7.$less$star;
  var Infix_$star$great = include$7.$star$great;
  var Infix_MonadExtensions = include$8.MonadExtensions;
  var Infix_$great$great$eq = include$8.$great$great$eq;
  var Infix_$eq$less$less = include$8.$eq$less$less;
  var Infix_$great$eq$great = include$8.$great$eq$great;
  var Infix_$less$eq$less = include$8.$less$eq$less;
  var Infix = {
    FunctorExtensions: Infix_FunctorExtensions,
    $less$$great: Infix_$less$$great,
    $less$$$great: Infix_$less$$$great,
    $less$: Infix_$less$,
    $$great: Infix_$$great,
    $less$at$great: Infix_$less$at$great,
    $less$less$$great$great: Infix_$less$less$$great$great,
    ApplyExtensions: Infix_ApplyExtensions,
    $less$star$great: Infix_$less$star$great,
    $less$star: Infix_$less$star,
    $star$great: Infix_$star$great,
    MonadExtensions: Infix_MonadExtensions,
    $great$great$eq: Infix_$great$great$eq,
    $eq$less$less: Infix_$eq$less$less,
    $great$eq$great: Infix_$great$eq$great,
    $less$eq$less: Infix_$less$eq$less
  };
  var include_BsFunctorExtensions = include.BsFunctorExtensions;
  var include_flipMap = include.flipMap;
  var include_void = include.$$void;
  var include_voidRight = include.voidRight;
  var include_voidLeft = include.voidLeft;
  var include_flap = include.flap;
  var include_mapLeft = include$1.mapLeft;
  var include_mapRight = include$1.mapRight;
  var include_mapError = include$1.mapError;
  var include_BsApplyExtensions = include$2.BsApplyExtensions;
  var include_applyFirst = include$2.applyFirst;
  var include_applySecond = include$2.applySecond;
  var include_map2 = include$2.map2;
  var include_map3 = include$2.map3;
  var include_map4 = include$2.map4;
  var include_map5 = include$2.map5;
  var include_tuple2 = include$2.tuple2;
  var include_tuple3 = include$2.tuple3;
  var include_tuple4 = include$2.tuple4;
  var include_tuple5 = include$2.tuple5;
  var include_mapTuple2 = include$2.mapTuple2;
  var include_mapTuple3 = include$2.mapTuple3;
  var include_mapTuple4 = include$2.mapTuple4;
  var include_mapTuple5 = include$2.mapTuple5;
  var include_BsApplicativeExtensions = include$3.BsApplicativeExtensions;
  var include_liftA1 = include$3.liftA1;
  var include_all = include$3.all;
  var include_BsMonadExtensions = include$4.BsMonadExtensions;
  var include_flatMap = include$4.flatMap;
  var include_flatten = include$4.flatten;
  var include_composeKleisli = include$4.composeKleisli;
  var include_flipComposeKleisli = include$4.flipComposeKleisli;
  var include_liftM1 = include$4.liftM1;
  var include_when_ = include$4.when_;
  var include_unless = include$4.unless;
  return {
          WithMonad: WithMonad,
          make: make,
          runResultT: runResultT,
          withResultT: withResultT,
          mapResultT: mapResultT,
          fromResult: fromResult,
          liftF: liftF,
          subflatMap: subflatMap,
          semiflatMap: semiflatMap,
          cond: cond,
          condError: condError,
          Functor: Functor,
          map: map,
          BsFunctorExtensions: include_BsFunctorExtensions,
          flipMap: include_flipMap,
          $$void: include_void,
          voidRight: include_voidRight,
          voidLeft: include_voidLeft,
          flap: include_flap,
          Bifunctor: Bifunctor,
          bimap: bimap,
          mapLeft: include_mapLeft,
          mapRight: include_mapRight,
          mapError: include_mapError,
          Apply: Apply,
          apply: apply,
          BsApplyExtensions: include_BsApplyExtensions,
          applyFirst: include_applyFirst,
          applySecond: include_applySecond,
          map2: include_map2,
          map3: include_map3,
          map4: include_map4,
          map5: include_map5,
          tuple2: include_tuple2,
          tuple3: include_tuple3,
          tuple4: include_tuple4,
          tuple5: include_tuple5,
          mapTuple2: include_mapTuple2,
          mapTuple3: include_mapTuple3,
          mapTuple4: include_mapTuple4,
          mapTuple5: include_mapTuple5,
          Applicative: Applicative,
          pure: pure,
          BsApplicativeExtensions: include_BsApplicativeExtensions,
          liftA1: include_liftA1,
          all: include_all,
          Monad: Monad,
          bind: bind,
          BsMonadExtensions: include_BsMonadExtensions,
          flatMap: include_flatMap,
          flatten: include_flatten,
          composeKleisli: include_composeKleisli,
          flipComposeKleisli: include_flipComposeKleisli,
          liftM1: include_liftM1,
          when_: include_when_,
          unless: include_unless,
          Infix: Infix
        };
}

exports.WithMonad = WithMonad;
exports.WithMonadAndError = WithMonadAndError;
/* Relude__Relude_Result Not a pure module */
