// Generated by Melange
'use strict';

var Curry = require("melange.runtime/curry.js");
var Js_exn = require("melange.belt/./js_exn.js");
var Caml_int32 = require("melange.runtime/caml_int32.js");
var Caml_format = require("melange.runtime/caml_format.js");
var Caml_option = require("melange.runtime/caml_option.js");
var Bastet__String = require("bastet/./String.js");
var Stdlib__String = require("melange/./string.js");
var Relude__Relude_Map = require("./Relude_Map.js");
var Relude__Relude_Set = require("./Relude_Set.js");
var Relude__Relude_Float = require("./Relude_Float.js");
var Relude__Relude_List_Base = require("./list/Relude_List_Base.js");
var Relude__Relude_Array_Base = require("./array/Relude_Array_Base.js");
var Relude__Relude_Extensions_Eq = require("./extensions/Relude_Extensions_Eq.js");
var Relude__Relude_Extensions_Ord = require("./extensions/Relude_Extensions_Ord.js");
var Relude__Relude_List_Instances = require("./list/Relude_List_Instances.js");
var Relude__Relude_Array_Instances = require("./array/Relude_Array_Instances.js");
var Relude__Relude_Extensions_Monoid = require("./extensions/Relude_Extensions_Monoid.js");
var Relude__Relude_Extensions_Semigroup = require("./extensions/Relude_Extensions_Semigroup.js");

var empty = "";

function length(prim) {
  return prim.length;
}

function isEmpty(s) {
  return s.length === 0;
}

function isNonEmpty(s) {
  return s.length !== 0;
}

function toNonEmpty(s) {
  if (s.length === 0) {
    return ;
  } else {
    return s;
  }
}

function trim(prim) {
  return prim.trim();
}

function isWhitespace(s) {
  var s$1 = s.trim();
  return s$1.length === 0;
}

function isNonWhitespace(s) {
  var s$1 = s.trim();
  return s$1.length !== 0;
}

function toNonWhitespace(s) {
  var s$1 = s.trim();
  if (s$1.length === 0) {
    return ;
  } else {
    return s;
  }
}

function concat(a, b) {
  return a + b;
}

var Semigroup = {
  append: concat
};

var include = Relude__Relude_Extensions_Semigroup.SemigroupExtensions(Semigroup);

var Monoid = {
  append: concat,
  empty: empty
};

var include$1 = Relude__Relude_Extensions_Monoid.MonoidExtensions(Monoid);

function concatArray(array) {
  return Curry._3(Relude__Relude_Array_Instances.foldLeft, (function (acc, str) {
                return acc + str;
              }), "", array);
}

function concatList(list) {
  return Relude__Relude_List_Instances.foldLeft((function (acc, str) {
                  return acc + str;
                }), "")(list);
}

function make(prim) {
  return String(prim);
}

function makeWithIndex(i, f) {
  var _acc = "";
  var _idx = 0;
  while(true) {
    var idx = _idx;
    var acc = _acc;
    if (idx >= i) {
      return acc;
    }
    _idx = idx + 1 | 0;
    _acc = acc + Curry._1(f, idx);
    continue ;
  };
}

function repeat(i, str) {
  var _acc = "";
  var _i = i;
  while(true) {
    var i$1 = _i;
    var acc = _acc;
    if (i$1 <= 0) {
      return acc;
    }
    _i = i$1 - 1 | 0;
    _acc = acc + str;
    continue ;
  };
}

function toUpperCase(prim) {
  return prim.toUpperCase();
}

function toLowerCase(prim) {
  return prim.toLowerCase();
}

function fromCharCode(prim) {
  return String.fromCharCode(prim);
}

function charCodeAt(i, str) {
  var code = str.charCodeAt(i);
  if (Relude__Relude_Float.$$isNaN(code)) {
    return ;
  } else {
    return code | 0;
  }
}

function charAt(i, str) {
  return Caml_option.nullable_to_opt(str[i]);
}

function charAtOrEmpty(i, str) {
  var x = str[i];
  if (x == null) {
    return "";
  } else if (x == null) {
    return ;
  } else {
    return Caml_option.some(x);
  }
}

function charAtNullable(i, str) {
  return str[i];
}

function charAtOrThrow(i, str) {
  var v = str[i];
  if (v == null) {
    return Js_exn.raiseRangeError("Failed to get string at index " + (String(i) + (" for string: " + str)));
  } else if (v == null) {
    return ;
  } else {
    return Caml_option.some(v);
  }
}

function toList(str) {
  return Relude__Relude_List_Base.makeWithIndex(str.length, (function (i) {
                return charAtOrThrow(i, str);
              }));
}

function toArray(str) {
  return Relude__Relude_Array_Base.makeWithIndex(str.length, (function (i) {
                return charAtOrThrow(i, str);
              }));
}

function foldLeft(f, init, str) {
  return Relude__Relude_List_Instances.foldLeft(f, init)(toList(str));
}

function foldRight(f, init, str) {
  return Relude__Relude_List_Instances.foldRight(f, init)(toList(str));
}

function show(a) {
  return a;
}

var Show = {
  show: show
};

function eq(a, b) {
  return a === b;
}

var Eq = {
  eq: eq
};

var include$2 = Relude__Relude_Extensions_Eq.EqExtensions(Eq);

var compare = Bastet__String.Ord.compare;

var Ord = {
  eq: eq,
  compare: compare
};

var include$3 = Relude__Relude_Extensions_Ord.OrdExtensions(Ord);

var $$Map = Relude__Relude_Map.WithOrd(Ord);

var $$Set = Relude__Relude_Set.WithOrd(Ord);

function endsWith(search, input) {
  return input.endsWith(search);
}

function startsWith(search, input) {
  return input.startsWith(search);
}

function contains(search, input) {
  return input.includes(search);
}

function indexOf(search, input) {
  var index = input.indexOf(search);
  if (index < 0) {
    return ;
  } else {
    return index;
  }
}

function lastIndexOf(search, input) {
  var index = input.lastIndexOf(search);
  if (index < 0) {
    return ;
  } else {
    return index;
  }
}

function slice(fromIndex, toIndex, input) {
  return input.slice(fromIndex, toIndex);
}

function sliceToEnd(fromIndex, str) {
  return str.slice(fromIndex);
}

function splitArray(delimiter, input) {
  return input.split(delimiter);
}

function splitList(delimiter, input) {
  return Relude__Relude_List_Instances.fromArray(input.split(delimiter));
}

function splitAt(index, input) {
  return [
          input.slice(0, index),
          input.slice(index)
        ];
}

function mapChars(f, str) {
  return Curry._3(Relude__Relude_List_Instances.foldMap, Monoid, f, toList(str));
}

function padStart(targetLength, padWithOpt, input) {
  var padWith = padWithOpt !== undefined ? padWithOpt : " ";
  var inputLength = input.length;
  var padWithLength = padWith.length;
  if (inputLength >= targetLength) {
    return input;
  }
  if (padWithLength === 0) {
    return input;
  }
  var padLength = targetLength - inputLength | 0;
  var padTimes = Caml_int32.div(padLength, padWithLength) + 1 | 0;
  var pad = repeat(padTimes, padWith).slice(0, padLength);
  return pad + input;
}

function padEnd(targetLength, padWithOpt, input) {
  var padWith = padWithOpt !== undefined ? padWithOpt : " ";
  var inputLength = input.length;
  var padWithLength = padWith.length;
  if (inputLength >= targetLength) {
    return input;
  }
  if (padWithLength === 0) {
    return input;
  }
  var padLength = targetLength - inputLength | 0;
  var padTimes = Caml_int32.div(padLength, padWithLength) + 1 | 0;
  var pad = repeat(padTimes, padWith).slice(0, padLength);
  return input + pad;
}

function replaceFirst(search, replaceWith, input) {
  return input.replace(search, replaceWith);
}

function replaceEach(search, replaceWith, input) {
  return Stdlib__String.concat(replaceWith, Relude__Relude_List_Instances.fromArray(input.split(search)));
}

function replaceRegex(search, replaceWith, input) {
  return input.replace(search, replaceWith);
}

function removeFirst(search, input) {
  return input.replace(search, "");
}

function removeEach(search, input) {
  return replaceEach(search, "", input);
}

function fromInt(prim) {
  return String(prim);
}

function toInt(v) {
  try {
    return Caml_format.caml_int_of_string(v);
  }
  catch (exn){
    return ;
  }
}

function fromFloat(prim) {
  return prim.toString();
}

function toFloat(v) {
  try {
    return Caml_format.caml_float_of_string(v);
  }
  catch (exn){
    return ;
  }
}

var isNotEmpty = isNonEmpty;

var concatNamed = include.concatNamed;

var BsMonoidExtensions = include$1.BsMonoidExtensions;

var guard = include$1.guard;

var power = include$1.power;

var eqWithConversion = include$2.eqWithConversion;

var notEq = include$2.notEq;

var eqInverted = include$2.eqInverted;

var EqInverted = include$2.EqInverted;

var EqBy = include$2.EqBy;

var compareWithConversion = include$3.compareWithConversion;

var compareReversed = include$3.compareReversed;

var OrdReversed = include$3.OrdReversed;

var compareAsInt = include$3.compareAsInt;

var min = include$3.min;

var max = include$3.max;

var lessThan = include$3.lessThan;

var lt = include$3.lt;

var lessThanOrEq = include$3.lessThanOrEq;

var lte = include$3.lte;

var greaterThan = include$3.greaterThan;

var gt = include$3.gt;

var greaterThanOrEq = include$3.greaterThanOrEq;

var gte = include$3.gte;

var clamp = include$3.clamp;

var between = include$3.between;

var OrdRingExtensions = include$3.OrdRingExtensions;

var OrdNamed = include$3.OrdNamed;

var OrdBy = include$3.OrdBy;

var splitAsArray = splitArray;

var splitAsList = splitList;

exports.empty = empty;
exports.length = length;
exports.isEmpty = isEmpty;
exports.isNonEmpty = isNonEmpty;
exports.isNotEmpty = isNotEmpty;
exports.toNonEmpty = toNonEmpty;
exports.trim = trim;
exports.isWhitespace = isWhitespace;
exports.isNonWhitespace = isNonWhitespace;
exports.toNonWhitespace = toNonWhitespace;
exports.concat = concat;
exports.Semigroup = Semigroup;
exports.concatNamed = concatNamed;
exports.Monoid = Monoid;
exports.BsMonoidExtensions = BsMonoidExtensions;
exports.guard = guard;
exports.power = power;
exports.concatArray = concatArray;
exports.concatList = concatList;
exports.make = make;
exports.makeWithIndex = makeWithIndex;
exports.repeat = repeat;
exports.toUpperCase = toUpperCase;
exports.toLowerCase = toLowerCase;
exports.fromCharCode = fromCharCode;
exports.charCodeAt = charCodeAt;
exports.charAt = charAt;
exports.charAtOrEmpty = charAtOrEmpty;
exports.charAtNullable = charAtNullable;
exports.charAtOrThrow = charAtOrThrow;
exports.toList = toList;
exports.toArray = toArray;
exports.foldLeft = foldLeft;
exports.foldRight = foldRight;
exports.show = show;
exports.Show = Show;
exports.eq = eq;
exports.Eq = Eq;
exports.eqWithConversion = eqWithConversion;
exports.notEq = notEq;
exports.eqInverted = eqInverted;
exports.EqInverted = EqInverted;
exports.EqBy = EqBy;
exports.compare = compare;
exports.Ord = Ord;
exports.compareWithConversion = compareWithConversion;
exports.compareReversed = compareReversed;
exports.OrdReversed = OrdReversed;
exports.compareAsInt = compareAsInt;
exports.min = min;
exports.max = max;
exports.lessThan = lessThan;
exports.lt = lt;
exports.lessThanOrEq = lessThanOrEq;
exports.lte = lte;
exports.greaterThan = greaterThan;
exports.gt = gt;
exports.greaterThanOrEq = greaterThanOrEq;
exports.gte = gte;
exports.clamp = clamp;
exports.between = between;
exports.OrdRingExtensions = OrdRingExtensions;
exports.OrdNamed = OrdNamed;
exports.OrdBy = OrdBy;
exports.$$Map = $$Map;
exports.$$Set = $$Set;
exports.endsWith = endsWith;
exports.startsWith = startsWith;
exports.contains = contains;
exports.indexOf = indexOf;
exports.lastIndexOf = lastIndexOf;
exports.slice = slice;
exports.sliceToEnd = sliceToEnd;
exports.splitArray = splitArray;
exports.splitAsArray = splitAsArray;
exports.splitList = splitList;
exports.splitAsList = splitAsList;
exports.splitAt = splitAt;
exports.mapChars = mapChars;
exports.padStart = padStart;
exports.padEnd = padEnd;
exports.replaceFirst = replaceFirst;
exports.replaceEach = replaceEach;
exports.replaceRegex = replaceRegex;
exports.removeFirst = removeFirst;
exports.removeEach = removeEach;
exports.fromInt = fromInt;
exports.toInt = toInt;
exports.fromFloat = fromFloat;
exports.toFloat = toFloat;
/* include Not a pure module */
