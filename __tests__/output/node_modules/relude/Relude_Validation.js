// Generated by Melange
'use strict';

var Curry = require("melange.runtime/curry.js");
var Caml_option = require("melange.runtime/caml_option.js");
var Relude__Relude_NonEmpty = require("./Relude_NonEmpty.js");
var Relude__Relude_Extensions_Apply = require("./extensions/Relude_Extensions_Apply.js");
var Relude__Relude_Extensions_Monad = require("./extensions/Relude_Extensions_Monad.js");
var Relude__Relude_Extensions_Functor = require("./extensions/Relude_Extensions_Functor.js");
var Relude__Relude_Extensions_Semialign = require("./extensions/Relude_Extensions_Semialign.js");
var Relude__Relude_Extensions_Applicative = require("./extensions/Relude_Extensions_Applicative.js");

function ok(a) {
  return {
          TAG: /* VOk */0,
          _0: a
        };
}

function error(e) {
  return {
          TAG: /* VError */1,
          _0: e
        };
}

function errorNel(e) {
  return {
          TAG: /* VError */1,
          _0: Relude__Relude_NonEmpty.List.pure(e)
        };
}

function errorNea(e) {
  return {
          TAG: /* VError */1,
          _0: Relude__Relude_NonEmpty.$$Array.pure(e)
        };
}

function isOk(param) {
  if (param.TAG === /* VOk */0) {
    return true;
  } else {
    return false;
  }
}

function isError(a) {
  return !isOk(a);
}

function map(f, a) {
  if (a.TAG === /* VOk */0) {
    return {
            TAG: /* VOk */0,
            _0: Curry._1(f, a._0)
          };
  } else {
    return a;
  }
}

function tap(f, e) {
  if (e.TAG !== /* VOk */0) {
    return e;
  }
  Curry._1(f, e._0);
  return e;
}

function mapError(f, ok) {
  if (ok.TAG === /* VOk */0) {
    return ok;
  } else {
    return {
            TAG: /* VError */1,
            _0: Curry._1(f, ok._0)
          };
  }
}

function mapErrorsNea(f, ok) {
  if (ok.TAG === /* VOk */0) {
    return ok;
  } else {
    return {
            TAG: /* VError */1,
            _0: Relude__Relude_NonEmpty.$$Array.map(f, ok._0)
          };
  }
}

function mapErrorsNel(f, ok) {
  if (ok.TAG === /* VOk */0) {
    return ok;
  } else {
    return {
            TAG: /* VError */1,
            _0: Relude__Relude_NonEmpty.List.map(f, ok._0)
          };
  }
}

function tapError(f, ok) {
  if (ok.TAG === /* VOk */0) {
    return ok;
  }
  Curry._1(f, ok._0);
  return ok;
}

function bimap(f, g, a) {
  if (a.TAG === /* VOk */0) {
    return {
            TAG: /* VOk */0,
            _0: Curry._1(f, a._0)
          };
  } else {
    return {
            TAG: /* VError */1,
            _0: Curry._1(g, a._0)
          };
  }
}

function bitap(f, g, ok) {
  if (ok.TAG === /* VOk */0) {
    Curry._1(f, ok._0);
    return ok;
  }
  Curry._1(g, ok._0);
  return ok;
}

function applyWithAppendErrors(appendErrors, ff, fv) {
  if (ff.TAG === /* VOk */0) {
    if (fv.TAG === /* VOk */0) {
      return {
              TAG: /* VOk */0,
              _0: Curry._1(ff._0, fv._0)
            };
    } else {
      return {
              TAG: /* VError */1,
              _0: fv._0
            };
    }
  }
  var e = ff._0;
  if (fv.TAG === /* VOk */0) {
    return {
            TAG: /* VError */1,
            _0: e
          };
  } else {
    return {
            TAG: /* VError */1,
            _0: Curry._2(appendErrors, e, fv._0)
          };
  }
}

function alignWithAppendErrors(appendErrors, fa, fb) {
  if (fa.TAG !== /* VOk */0) {
    if (fb.TAG === /* VOk */0) {
      return {
              TAG: /* VOk */0,
              _0: {
                TAG: /* That */1,
                _0: fb._0
              }
            };
    } else {
      return {
              TAG: /* VError */1,
              _0: Curry._2(appendErrors, fa._0, fb._0)
            };
    }
  }
  var a = fa._0;
  if (fb.TAG === /* VOk */0) {
    return {
            TAG: /* VOk */0,
            _0: {
              TAG: /* Both */2,
              _0: a,
              _1: fb._0
            }
          };
  } else {
    return {
            TAG: /* VOk */0,
            _0: {
              TAG: /* This */0,
              _0: a
            }
          };
  }
}

function alignWithWithAppendErrors(appendErrors, f, fa, fb) {
  return map(f, alignWithAppendErrors(appendErrors, fa, fb));
}

function pure(a) {
  return {
          TAG: /* VOk */0,
          _0: a
        };
}

function bind(fa, f) {
  if (fa.TAG === /* VOk */0) {
    return Curry._1(f, fa._0);
  } else {
    return {
            TAG: /* VError */1,
            _0: fa._0
          };
  }
}

function flatMap(f, fa) {
  return bind(fa, f);
}

function fromResult(a) {
  if (a.TAG === /* Ok */0) {
    return {
            TAG: /* VOk */0,
            _0: a._0
          };
  } else {
    return {
            TAG: /* VError */1,
            _0: a._0
          };
  }
}

function toResult(a) {
  if (a.TAG === /* VOk */0) {
    return {
            TAG: /* Ok */0,
            _0: a._0
          };
  } else {
    return {
            TAG: /* Error */1,
            _0: a._0
          };
  }
}

function fromOption(defaultError, a) {
  if (a !== undefined) {
    return {
            TAG: /* VOk */0,
            _0: Caml_option.valFromOption(a)
          };
  } else {
    return {
            TAG: /* VError */1,
            _0: defaultError
          };
  }
}

function fromOptionLazy(getDefaultError, a) {
  if (a !== undefined) {
    return {
            TAG: /* VOk */0,
            _0: Caml_option.valFromOption(a)
          };
  } else {
    return {
            TAG: /* VError */1,
            _0: Curry._1(getDefaultError, undefined)
          };
  }
}

function fold(ec, ac, a) {
  if (a.TAG === /* VOk */0) {
    return Curry._1(ac, a._0);
  } else {
    return Curry._1(ec, a._0);
  }
}

function flip(fa) {
  return fold((function (e) {
                return {
                        TAG: /* VOk */0,
                        _0: e
                      };
              }), (function (a) {
                return {
                        TAG: /* VError */1,
                        _0: a
                      };
              }), fa);
}

function map2(appendErrors, f, fa, fb) {
  return applyWithAppendErrors(appendErrors, map(f, fa), fb);
}

function map3(appendErrors, f, fa, fb, fc) {
  return applyWithAppendErrors(appendErrors, map2(appendErrors, f, fa, fb), fc);
}

function map4(appendErrors, f, fa, fb, fc, fd) {
  return applyWithAppendErrors(appendErrors, map3(appendErrors, f, fa, fb, fc), fd);
}

function map5(appendErrors, f, fa, fb, fc, fd, fe) {
  return applyWithAppendErrors(appendErrors, map4(appendErrors, f, fa, fb, fc, fd), fe);
}

function WithErrors(Errors, $$Error) {
  var Functor = {
    map: map
  };
  var include = Relude__Relude_Extensions_Functor.FunctorExtensions(Functor);
  var apply = function (ff, fa) {
    return applyWithAppendErrors(Errors.append, ff, fa);
  };
  var Apply = {
    map: map,
    apply: apply
  };
  var include$1 = Relude__Relude_Extensions_Apply.ApplyExtensions(Apply);
  var Applicative = {
    map: map,
    apply: apply,
    pure: pure
  };
  var include$2 = Relude__Relude_Extensions_Applicative.ApplicativeExtensions(Applicative);
  var align = function (fa, fb) {
    return alignWithAppendErrors(Errors.append, fa, fb);
  };
  var alignWith = function (f, fa, fb) {
    return alignWithWithAppendErrors(Errors.append, f, fa, fb);
  };
  var Semialign = {
    map: map,
    align: align,
    alignWith: alignWith
  };
  Relude__Relude_Extensions_Semialign.SemialignExtensions(Semialign);
  var Monad = {
    map: map,
    apply: apply,
    pure: pure,
    flat_map: bind
  };
  var include$3 = Relude__Relude_Extensions_Monad.MonadExtensions(Monad);
  var include$4 = Relude__Relude_Extensions_Functor.FunctorInfix(Functor);
  var include$5 = Relude__Relude_Extensions_Apply.ApplyInfix(Apply);
  var include$6 = Relude__Relude_Extensions_Monad.MonadInfix(Monad);
  var Infix_FunctorExtensions = include$4.FunctorExtensions;
  var Infix_$less$$great = include$4.$less$$great;
  var Infix_$less$$$great = include$4.$less$$$great;
  var Infix_$less$ = include$4.$less$;
  var Infix_$$great = include$4.$$great;
  var Infix_$less$at$great = include$4.$less$at$great;
  var Infix_ApplyExtensions = include$5.ApplyExtensions;
  var Infix_$less$star$great = include$5.$less$star$great;
  var Infix_$less$star = include$5.$less$star;
  var Infix_$star$great = include$5.$star$great;
  var Infix_MonadExtensions = include$6.MonadExtensions;
  var Infix_$great$great$eq = include$6.$great$great$eq;
  var Infix_$eq$less$less = include$6.$eq$less$less;
  var Infix_$great$eq$great = include$6.$great$eq$great;
  var Infix_$less$eq$less = include$6.$less$eq$less;
  var Infix = {
    FunctorExtensions: Infix_FunctorExtensions,
    $less$$great: Infix_$less$$great,
    $less$$$great: Infix_$less$$$great,
    $less$: Infix_$less$,
    $$great: Infix_$$great,
    $less$at$great: Infix_$less$at$great,
    ApplyExtensions: Infix_ApplyExtensions,
    $less$star$great: Infix_$less$star$great,
    $less$star: Infix_$less$star,
    $star$great: Infix_$star$great,
    MonadExtensions: Infix_MonadExtensions,
    $great$great$eq: Infix_$great$great$eq,
    $eq$less$less: Infix_$eq$less$less,
    $great$eq$great: Infix_$great$eq$great,
    $less$eq$less: Infix_$less$eq$less
  };
  return {
          Functor: Functor,
          map: map,
          BsFunctorExtensions: include.BsFunctorExtensions,
          flipMap: include.flipMap,
          $$void: include.$$void,
          voidRight: include.voidRight,
          voidLeft: include.voidLeft,
          flap: include.flap,
          Apply: Apply,
          apply: apply,
          BsApplyExtensions: include$1.BsApplyExtensions,
          applyFirst: include$1.applyFirst,
          applySecond: include$1.applySecond,
          map2: include$1.map2,
          map3: include$1.map3,
          map4: include$1.map4,
          map5: include$1.map5,
          tuple2: include$1.tuple2,
          tuple3: include$1.tuple3,
          tuple4: include$1.tuple4,
          tuple5: include$1.tuple5,
          mapTuple2: include$1.mapTuple2,
          mapTuple3: include$1.mapTuple3,
          mapTuple4: include$1.mapTuple4,
          mapTuple5: include$1.mapTuple5,
          Applicative: Applicative,
          pure: pure,
          BsApplicativeExtensions: include$2.BsApplicativeExtensions,
          liftA1: include$2.liftA1,
          all: include$2.all,
          Semialign: Semialign,
          Monad: Monad,
          bind: bind,
          BsMonadExtensions: include$3.BsMonadExtensions,
          flatMap: include$3.flatMap,
          flatten: include$3.flatten,
          composeKleisli: include$3.composeKleisli,
          flipComposeKleisli: include$3.flipComposeKleisli,
          liftM1: include$3.liftM1,
          when_: include$3.when_,
          unless: include$3.unless,
          Infix: Infix
        };
}

exports.ok = ok;
exports.error = error;
exports.errorNel = errorNel;
exports.errorNea = errorNea;
exports.isOk = isOk;
exports.isError = isError;
exports.map = map;
exports.tap = tap;
exports.mapError = mapError;
exports.mapErrorsNea = mapErrorsNea;
exports.mapErrorsNel = mapErrorsNel;
exports.tapError = tapError;
exports.bimap = bimap;
exports.bitap = bitap;
exports.applyWithAppendErrors = applyWithAppendErrors;
exports.alignWithAppendErrors = alignWithAppendErrors;
exports.alignWithWithAppendErrors = alignWithWithAppendErrors;
exports.pure = pure;
exports.bind = bind;
exports.flatMap = flatMap;
exports.fromResult = fromResult;
exports.toResult = toResult;
exports.fromOption = fromOption;
exports.fromOptionLazy = fromOptionLazy;
exports.fold = fold;
exports.flip = flip;
exports.map2 = map2;
exports.map3 = map3;
exports.map4 = map4;
exports.map5 = map5;
exports.WithErrors = WithErrors;
/* Relude__Relude_NonEmpty Not a pure module */
