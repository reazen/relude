// Generated by Melange
'use strict';

var Relude__Relude_Extensions_Eq = require("./extensions/Relude_Extensions_Eq.js");
var Relude__Relude_Extensions_Ord = require("./extensions/Relude_Extensions_Ord.js");
var Relude__Relude_Extensions_Enum = require("./extensions/Relude_Extensions_Enum.js");
var Relude__Relude_Extensions_Bounded = require("./extensions/Relude_Extensions_Bounded.js");
var Relude__Relude_Extensions_BoundedEnum = require("./extensions/Relude_Extensions_BoundedEnum.js");

function fromInt(i) {
  if (i < 0) {
    return "less_than";
  } else if (i === 0) {
    return "equal_to";
  } else {
    return "greater_than";
  }
}

function toInt(param) {
  if (param === "greater_than") {
    return 1;
  } else if (param === "less_than") {
    return -1;
  } else {
    return 0;
  }
}

function reverse(param) {
  if (param === "greater_than") {
    return "less_than";
  } else if (param === "less_than") {
    return "greater_than";
  } else {
    return "equal_to";
  }
}

function eq(a, b) {
  return a === b;
}

var Eq = {
  eq: eq
};

var include = Relude__Relude_Extensions_Eq.EqExtensions(Eq);

function compare(o1, o2) {
  if (o1 === "greater_than") {
    if (o2 === "greater_than") {
      return "equal_to";
    } else {
      return "greater_than";
    }
  } else if (o1 === "less_than") {
    if (o2 === "less_than") {
      return "equal_to";
    } else {
      return "less_than";
    }
  } else if (o2 === "greater_than") {
    return "less_than";
  } else if (o2 === "less_than") {
    return "greater_than";
  } else {
    return "equal_to";
  }
}

var Ord = {
  eq: eq,
  compare: compare
};

var include$1 = Relude__Relude_Extensions_Ord.OrdExtensions(Ord);

var Bounded = {
  eq: eq,
  compare: compare,
  top: "greater_than",
  bottom: "less_than"
};

Relude__Relude_Extensions_Bounded.BoundedExtensions(Bounded);

function pred(param) {
  if (param === "greater_than") {
    return "equal_to";
  } else if (param === "less_than") {
    return ;
  } else {
    return "less_than";
  }
}

function succ(param) {
  if (param === "greater_than") {
    return ;
  } else if (param === "less_than") {
    return "equal_to";
  } else {
    return "greater_than";
  }
}

var Enum = {
  eq: eq,
  compare: compare,
  succ: succ,
  pred: pred
};

Relude__Relude_Extensions_Enum.EnumExtensions(Enum);

function toEnum(i) {
  return fromInt(i);
}

var BoundedEnum = {
  top: "greater_than",
  bottom: "less_than",
  eq: eq,
  compare: compare,
  succ: succ,
  pred: pred,
  cardinality: 3,
  fromEnum: toInt,
  toEnum: toEnum
};

var include$2 = Relude__Relude_Extensions_BoundedEnum.BoundedEnumExtensions(BoundedEnum);

var eqWithConversion = include.eqWithConversion;

var notEq = include.notEq;

var eqInverted = include.eqInverted;

var EqInverted = include.EqInverted;

var EqBy = include.EqBy;

var compareWithConversion = include$1.compareWithConversion;

var compareReversed = include$1.compareReversed;

var OrdReversed = include$1.OrdReversed;

var compareAsInt = include$1.compareAsInt;

var min = include$1.min;

var max = include$1.max;

var lessThan = include$1.lessThan;

var lt = include$1.lt;

var lessThanOrEq = include$1.lessThanOrEq;

var lte = include$1.lte;

var greaterThan = include$1.greaterThan;

var gt = include$1.gt;

var greaterThanOrEq = include$1.greaterThanOrEq;

var gte = include$1.gte;

var clamp = include$1.clamp;

var between = include$1.between;

var OrdRingExtensions = include$1.OrdRingExtensions;

var OrdNamed = include$1.OrdNamed;

var OrdBy = include$1.OrdBy;

var top = "greater_than";

var bottom = "less_than";

var fromToAsList = include$2.fromToAsList;

var upFromAsList = include$2.upFromAsList;

var upFromIncludingAsList = include$2.upFromIncludingAsList;

var downFromAsList = include$2.downFromAsList;

var downFromIncludingAsList = include$2.downFromIncludingAsList;

var fromThenToAsList = include$2.fromThenToAsList;

var inverseMapEqBy = include$2.inverseMapEqBy;

var inverseMapEq = include$2.inverseMapEq;

var inverseMapOrdBy = include$2.inverseMapOrdBy;

var inverseMapOrd = include$2.inverseMapOrd;

var inverseMapString = include$2.inverseMapString;

exports.fromInt = fromInt;
exports.toInt = toInt;
exports.reverse = reverse;
exports.eq = eq;
exports.Eq = Eq;
exports.eqWithConversion = eqWithConversion;
exports.notEq = notEq;
exports.eqInverted = eqInverted;
exports.EqInverted = EqInverted;
exports.EqBy = EqBy;
exports.compare = compare;
exports.Ord = Ord;
exports.compareWithConversion = compareWithConversion;
exports.compareReversed = compareReversed;
exports.OrdReversed = OrdReversed;
exports.compareAsInt = compareAsInt;
exports.min = min;
exports.max = max;
exports.lessThan = lessThan;
exports.lt = lt;
exports.lessThanOrEq = lessThanOrEq;
exports.lte = lte;
exports.greaterThan = greaterThan;
exports.gt = gt;
exports.greaterThanOrEq = greaterThanOrEq;
exports.gte = gte;
exports.clamp = clamp;
exports.between = between;
exports.OrdRingExtensions = OrdRingExtensions;
exports.OrdNamed = OrdNamed;
exports.OrdBy = OrdBy;
exports.top = top;
exports.bottom = bottom;
exports.Bounded = Bounded;
exports.pred = pred;
exports.succ = succ;
exports.Enum = Enum;
exports.BoundedEnum = BoundedEnum;
exports.fromToAsList = fromToAsList;
exports.upFromAsList = upFromAsList;
exports.upFromIncludingAsList = upFromIncludingAsList;
exports.downFromAsList = downFromAsList;
exports.downFromIncludingAsList = downFromIncludingAsList;
exports.fromThenToAsList = fromThenToAsList;
exports.inverseMapEqBy = inverseMapEqBy;
exports.inverseMapEq = inverseMapEq;
exports.inverseMapOrdBy = inverseMapOrdBy;
exports.inverseMapOrd = inverseMapOrd;
exports.inverseMapString = inverseMapString;
/* include Not a pure module */
