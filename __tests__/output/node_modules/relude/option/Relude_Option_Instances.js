// Generated by Melange
'use strict';

var Curry = require("melange.runtime/curry.js");
var Caml_option = require("melange.runtime/caml_option.js");
var Bastet__Option = require("bastet/./Option.js");
var Relude__Relude_Function = require("../Relude_Function.js");
var Relude__Relude_Extensions_Alt = require("../extensions/Relude_Extensions_Alt.js");
var Relude__Relude_Extensions_Plus = require("../extensions/Relude_Extensions_Plus.js");
var Relude__Relude_Extensions_Align = require("../extensions/Relude_Extensions_Align.js");
var Relude__Relude_Extensions_Apply = require("../extensions/Relude_Extensions_Apply.js");
var Relude__Relude_Extensions_Monad = require("../extensions/Relude_Extensions_Monad.js");
var Relude__Relude_Extensions_Monoid = require("../extensions/Relude_Extensions_Monoid.js");
var Relude__Relude_Extensions_Functor = require("../extensions/Relude_Extensions_Functor.js");
var Relude__Relude_Extensions_Foldable = require("../extensions/Relude_Extensions_Foldable.js");
var Relude__Relude_Extensions_Semialign = require("../extensions/Relude_Extensions_Semialign.js");
var Relude__Relude_Extensions_Semigroup = require("../extensions/Relude_Extensions_Semigroup.js");
var Relude__Relude_Extensions_Alternative = require("../extensions/Relude_Extensions_Alternative.js");
var Relude__Relude_Extensions_Applicative = require("../extensions/Relude_Extensions_Applicative.js");
var Relude__Relude_Extensions_Traversable = require("../extensions/Relude_Extensions_Traversable.js");
var Relude__Relude_Extensions_Semigroupoid = require("../extensions/Relude_Extensions_Semigroupoid.js");

function compose(optionBToC, optionAToB) {
  if (optionAToB !== undefined && optionBToC !== undefined) {
    return (function (param) {
              return Relude__Relude_Function.Infix.$great$great(optionAToB, optionBToC, param);
            });
  }
  
}

var Semigroupoid = {
  compose: compose
};

var include = Relude__Relude_Extensions_Semigroupoid.SemigroupoidExtensions(Semigroupoid);

function map(f, x) {
  if (x !== undefined) {
    return Caml_option.some(Curry._1(f, Caml_option.valFromOption(x)));
  }
  
}

var Functor = {
  map: map
};

var include$1 = Relude__Relude_Extensions_Functor.FunctorExtensions(Functor);

var apply = Bastet__Option.Apply.apply;

var Apply = {
  map: map,
  apply: apply
};

var include$2 = Relude__Relude_Extensions_Apply.ApplyExtensions(Apply);

function pure(v) {
  return Caml_option.some(v);
}

var Applicative = {
  map: map,
  apply: apply,
  pure: pure
};

var include$3 = Relude__Relude_Extensions_Applicative.ApplicativeExtensions(Applicative);

function bind(x, f) {
  if (x !== undefined) {
    return Curry._1(f, Caml_option.valFromOption(x));
  }
  
}

var Monad = {
  map: map,
  apply: apply,
  pure: pure,
  flat_map: bind
};

var include$4 = Relude__Relude_Extensions_Monad.MonadExtensions(Monad);

function align(fa, fb) {
  if (fa === undefined) {
    if (fb !== undefined) {
      return {
              TAG: /* That */1,
              _0: Caml_option.valFromOption(fb)
            };
    } else {
      return ;
    }
  }
  var a = Caml_option.valFromOption(fa);
  if (fb !== undefined) {
    return {
            TAG: /* Both */2,
            _0: a,
            _1: Caml_option.valFromOption(fb)
          };
  } else {
    return {
            TAG: /* This */0,
            _0: a
          };
  }
}

function alignWith(f, fa, fb) {
  return map(f, align(fa, fb));
}

var Semialign = {
  map: map,
  align: align,
  alignWith: alignWith
};

Relude__Relude_Extensions_Semialign.SemialignExtensions(Semialign);

var Align = {
  map: map,
  align: align,
  alignWith: alignWith,
  nil: undefined
};

Relude__Relude_Extensions_Align.AlignExtensions(Align);

function foldLeft(fn, $$default) {
  return function (param) {
    return Bastet__Option.Foldable.fold_left(fn, $$default, param);
  };
}

function foldRight(fn, $$default) {
  return function (param) {
    return Bastet__Option.Foldable.fold_right(fn, $$default, param);
  };
}

var include$5 = Relude__Relude_Extensions_Foldable.FoldableExtensions(Bastet__Option.Foldable);

function alt(fa1, fa2) {
  if (fa1 !== undefined) {
    return fa1;
  } else {
    return fa2;
  }
}

function altLazy(fa1, getFA2) {
  if (fa1 !== undefined) {
    return fa1;
  } else {
    return Curry._1(getFA2, undefined);
  }
}

var Semigroup_Any = {
  append: alt
};

var Monoid_Any = {
  append: alt,
  empty: undefined
};

var include$6 = Relude__Relude_Extensions_Alt.AltExtensions(Bastet__Option.Alt);

Relude__Relude_Extensions_Plus.PlusExtensions(Bastet__Option.Plus);

Relude__Relude_Extensions_Alternative.AlternativeExtensions(Bastet__Option.Alternative);

function eqBy(innerEq, a, b) {
  if (a !== undefined) {
    if (b !== undefined) {
      return Curry._2(innerEq, Caml_option.valFromOption(a), Caml_option.valFromOption(b));
    } else {
      return false;
    }
  } else {
    return b === undefined;
  }
}

function eq(showA, fa1, fa2) {
  var Eq = Bastet__Option.Eq(showA);
  return Curry._2(Eq.eq, fa1, fa2);
}

function Eq(EqA) {
  var eq = function (xs, ys) {
    return eqBy(EqA.eq, xs, ys);
  };
  return {
          eq: eq
        };
}

function showBy(showA, a) {
  if (a !== undefined) {
    return "Some(" + (Curry._1(showA, Caml_option.valFromOption(a)) + ")");
  } else {
    return "None";
  }
}

function show(showA, fa) {
  var Show = Bastet__Option.Show(showA);
  return Curry._1(Show.show, fa);
}

function WithSemigroup(S) {
  var Semigroup = Bastet__Option.Semigroup(S);
  var include = Relude__Relude_Extensions_Semigroup.SemigroupExtensions(Semigroup);
  var Monoid = Bastet__Option.Monoid(S);
  var include$1 = Relude__Relude_Extensions_Monoid.MonoidExtensions(Monoid);
  return {
          Semigroup: Semigroup,
          concatNamed: include.concatNamed,
          Monoid: Monoid,
          BsMonoidExtensions: include$1.BsMonoidExtensions,
          guard: include$1.guard,
          power: include$1.power
        };
}

function WithApplicative(A) {
  var Traversable = Bastet__Option.Traversable(A);
  Relude__Relude_Extensions_Traversable.TraversableExtensions(Traversable);
  return {
          Traversable: Traversable
        };
}

var andThen = include.andThen;

var BsFunctorExtensions = include$1.BsFunctorExtensions;

var flipMap = include$1.flipMap;

var $$void = include$1.$$void;

var voidRight = include$1.voidRight;

var voidLeft = include$1.voidLeft;

var flap = include$1.flap;

var BsApplyExtensions = include$2.BsApplyExtensions;

var applyFirst = include$2.applyFirst;

var applySecond = include$2.applySecond;

var map2 = include$2.map2;

var map3 = include$2.map3;

var map4 = include$2.map4;

var map5 = include$2.map5;

var tuple2 = include$2.tuple2;

var tuple3 = include$2.tuple3;

var tuple4 = include$2.tuple4;

var tuple5 = include$2.tuple5;

var mapTuple2 = include$2.mapTuple2;

var mapTuple3 = include$2.mapTuple3;

var mapTuple4 = include$2.mapTuple4;

var mapTuple5 = include$2.mapTuple5;

var BsApplicativeExtensions = include$3.BsApplicativeExtensions;

var liftA1 = include$3.liftA1;

var BsMonadExtensions = include$4.BsMonadExtensions;

var flatMap = include$4.flatMap;

var flatten = include$4.flatten;

var composeKleisli = include$4.composeKleisli;

var flipComposeKleisli = include$4.flipComposeKleisli;

var liftM1 = include$4.liftM1;

var when_ = include$4.when_;

var unless = include$4.unless;

var BsFoldableExtensions = include$5.BsFoldableExtensions;

var any = include$5.any;

var all = include$5.all;

var containsBy = include$5.containsBy;

var contains = include$5.contains;

var indexOfBy = include$5.indexOfBy;

var indexOf = include$5.indexOf;

var minBy = include$5.minBy;

var min = include$5.min;

var maxBy = include$5.maxBy;

var max = include$5.max;

var countBy = include$5.countBy;

var length = include$5.length;

var size = include$5.size;

var count = include$5.count;

var forEach = include$5.forEach;

var forEachWithIndex = include$5.forEachWithIndex;

var find = include$5.find;

var findWithIndex = include$5.findWithIndex;

var toList = include$5.toList;

var toArray = include$5.toArray;

var FoldableSemigroupExtensions = include$5.FoldableSemigroupExtensions;

var FoldableMonoidExtensions = include$5.FoldableMonoidExtensions;

var foldMap = include$5.foldMap;

var foldWithMonoid = include$5.foldWithMonoid;

var intercalate = include$5.intercalate;

var FoldableApplicativeExtensions = include$5.FoldableApplicativeExtensions;

var FoldableMonadExtensions = include$5.FoldableMonadExtensions;

var FoldableEqExtensions = include$5.FoldableEqExtensions;

var FoldableOrdExtensions = include$5.FoldableOrdExtensions;

var orElse = include$6.orElse;

var Traversable = Bastet__Option.Traversable;

var Ord = Bastet__Option.Ord;

exports.compose = compose;
exports.Semigroupoid = Semigroupoid;
exports.andThen = andThen;
exports.map = map;
exports.Functor = Functor;
exports.BsFunctorExtensions = BsFunctorExtensions;
exports.flipMap = flipMap;
exports.$$void = $$void;
exports.voidRight = voidRight;
exports.voidLeft = voidLeft;
exports.flap = flap;
exports.apply = apply;
exports.Apply = Apply;
exports.BsApplyExtensions = BsApplyExtensions;
exports.applyFirst = applyFirst;
exports.applySecond = applySecond;
exports.map2 = map2;
exports.map3 = map3;
exports.map4 = map4;
exports.map5 = map5;
exports.tuple2 = tuple2;
exports.tuple3 = tuple3;
exports.tuple4 = tuple4;
exports.tuple5 = tuple5;
exports.mapTuple2 = mapTuple2;
exports.mapTuple3 = mapTuple3;
exports.mapTuple4 = mapTuple4;
exports.mapTuple5 = mapTuple5;
exports.pure = pure;
exports.Applicative = Applicative;
exports.BsApplicativeExtensions = BsApplicativeExtensions;
exports.liftA1 = liftA1;
exports.bind = bind;
exports.Monad = Monad;
exports.BsMonadExtensions = BsMonadExtensions;
exports.flatMap = flatMap;
exports.flatten = flatten;
exports.composeKleisli = composeKleisli;
exports.flipComposeKleisli = flipComposeKleisli;
exports.liftM1 = liftM1;
exports.when_ = when_;
exports.unless = unless;
exports.align = align;
exports.alignWith = alignWith;
exports.Semialign = Semialign;
exports.Align = Align;
exports.foldLeft = foldLeft;
exports.foldRight = foldRight;
exports.BsFoldableExtensions = BsFoldableExtensions;
exports.any = any;
exports.all = all;
exports.containsBy = containsBy;
exports.contains = contains;
exports.indexOfBy = indexOfBy;
exports.indexOf = indexOf;
exports.minBy = minBy;
exports.min = min;
exports.maxBy = maxBy;
exports.max = max;
exports.countBy = countBy;
exports.length = length;
exports.size = size;
exports.count = count;
exports.forEach = forEach;
exports.forEachWithIndex = forEachWithIndex;
exports.find = find;
exports.findWithIndex = findWithIndex;
exports.toList = toList;
exports.toArray = toArray;
exports.FoldableSemigroupExtensions = FoldableSemigroupExtensions;
exports.FoldableMonoidExtensions = FoldableMonoidExtensions;
exports.foldMap = foldMap;
exports.foldWithMonoid = foldWithMonoid;
exports.intercalate = intercalate;
exports.FoldableApplicativeExtensions = FoldableApplicativeExtensions;
exports.FoldableMonadExtensions = FoldableMonadExtensions;
exports.FoldableEqExtensions = FoldableEqExtensions;
exports.FoldableOrdExtensions = FoldableOrdExtensions;
exports.alt = alt;
exports.altLazy = altLazy;
exports.Semigroup_Any = Semigroup_Any;
exports.Monoid_Any = Monoid_Any;
exports.orElse = orElse;
exports.Traversable = Traversable;
exports.eqBy = eqBy;
exports.eq = eq;
exports.Eq = Eq;
exports.Ord = Ord;
exports.showBy = showBy;
exports.show = show;
exports.WithSemigroup = WithSemigroup;
exports.WithApplicative = WithApplicative;
/* include Not a pure module */
