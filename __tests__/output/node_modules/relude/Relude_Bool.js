// Generated by Melange
'use strict';

var Curry = require("melange.runtime/curry.js");
var Relude__Relude_Extensions_Eq = require("./extensions/Relude_Extensions_Eq.js");
var Relude__Relude_Extensions_Ord = require("./extensions/Relude_Extensions_Ord.js");
var Relude__Relude_Extensions_Enum = require("./extensions/Relude_Extensions_Enum.js");
var Relude__Relude_Extensions_Monoid = require("./extensions/Relude_Extensions_Monoid.js");
var Relude__Relude_Extensions_Bounded = require("./extensions/Relude_Extensions_Bounded.js");
var Relude__Relude_Extensions_Semigroup = require("./extensions/Relude_Extensions_Semigroup.js");
var Relude__Relude_Extensions_BoundedEnum = require("./extensions/Relude_Extensions_BoundedEnum.js");

function ifElse(onTrue, onFalse, value) {
  if (value) {
    return Curry._1(onTrue, undefined);
  } else {
    return Curry._1(onFalse, undefined);
  }
}

function inverse(prim) {
  return !prim;
}

function and_(prim0, prim1) {
  if (prim0) {
    return prim1;
  } else {
    return false;
  }
}

function or_(prim0, prim1) {
  if (prim0) {
    return true;
  } else {
    return prim1;
  }
}

function nand(a, b) {
  return !(a && b);
}

function nor(a, b) {
  return !(a || b);
}

function xor(a, b) {
  if (!a && b) {
    return true;
  } else if (a) {
    return !b;
  } else {
    return false;
  }
}

function xnor(a, b) {
  return !xor(a, b);
}

function implies(a, b) {
  if (a) {
    return b;
  } else {
    return true;
  }
}

function eq(a, b) {
  if (a) {
    if (b) {
      return true;
    } else {
      return false;
    }
  } else if (b) {
    return false;
  } else {
    return true;
  }
}

var Eq = {
  eq: eq
};

function compare(a, b) {
  if (a) {
    if (b) {
      return "equal_to";
    } else {
      return "greater_than";
    }
  } else if (b) {
    return "less_than";
  } else {
    return "equal_to";
  }
}

var Ord = {
  eq: eq,
  compare: compare
};

function show(b) {
  if (b) {
    return "true";
  } else {
    return "false";
  }
}

var Show = {
  show: show
};

function append(prim0, prim1) {
  if (prim0) {
    return prim1;
  } else {
    return false;
  }
}

var Magma = {
  append: append
};

var include = Relude__Relude_Extensions_Semigroup.SemigroupExtensions(Magma);

var Monoid = {
  append: append,
  empty: true
};

var include$1 = Relude__Relude_Extensions_Monoid.MonoidExtensions(Monoid);

var Conjunctive_concatNamed = include.concatNamed;

var Conjunctive_BsMonoidExtensions = include$1.BsMonoidExtensions;

var Conjunctive_guard = include$1.guard;

var Conjunctive_power = include$1.power;

var Conjunctive = {
  Magma: Magma,
  MedialMagma: Magma,
  Semigroup: Magma,
  concatNamed: Conjunctive_concatNamed,
  Monoid: Monoid,
  BsMonoidExtensions: Conjunctive_BsMonoidExtensions,
  guard: Conjunctive_guard,
  power: Conjunctive_power
};

function append$1(prim0, prim1) {
  if (prim0) {
    return true;
  } else {
    return prim1;
  }
}

var Magma$1 = {
  append: append$1
};

var include$2 = Relude__Relude_Extensions_Semigroup.SemigroupExtensions(Magma$1);

var Monoid$1 = {
  append: append$1,
  empty: false
};

var include$3 = Relude__Relude_Extensions_Monoid.MonoidExtensions(Monoid$1);

var Disjunctive_concatNamed = include$2.concatNamed;

var Disjunctive_BsMonoidExtensions = include$3.BsMonoidExtensions;

var Disjunctive_guard = include$3.guard;

var Disjunctive_power = include$3.power;

var Disjunctive = {
  Magma: Magma$1,
  MedialMagma: Magma$1,
  Semigroup: Magma$1,
  concatNamed: Disjunctive_concatNamed,
  Monoid: Monoid$1,
  BsMonoidExtensions: Disjunctive_BsMonoidExtensions,
  guard: Disjunctive_guard,
  power: Disjunctive_power
};

var Bounded = {
  eq: eq,
  compare: compare,
  top: true,
  bottom: false
};

Relude__Relude_Extensions_Bounded.BoundedExtensions(Bounded);

function pred(param) {
  if (param) {
    return false;
  }
  
}

function succ(param) {
  if (param) {
    return ;
  } else {
    return true;
  }
}

var Enum = {
  eq: eq,
  compare: compare,
  succ: succ,
  pred: pred
};

Relude__Relude_Extensions_Enum.EnumExtensions(Enum);

function fromEnum(param) {
  if (param) {
    return 1;
  } else {
    return 0;
  }
}

function toEnum(param) {
  if (param !== 0) {
    if (param !== 1) {
      return ;
    } else {
      return true;
    }
  } else {
    return false;
  }
}

var BoundedEnum = {
  top: true,
  bottom: false,
  eq: eq,
  compare: compare,
  succ: succ,
  pred: pred,
  cardinality: 2,
  fromEnum: fromEnum,
  toEnum: toEnum
};

var include$4 = Relude__Relude_Extensions_BoundedEnum.BoundedEnumExtensions(BoundedEnum);

var include$5 = Relude__Relude_Extensions_Eq.EqInfix(Eq);

var include$6 = Relude__Relude_Extensions_Ord.OrdInfix(Ord);

var Infix_EqExtensions = include$5.EqExtensions;

var Infix_$pipe$eq$pipe = include$5.$pipe$eq$pipe;

var Infix_$pipe$bang$eq$pipe = include$5.$pipe$bang$eq$pipe;

var Infix_OrdExtensions = include$6.OrdExtensions;

var Infix_$pipe$less$pipe = include$6.$pipe$less$pipe;

var Infix_$pipe$less$eq$pipe = include$6.$pipe$less$eq$pipe;

var Infix_$pipe$great$pipe = include$6.$pipe$great$pipe;

var Infix_$pipe$great$eq$pipe = include$6.$pipe$great$eq$pipe;

var Infix = {
  EqExtensions: Infix_EqExtensions,
  $pipe$eq$pipe: Infix_$pipe$eq$pipe,
  $pipe$bang$eq$pipe: Infix_$pipe$bang$eq$pipe,
  OrdExtensions: Infix_OrdExtensions,
  $pipe$less$pipe: Infix_$pipe$less$pipe,
  $pipe$less$eq$pipe: Infix_$pipe$less$eq$pipe,
  $pipe$great$pipe: Infix_$pipe$great$pipe,
  $pipe$great$eq$pipe: Infix_$pipe$great$eq$pipe
};

var not__ = inverse;

var fromToAsList = include$4.fromToAsList;

var upFromAsList = include$4.upFromAsList;

var upFromIncludingAsList = include$4.upFromIncludingAsList;

var downFromAsList = include$4.downFromAsList;

var downFromIncludingAsList = include$4.downFromIncludingAsList;

var fromThenToAsList = include$4.fromThenToAsList;

var inverseMapEqBy = include$4.inverseMapEqBy;

var inverseMapEq = include$4.inverseMapEq;

var inverseMapOrdBy = include$4.inverseMapOrdBy;

var inverseMapOrd = include$4.inverseMapOrd;

var inverseMapString = include$4.inverseMapString;

exports.ifElse = ifElse;
exports.inverse = inverse;
exports.not__ = not__;
exports.and_ = and_;
exports.or_ = or_;
exports.nand = nand;
exports.nor = nor;
exports.xor = xor;
exports.xnor = xnor;
exports.implies = implies;
exports.eq = eq;
exports.Eq = Eq;
exports.compare = compare;
exports.Ord = Ord;
exports.show = show;
exports.Show = Show;
exports.Conjunctive = Conjunctive;
exports.Disjunctive = Disjunctive;
exports.Bounded = Bounded;
exports.Enum = Enum;
exports.BoundedEnum = BoundedEnum;
exports.fromToAsList = fromToAsList;
exports.upFromAsList = upFromAsList;
exports.upFromIncludingAsList = upFromIncludingAsList;
exports.downFromAsList = downFromAsList;
exports.downFromIncludingAsList = downFromIncludingAsList;
exports.fromThenToAsList = fromThenToAsList;
exports.inverseMapEqBy = inverseMapEqBy;
exports.inverseMapEq = inverseMapEq;
exports.inverseMapOrdBy = inverseMapOrdBy;
exports.inverseMapOrd = inverseMapOrd;
exports.inverseMapString = inverseMapString;
exports.Infix = Infix;
/* include Not a pure module */
