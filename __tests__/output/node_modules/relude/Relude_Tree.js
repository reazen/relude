// Generated by Melange
'use strict';

var Curry = require("melange.runtime/curry.js");
var Stdlib__List = require("melange/./list.js");
var Relude__Relude_List = require("./Relude_List.js");
var Relude__Relude_String = require("./Relude_String.js");
var Relude__Relude_NonEmpty = require("./Relude_NonEmpty.js");
var Relude__Relude_List_Instances = require("./list/Relude_List_Instances.js");
var Relude__Relude_Extensions_Apply = require("./extensions/Relude_Extensions_Apply.js");
var Relude__Relude_Extensions_Monad = require("./extensions/Relude_Extensions_Monad.js");
var Relude__Relude_Extensions_Extend = require("./extensions/Relude_Extensions_Extend.js");
var Relude__Relude_Extensions_Comonad = require("./extensions/Relude_Extensions_Comonad.js");
var Relude__Relude_Extensions_Functor = require("./extensions/Relude_Extensions_Functor.js");
var Relude__Relude_Extensions_Foldable = require("./extensions/Relude_Extensions_Foldable.js");
var Relude__Relude_List_Specializations = require("./list/Relude_List_Specializations.js");
var Relude__Relude_Extensions_Unfoldable = require("./extensions/Relude_Extensions_Unfoldable.js");
var Relude__Relude_Extensions_Applicative = require("./extensions/Relude_Extensions_Applicative.js");

function pure(a) {
  return {
          value: a,
          children: /* [] */0
        };
}

function isSingleton(param) {
  return Relude__Relude_List.isEmpty(param.children);
}

function make(value, children) {
  return {
          value: value,
          children: children
        };
}

function unmake(param) {
  return [
          param.value,
          param.children
        ];
}

function fill(getChildrenSeeds, seed) {
  return {
          value: seed,
          children: Relude__Relude_List.map(function (param) {
                  return fill(getChildrenSeeds, param);
                })(Curry._1(getChildrenSeeds, seed))
        };
}

function getValue(param) {
  return param.value;
}

function setValue(newValue, param) {
  return {
          value: newValue,
          children: param.children
        };
}

function modifyValue(f, param) {
  return {
          value: Curry._1(f, param.value),
          children: param.children
        };
}

function getChildren(param) {
  return param.children;
}

function getChildAt(index, param) {
  return Relude__Relude_List.at(index, param.children);
}

function setChildren(newChildren, param) {
  return {
          value: param.value,
          children: newChildren
        };
}

function modifyChildren(f, param) {
  return {
          value: param.value,
          children: Curry._1(f, param.children)
        };
}

function prependChild(child, param) {
  return {
          value: param.value,
          children: Relude__Relude_List.prepend(child, param.children)
        };
}

function appendChild(child, param) {
  return {
          value: param.value,
          children: Relude__Relude_List.append(child, param.children)
        };
}

function prependChildren(newChildren, param) {
  return {
          value: param.value,
          children: Relude__Relude_List.concat(newChildren, param.children)
        };
}

function appendChildren(newChildren, param) {
  return {
          value: param.value,
          children: Relude__Relude_List.concat(param.children, newChildren)
        };
}

function toNonEmptyList(param) {
  var flatten$p = function (param) {
    var children = param.children;
    var value = param.value;
    if (children) {
      return {
              hd: value,
              tl: Curry._2(Relude__Relude_List.flatMap, flatten$p, children)
            };
    } else {
      return {
              hd: value,
              tl: /* [] */0
            };
    }
  };
  return Relude__Relude_NonEmpty.List.make(param.value, Curry._2(Relude__Relude_List.flatMap, flatten$p, param.children));
}

function toNonEmptyArray(tree) {
  return Relude__Relude_NonEmpty.$$Array.fromNonEmptyList(toNonEmptyList(tree));
}

function zipWith(f, param, param$1) {
  return {
          value: Curry._2(f, param.value, param$1.value),
          children: Relude__Relude_List.zipWith((function (param, param$1) {
                  return zipWith(f, param, param$1);
                }), param.children, param$1.children)
        };
}

function zip(ta, tb) {
  return zipWith((function (a, b) {
                return [
                        a,
                        b
                      ];
              }), ta, tb);
}

function map(aToB, param) {
  return {
          value: Curry._1(aToB, param.value),
          children: Relude__Relude_List.map(function (param) {
                  return map(aToB, param);
                })(param.children)
        };
}

var Functor = {
  map: map
};

var include = Relude__Relude_Extensions_Functor.FunctorExtensions(Functor);

function apply(param, aTree) {
  var aToB = param.value;
  return {
          value: Curry._1(aToB, aTree.value),
          children: Relude__Relude_List.concat(Stdlib__List.map((function (aChildTree) {
                      return map(aToB, aChildTree);
                    }), aTree.children), Relude__Relude_List.map(function (aToBChildTree) {
                      return apply(aToBChildTree, aTree);
                    })(param.children))
        };
}

var Apply = {
  map: map,
  apply: apply
};

var include$1 = Relude__Relude_Extensions_Apply.ApplyExtensions(Apply);

var Applicative = {
  map: map,
  apply: apply,
  pure: pure
};

var include$2 = Relude__Relude_Extensions_Applicative.ApplicativeExtensions(Applicative);

function bind(param, aToTreeB) {
  var match = Curry._1(aToTreeB, param.value);
  var otherChildTreesB = Relude__Relude_List.map(function (childTreeA) {
          return bind(childTreeA, aToTreeB);
        })(param.children);
  return {
          value: match.value,
          children: Relude__Relude_List.concat(match.children, otherChildTreesB)
        };
}

var Monad = {
  map: map,
  apply: apply,
  pure: pure,
  flat_map: bind
};

var include$3 = Relude__Relude_Extensions_Monad.MonadExtensions(Monad);

function extend(treeAToB, treeA) {
  return {
          value: Curry._1(treeAToB, treeA),
          children: Relude__Relude_List.map(function (param) {
                  return extend(treeAToB, param);
                })(treeA.children)
        };
}

var Extend = {
  map: map,
  extend: extend
};

Relude__Relude_Extensions_Extend.ExtendExtensions(Extend);

var Comonad = {
  map: map,
  extend: extend,
  extract: getValue
};

Relude__Relude_Extensions_Comonad.ComonadExtensions(Comonad);

function foldLeft(f, init, param) {
  var acc = Relude__Relude_List.foldLeft((function (acc, child) {
            return foldLeft(f, acc, child);
          }), init)(param.children);
  return Curry._2(f, acc, param.value);
}

function foldRight(f, init, param) {
  var acc = Relude__Relude_List.foldRight((function (child, acc) {
            return foldRight(f, acc, child);
          }), init)(param.children);
  return Curry._2(f, param.value, acc);
}

function Fold_Map(M) {
  var fold_map = function (f, tree) {
    return foldLeft((function (acc, value) {
                  return Curry._2(M.append, acc, Curry._1(f, value));
                }), M.empty, tree);
  };
  return {
          fold_map: fold_map
        };
}

function Fold_Map_Any(M) {
  var fold_map = function (f, tree) {
    return foldLeft((function (acc, value) {
                  return Curry._2(M.append, acc, Curry._1(f, value));
                }), M.empty, tree);
  };
  return {
          fold_map: fold_map
        };
}

function Fold_Map_Plus(P) {
  var fold_map = function (f, tree) {
    return foldLeft((function (acc, value) {
                  return Curry._2(P.alt, acc, Curry._1(f, value));
                }), P.empty, tree);
  };
  return {
          fold_map: fold_map
        };
}

var Foldable = {
  fold_left: foldLeft,
  fold_right: foldRight,
  Fold_Map: Fold_Map,
  Fold_Map_Any: Fold_Map_Any,
  Fold_Map_Plus: Fold_Map_Plus
};

var include$4 = Relude__Relude_Extensions_Foldable.FoldableExtensions(Foldable);

function unfold(f, init) {
  var match = Curry._1(f, init);
  if (match !== undefined) {
    return {
            value: match[0],
            children: {
              hd: unfold(f, match[1]),
              tl: /* [] */0
            }
          };
  } else {
    return {
            value: init,
            children: /* [] */0
          };
  }
}

var Unfoldable = {
  unfold: unfold
};

Relude__Relude_Extensions_Unfoldable.UnfoldableExtensions(Unfoldable);

function WithApplicative(A) {
  var ListTraversable = Relude__Relude_List_Instances.Traversable(A);
  var traverse = function (f, param) {
    return Curry._2(A.apply, Curry._2(A.map, make, Curry._1(f, param.value)), Curry._2(ListTraversable.traverse, (function (param) {
                      return traverse(f, param);
                    }), param.children));
  };
  var sequence = function (tree) {
    return traverse((function (a) {
                  return a;
                }), tree);
  };
  var Traversable = {
    map: map,
    fold_left: foldLeft,
    fold_right: foldRight,
    Fold_Map: Fold_Map,
    Fold_Map_Any: Fold_Map_Any,
    Fold_Map_Plus: Fold_Map_Plus,
    traverse: traverse,
    sequence: sequence
  };
  return {
          Traversable: Traversable
        };
}

function filter(pred, param) {
  var value = param.value;
  if (Curry._1(pred, value)) {
    return {
            value: value,
            children: Relude__Relude_List.mapOption((function (param) {
                    return filter(pred, param);
                  }), param.children)
          };
  }
  
}

function showBy(showA, param) {
  return "Tree " + (Curry._1(showA, param.value) + (" " + Relude__Relude_List.showBy((function (param) {
                    return showBy(showA, param);
                  }), param.children)));
}

function Show(ShowA) {
  var show = function (tree) {
    return showBy(ShowA.show, tree);
  };
  return {
          show: show
        };
}

function showPrettyBy(showA, tree) {
  var showPrettyByWithIndent = function (level, showA, tree) {
    var indent = level > 0 ? Relude__Relude_String.repeat(level - 1 | 0, "   ") + "|- " : "";
    var partial_arg = level + 1 | 0;
    var childrenStr = Curry._2(Relude__Relude_List_Specializations.$$String.joinWith, "", Relude__Relude_List.map(function (param) {
                return showPrettyByWithIndent(partial_arg, showA, param);
              })(getChildren(tree)));
    return indent + (Curry._1(showA, getValue(tree)) + ("\n" + childrenStr));
  };
  return showPrettyByWithIndent(0, showA, tree);
}

function ShowPretty(ShowA) {
  var show = function (param) {
    return showPrettyBy(ShowA.show, param);
  };
  return {
          show: show
        };
}

function eqBy(eqA, param, param$1) {
  if (Curry._2(eqA, param.value, param$1.value)) {
    return Relude__Relude_List.eqBy((function (param, param$1) {
                  return eqBy(eqA, param, param$1);
                }), param.children, param$1.children);
  } else {
    return false;
  }
}

function Eq(EqA) {
  var eq = function (tree1, tree2) {
    return eqBy(EqA.eq, tree1, tree2);
  };
  return {
          eq: eq
        };
}

var singleton = pure;

var BsFunctorExtensions = include.BsFunctorExtensions;

var flipMap = include.flipMap;

var $$void = include.$$void;

var voidRight = include.voidRight;

var voidLeft = include.voidLeft;

var flap = include.flap;

var BsApplyExtensions = include$1.BsApplyExtensions;

var applyFirst = include$1.applyFirst;

var applySecond = include$1.applySecond;

var map2 = include$1.map2;

var map3 = include$1.map3;

var map4 = include$1.map4;

var map5 = include$1.map5;

var tuple2 = include$1.tuple2;

var tuple3 = include$1.tuple3;

var tuple4 = include$1.tuple4;

var tuple5 = include$1.tuple5;

var mapTuple2 = include$1.mapTuple2;

var mapTuple3 = include$1.mapTuple3;

var mapTuple4 = include$1.mapTuple4;

var mapTuple5 = include$1.mapTuple5;

var BsApplicativeExtensions = include$2.BsApplicativeExtensions;

var liftA1 = include$2.liftA1;

var BsMonadExtensions = include$3.BsMonadExtensions;

var flatMap = include$3.flatMap;

var flatten = include$3.flatten;

var composeKleisli = include$3.composeKleisli;

var flipComposeKleisli = include$3.flipComposeKleisli;

var liftM1 = include$3.liftM1;

var when_ = include$3.when_;

var unless = include$3.unless;

var BsFoldableExtensions = include$4.BsFoldableExtensions;

var any = include$4.any;

var all = include$4.all;

var containsBy = include$4.containsBy;

var contains = include$4.contains;

var indexOfBy = include$4.indexOfBy;

var indexOf = include$4.indexOf;

var minBy = include$4.minBy;

var min = include$4.min;

var maxBy = include$4.maxBy;

var max = include$4.max;

var countBy = include$4.countBy;

var length = include$4.length;

var size = include$4.size;

var count = include$4.count;

var forEach = include$4.forEach;

var forEachWithIndex = include$4.forEachWithIndex;

var find = include$4.find;

var findWithIndex = include$4.findWithIndex;

var toList = include$4.toList;

var toArray = include$4.toArray;

var FoldableSemigroupExtensions = include$4.FoldableSemigroupExtensions;

var FoldableMonoidExtensions = include$4.FoldableMonoidExtensions;

var foldMap = include$4.foldMap;

var foldWithMonoid = include$4.foldWithMonoid;

var intercalate = include$4.intercalate;

var FoldableApplicativeExtensions = include$4.FoldableApplicativeExtensions;

var FoldableMonadExtensions = include$4.FoldableMonadExtensions;

var FoldableEqExtensions = include$4.FoldableEqExtensions;

var FoldableOrdExtensions = include$4.FoldableOrdExtensions;

exports.pure = pure;
exports.singleton = singleton;
exports.isSingleton = isSingleton;
exports.make = make;
exports.unmake = unmake;
exports.fill = fill;
exports.getValue = getValue;
exports.setValue = setValue;
exports.modifyValue = modifyValue;
exports.getChildren = getChildren;
exports.getChildAt = getChildAt;
exports.setChildren = setChildren;
exports.modifyChildren = modifyChildren;
exports.prependChild = prependChild;
exports.appendChild = appendChild;
exports.prependChildren = prependChildren;
exports.appendChildren = appendChildren;
exports.toNonEmptyList = toNonEmptyList;
exports.toNonEmptyArray = toNonEmptyArray;
exports.zipWith = zipWith;
exports.zip = zip;
exports.map = map;
exports.Functor = Functor;
exports.BsFunctorExtensions = BsFunctorExtensions;
exports.flipMap = flipMap;
exports.$$void = $$void;
exports.voidRight = voidRight;
exports.voidLeft = voidLeft;
exports.flap = flap;
exports.apply = apply;
exports.Apply = Apply;
exports.BsApplyExtensions = BsApplyExtensions;
exports.applyFirst = applyFirst;
exports.applySecond = applySecond;
exports.map2 = map2;
exports.map3 = map3;
exports.map4 = map4;
exports.map5 = map5;
exports.tuple2 = tuple2;
exports.tuple3 = tuple3;
exports.tuple4 = tuple4;
exports.tuple5 = tuple5;
exports.mapTuple2 = mapTuple2;
exports.mapTuple3 = mapTuple3;
exports.mapTuple4 = mapTuple4;
exports.mapTuple5 = mapTuple5;
exports.Applicative = Applicative;
exports.BsApplicativeExtensions = BsApplicativeExtensions;
exports.liftA1 = liftA1;
exports.bind = bind;
exports.Monad = Monad;
exports.BsMonadExtensions = BsMonadExtensions;
exports.flatMap = flatMap;
exports.flatten = flatten;
exports.composeKleisli = composeKleisli;
exports.flipComposeKleisli = flipComposeKleisli;
exports.liftM1 = liftM1;
exports.when_ = when_;
exports.unless = unless;
exports.extend = extend;
exports.Extend = Extend;
exports.Comonad = Comonad;
exports.foldLeft = foldLeft;
exports.foldRight = foldRight;
exports.Foldable = Foldable;
exports.BsFoldableExtensions = BsFoldableExtensions;
exports.any = any;
exports.all = all;
exports.containsBy = containsBy;
exports.contains = contains;
exports.indexOfBy = indexOfBy;
exports.indexOf = indexOf;
exports.minBy = minBy;
exports.min = min;
exports.maxBy = maxBy;
exports.max = max;
exports.countBy = countBy;
exports.length = length;
exports.size = size;
exports.count = count;
exports.forEach = forEach;
exports.forEachWithIndex = forEachWithIndex;
exports.find = find;
exports.findWithIndex = findWithIndex;
exports.toList = toList;
exports.toArray = toArray;
exports.FoldableSemigroupExtensions = FoldableSemigroupExtensions;
exports.FoldableMonoidExtensions = FoldableMonoidExtensions;
exports.foldMap = foldMap;
exports.foldWithMonoid = foldWithMonoid;
exports.intercalate = intercalate;
exports.FoldableApplicativeExtensions = FoldableApplicativeExtensions;
exports.FoldableMonadExtensions = FoldableMonadExtensions;
exports.FoldableEqExtensions = FoldableEqExtensions;
exports.FoldableOrdExtensions = FoldableOrdExtensions;
exports.unfold = unfold;
exports.Unfoldable = Unfoldable;
exports.WithApplicative = WithApplicative;
exports.filter = filter;
exports.showBy = showBy;
exports.Show = Show;
exports.showPrettyBy = showPrettyBy;
exports.ShowPretty = ShowPretty;
exports.eqBy = eqBy;
exports.Eq = Eq;
/* include Not a pure module */
