// Generated by Melange
'use strict';

var Curry = require("melange.runtime/curry.js");
var Relude__Relude_Function = require("./Relude_Function.js");
var Relude__Relude_Identity = require("./Relude_Identity.js");
var Relude__Relude_Extensions_Apply = require("./extensions/Relude_Extensions_Apply.js");
var Relude__Relude_Extensions_Monad = require("./extensions/Relude_Extensions_Monad.js");
var Relude__Relude_Extensions_Functor = require("./extensions/Relude_Extensions_Functor.js");
var Relude__Relude_Extensions_Applicative = require("./extensions/Relude_Extensions_Applicative.js");

function WithMonad(M) {
  var runStateT = function (s, sToMAS) {
    return Curry._1(sToMAS._0, s);
  };
  var evalStateT = function (sToMAS, s) {
    return Curry._2(M.map, (function (prim) {
                  return prim[0];
                }), Curry._1(sToMAS._0, s));
  };
  var execStateT = function (sToMAS, s) {
    return Curry._2(M.map, (function (prim) {
                  return prim[1];
                }), Curry._1(sToMAS._0, s));
  };
  var mapStateT = function (mASToMBS, sToMAS) {
    var sToMAS$1 = sToMAS._0;
    return /* StateT */{
            _0: (function (param) {
                return Relude__Relude_Function.Infix.$less$less(mASToMBS, sToMAS$1, param);
              })
          };
  };
  var withStateT = function (sToS, sToMAS) {
    var sToMAS$1 = sToMAS._0;
    return /* StateT */{
            _0: (function (param) {
                return Relude__Relude_Function.Infix.$less$less(sToMAS$1, sToS, param);
              })
          };
  };
  var get = /* StateT */{
    _0: (function (s) {
        return Curry._1(M.pure, [
                    s,
                    s
                  ]);
      })
  };
  var gets = function (sToA) {
    return /* StateT */{
            _0: (function (s) {
                return Curry._1(M.pure, [
                            Curry._1(sToA, s),
                            s
                          ]);
              })
          };
  };
  var put = function (s) {
    return /* StateT */{
            _0: (function (param) {
                return Curry._1(M.pure, [
                            undefined,
                            s
                          ]);
              })
          };
  };
  var modify = function (sToS) {
    return /* StateT */{
            _0: (function (s) {
                var s$p = Curry._1(sToS, s);
                return Curry._1(M.pure, [
                            s$p,
                            s$p
                          ]);
              })
          };
  };
  var modify_ = function (sToS) {
    return /* StateT */{
            _0: (function (s) {
                return Curry._1(M.pure, [
                            undefined,
                            Curry._1(sToS, s)
                          ]);
              })
          };
  };
  var map = function (aToB, sToMAS) {
    var sToMAS$1 = sToMAS._0;
    return /* StateT */{
            _0: (function (s) {
                return Curry._2(M.map, (function (param) {
                              return [
                                      Curry._1(aToB, param[0]),
                                      param[1]
                                    ];
                            }), Curry._1(sToMAS$1, s));
              })
          };
  };
  var pure = function (a) {
    return /* StateT */{
            _0: (function (s) {
                return Curry._1(M.pure, [
                            a,
                            s
                          ]);
              })
          };
  };
  var apply = function (sToMAToBS, sToMAS) {
    var sToMAS$1 = sToMAS._0;
    var sToMAToBS$1 = sToMAToBS._0;
    return /* StateT */{
            _0: (function (s) {
                var mAToBS = Curry._1(sToMAToBS$1, s);
                var mAS = Curry._1(sToMAS$1, s);
                var f = function (param, param$1) {
                  return [
                          Curry._1(param[0], param$1[0]),
                          param$1[1]
                        ];
                };
                return Curry._2(M.apply, Curry._2(M.map, f, mAToBS), mAS);
              })
          };
  };
  var bind = function (sToMAS, aToStateTBS) {
    var sToMAS$1 = sToMAS._0;
    return /* StateT */{
            _0: (function (s) {
                var mAS = Curry._1(sToMAS$1, s);
                return Curry._2(M.flat_map, mAS, (function (param) {
                              var sToMBS = Curry._1(aToStateTBS, param[0]);
                              return Curry._1(sToMBS._0, param[1]);
                            }));
              })
          };
  };
  var WithState = function (S) {
    var Functor = {
      map: map
    };
    var include = Relude__Relude_Extensions_Functor.FunctorExtensions(Functor);
    var Apply = {
      map: map,
      apply: apply
    };
    var include$1 = Relude__Relude_Extensions_Apply.ApplyExtensions(Apply);
    var Applicative = {
      map: map,
      apply: apply,
      pure: pure
    };
    var include$2 = Relude__Relude_Extensions_Applicative.ApplicativeExtensions(Applicative);
    var Monad = {
      map: map,
      apply: apply,
      pure: pure,
      flat_map: bind
    };
    var include$3 = Relude__Relude_Extensions_Monad.MonadExtensions(Monad);
    var include$4 = Relude__Relude_Extensions_Functor.FunctorInfix(Functor);
    var include$5 = Relude__Relude_Extensions_Apply.ApplyInfix(Apply);
    var include$6 = Relude__Relude_Extensions_Monad.MonadInfix(Monad);
    var Infix_FunctorExtensions = include$4.FunctorExtensions;
    var Infix_$less$$great = include$4.$less$$great;
    var Infix_$less$$$great = include$4.$less$$$great;
    var Infix_$less$ = include$4.$less$;
    var Infix_$$great = include$4.$$great;
    var Infix_$less$at$great = include$4.$less$at$great;
    var Infix_ApplyExtensions = include$5.ApplyExtensions;
    var Infix_$less$star$great = include$5.$less$star$great;
    var Infix_$less$star = include$5.$less$star;
    var Infix_$star$great = include$5.$star$great;
    var Infix_MonadExtensions = include$6.MonadExtensions;
    var Infix_$great$great$eq = include$6.$great$great$eq;
    var Infix_$eq$less$less = include$6.$eq$less$less;
    var Infix_$great$eq$great = include$6.$great$eq$great;
    var Infix_$less$eq$less = include$6.$less$eq$less;
    var Infix = {
      FunctorExtensions: Infix_FunctorExtensions,
      $less$$great: Infix_$less$$great,
      $less$$$great: Infix_$less$$$great,
      $less$: Infix_$less$,
      $$great: Infix_$$great,
      $less$at$great: Infix_$less$at$great,
      ApplyExtensions: Infix_ApplyExtensions,
      $less$star$great: Infix_$less$star$great,
      $less$star: Infix_$less$star,
      $star$great: Infix_$star$great,
      MonadExtensions: Infix_MonadExtensions,
      $great$great$eq: Infix_$great$great$eq,
      $eq$less$less: Infix_$eq$less$less,
      $great$eq$great: Infix_$great$eq$great,
      $less$eq$less: Infix_$less$eq$less
    };
    return {
            runStateT: runStateT,
            evalStateT: evalStateT,
            execStateT: execStateT,
            mapStateT: mapStateT,
            withStateT: withStateT,
            get: get,
            gets: gets,
            put: put,
            modify: modify,
            modify_: modify_,
            Functor: Functor,
            map: map,
            BsFunctorExtensions: include.BsFunctorExtensions,
            flipMap: include.flipMap,
            $$void: include.$$void,
            voidRight: include.voidRight,
            voidLeft: include.voidLeft,
            flap: include.flap,
            Apply: Apply,
            apply: apply,
            BsApplyExtensions: include$1.BsApplyExtensions,
            applyFirst: include$1.applyFirst,
            applySecond: include$1.applySecond,
            map2: include$1.map2,
            map3: include$1.map3,
            map4: include$1.map4,
            map5: include$1.map5,
            tuple2: include$1.tuple2,
            tuple3: include$1.tuple3,
            tuple4: include$1.tuple4,
            tuple5: include$1.tuple5,
            mapTuple2: include$1.mapTuple2,
            mapTuple3: include$1.mapTuple3,
            mapTuple4: include$1.mapTuple4,
            mapTuple5: include$1.mapTuple5,
            Applicative: Applicative,
            pure: pure,
            BsApplicativeExtensions: include$2.BsApplicativeExtensions,
            liftA1: include$2.liftA1,
            all: include$2.all,
            Monad: Monad,
            bind: bind,
            BsMonadExtensions: include$3.BsMonadExtensions,
            flatMap: include$3.flatMap,
            flatten: include$3.flatten,
            composeKleisli: include$3.composeKleisli,
            flipComposeKleisli: include$3.flipComposeKleisli,
            liftM1: include$3.liftM1,
            when_: include$3.when_,
            unless: include$3.unless,
            Infix: Infix
          };
  };
  return {
          runStateT: runStateT,
          evalStateT: evalStateT,
          execStateT: execStateT,
          mapStateT: mapStateT,
          withStateT: withStateT,
          get: get,
          gets: gets,
          put: put,
          modify: modify,
          modify_: modify_,
          map: map,
          pure: pure,
          apply: apply,
          bind: bind,
          WithState: WithState
        };
}

function runStateT(s, sToMAS) {
  return Curry._1(sToMAS._0, s);
}

function evalStateT(sToMAS, s) {
  return Curry._2(Relude__Relude_Identity.Monad.map, (function (prim) {
                return prim[0];
              }), Curry._1(sToMAS._0, s));
}

function execStateT(sToMAS, s) {
  return Curry._2(Relude__Relude_Identity.Monad.map, (function (prim) {
                return prim[1];
              }), Curry._1(sToMAS._0, s));
}

function mapStateT(mASToMBS, sToMAS) {
  var sToMAS$1 = sToMAS._0;
  return /* StateT */{
          _0: (function (param) {
              return Relude__Relude_Function.Infix.$less$less(mASToMBS, sToMAS$1, param);
            })
        };
}

function withStateT(sToS, sToMAS) {
  var sToMAS$1 = sToMAS._0;
  return /* StateT */{
          _0: (function (param) {
              return Relude__Relude_Function.Infix.$less$less(sToMAS$1, sToS, param);
            })
        };
}

var get = /* StateT */{
  _0: (function (s) {
      return Curry._1(Relude__Relude_Identity.Monad.pure, [
                  s,
                  s
                ]);
    })
};

function gets(sToA) {
  return /* StateT */{
          _0: (function (s) {
              return Curry._1(Relude__Relude_Identity.Monad.pure, [
                          Curry._1(sToA, s),
                          s
                        ]);
            })
        };
}

function put(s) {
  return /* StateT */{
          _0: (function (param) {
              return Curry._1(Relude__Relude_Identity.Monad.pure, [
                          undefined,
                          s
                        ]);
            })
        };
}

function modify(sToS) {
  return /* StateT */{
          _0: (function (s) {
              var s$p = Curry._1(sToS, s);
              return Curry._1(Relude__Relude_Identity.Monad.pure, [
                          s$p,
                          s$p
                        ]);
            })
        };
}

function modify_(sToS) {
  return /* StateT */{
          _0: (function (s) {
              return Curry._1(Relude__Relude_Identity.Monad.pure, [
                          undefined,
                          Curry._1(sToS, s)
                        ]);
            })
        };
}

function map(aToB, sToMAS) {
  var sToMAS$1 = sToMAS._0;
  return /* StateT */{
          _0: (function (s) {
              return Curry._2(Relude__Relude_Identity.Monad.map, (function (param) {
                            return [
                                    Curry._1(aToB, param[0]),
                                    param[1]
                                  ];
                          }), Curry._1(sToMAS$1, s));
            })
        };
}

function pure(a) {
  return /* StateT */{
          _0: (function (s) {
              return Curry._1(Relude__Relude_Identity.Monad.pure, [
                          a,
                          s
                        ]);
            })
        };
}

function apply(sToMAToBS, sToMAS) {
  var sToMAS$1 = sToMAS._0;
  var sToMAToBS$1 = sToMAToBS._0;
  return /* StateT */{
          _0: (function (s) {
              var mAToBS = Curry._1(sToMAToBS$1, s);
              var mAS = Curry._1(sToMAS$1, s);
              var f = function (param, param$1) {
                return [
                        Curry._1(param[0], param$1[0]),
                        param$1[1]
                      ];
              };
              return Curry._2(Relude__Relude_Identity.Monad.apply, Curry._2(Relude__Relude_Identity.Monad.map, f, mAToBS), mAS);
            })
        };
}

function bind(sToMAS, aToStateTBS) {
  var sToMAS$1 = sToMAS._0;
  return /* StateT */{
          _0: (function (s) {
              var mAS = Curry._1(sToMAS$1, s);
              return Curry._2(Relude__Relude_Identity.Monad.flat_map, mAS, (function (param) {
                            var sToMBS = Curry._1(aToStateTBS, param[0]);
                            return Curry._1(sToMBS._0, param[1]);
                          }));
            })
        };
}

function WithState(S) {
  var Functor = {
    map: map
  };
  var include = Relude__Relude_Extensions_Functor.FunctorExtensions(Functor);
  var Apply = {
    map: map,
    apply: apply
  };
  var include$1 = Relude__Relude_Extensions_Apply.ApplyExtensions(Apply);
  var Applicative = {
    map: map,
    apply: apply,
    pure: pure
  };
  var include$2 = Relude__Relude_Extensions_Applicative.ApplicativeExtensions(Applicative);
  var Monad = {
    map: map,
    apply: apply,
    pure: pure,
    flat_map: bind
  };
  var include$3 = Relude__Relude_Extensions_Monad.MonadExtensions(Monad);
  var include$4 = Relude__Relude_Extensions_Functor.FunctorInfix(Functor);
  var include$5 = Relude__Relude_Extensions_Apply.ApplyInfix(Apply);
  var include$6 = Relude__Relude_Extensions_Monad.MonadInfix(Monad);
  var Infix_FunctorExtensions = include$4.FunctorExtensions;
  var Infix_$less$$great = include$4.$less$$great;
  var Infix_$less$$$great = include$4.$less$$$great;
  var Infix_$less$ = include$4.$less$;
  var Infix_$$great = include$4.$$great;
  var Infix_$less$at$great = include$4.$less$at$great;
  var Infix_ApplyExtensions = include$5.ApplyExtensions;
  var Infix_$less$star$great = include$5.$less$star$great;
  var Infix_$less$star = include$5.$less$star;
  var Infix_$star$great = include$5.$star$great;
  var Infix_MonadExtensions = include$6.MonadExtensions;
  var Infix_$great$great$eq = include$6.$great$great$eq;
  var Infix_$eq$less$less = include$6.$eq$less$less;
  var Infix_$great$eq$great = include$6.$great$eq$great;
  var Infix_$less$eq$less = include$6.$less$eq$less;
  var Infix = {
    FunctorExtensions: Infix_FunctorExtensions,
    $less$$great: Infix_$less$$great,
    $less$$$great: Infix_$less$$$great,
    $less$: Infix_$less$,
    $$great: Infix_$$great,
    $less$at$great: Infix_$less$at$great,
    ApplyExtensions: Infix_ApplyExtensions,
    $less$star$great: Infix_$less$star$great,
    $less$star: Infix_$less$star,
    $star$great: Infix_$star$great,
    MonadExtensions: Infix_MonadExtensions,
    $great$great$eq: Infix_$great$great$eq,
    $eq$less$less: Infix_$eq$less$less,
    $great$eq$great: Infix_$great$eq$great,
    $less$eq$less: Infix_$less$eq$less
  };
  return {
          runStateT: runStateT,
          evalStateT: evalStateT,
          execStateT: execStateT,
          mapStateT: mapStateT,
          withStateT: withStateT,
          get: get,
          gets: gets,
          put: put,
          modify: modify,
          modify_: modify_,
          Functor: Functor,
          map: map,
          BsFunctorExtensions: include.BsFunctorExtensions,
          flipMap: include.flipMap,
          $$void: include.$$void,
          voidRight: include.voidRight,
          voidLeft: include.voidLeft,
          flap: include.flap,
          Apply: Apply,
          apply: apply,
          BsApplyExtensions: include$1.BsApplyExtensions,
          applyFirst: include$1.applyFirst,
          applySecond: include$1.applySecond,
          map2: include$1.map2,
          map3: include$1.map3,
          map4: include$1.map4,
          map5: include$1.map5,
          tuple2: include$1.tuple2,
          tuple3: include$1.tuple3,
          tuple4: include$1.tuple4,
          tuple5: include$1.tuple5,
          mapTuple2: include$1.mapTuple2,
          mapTuple3: include$1.mapTuple3,
          mapTuple4: include$1.mapTuple4,
          mapTuple5: include$1.mapTuple5,
          Applicative: Applicative,
          pure: pure,
          BsApplicativeExtensions: include$2.BsApplicativeExtensions,
          liftA1: include$2.liftA1,
          all: include$2.all,
          Monad: Monad,
          bind: bind,
          BsMonadExtensions: include$3.BsMonadExtensions,
          flatMap: include$3.flatMap,
          flatten: include$3.flatten,
          composeKleisli: include$3.composeKleisli,
          flipComposeKleisli: include$3.flipComposeKleisli,
          liftM1: include$3.liftM1,
          when_: include$3.when_,
          unless: include$3.unless,
          Infix: Infix
        };
}

var State = {
  runStateT: runStateT,
  evalStateT: evalStateT,
  execStateT: execStateT,
  mapStateT: mapStateT,
  withStateT: withStateT,
  get: get,
  gets: gets,
  put: put,
  modify: modify,
  modify_: modify_,
  map: map,
  pure: pure,
  apply: apply,
  bind: bind,
  WithState: WithState
};

exports.WithMonad = WithMonad;
exports.State = State;
/* Relude__Relude_Function Not a pure module */
