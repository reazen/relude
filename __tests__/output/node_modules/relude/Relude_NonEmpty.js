// Generated by Melange
'use strict';

var Curry = require("melange.runtime/curry.js");
var Belt_List = require("melange.belt/./belt_List.js");
var Belt_Option = require("melange.belt/./belt_Option.js");
var Relude__Relude_Sequence = require("./Relude_Sequence.js");
var Relude__Relude_Array_Base = require("./array/Relude_Array_Base.js");
var Relude__Relude_Option_Base = require("./option/Relude_Option_Base.js");
var Relude__Relude_Extensions_Apply = require("./extensions/Relude_Extensions_Apply.js");
var Relude__Relude_Extensions_Monad = require("./extensions/Relude_Extensions_Monad.js");
var Relude__Relude_Option_Instances = require("./option/Relude_Option_Instances.js");
var Relude__Relude_Extensions_Functor = require("./extensions/Relude_Extensions_Functor.js");
var Relude__Relude_Extensions_Foldable = require("./extensions/Relude_Extensions_Foldable.js");
var Relude__Relude_Extensions_Applicative = require("./extensions/Relude_Extensions_Applicative.js");
var Relude__Relude_Extensions_Traversable = require("./extensions/Relude_Extensions_Traversable.js");
var Relude__Relude_Extensions_SemigroupAny = require("./extensions/Relude_Extensions_SemigroupAny.js");

function WithSequence(TailSequence) {
  var one = function (head) {
    return /* NonEmpty */{
            _0: head,
            _1: Curry._1(TailSequence.emptyLazy, undefined)
          };
  };
  var make = function (head, tailSequence) {
    return /* NonEmpty */{
            _0: head,
            _1: tailSequence
          };
  };
  var fromSequence = function (sequence) {
    return Belt_Option.map(Curry._1(TailSequence.head, sequence), (function (head) {
                  return /* NonEmpty */{
                          _0: head,
                          _1: Curry._1(TailSequence.tailOrEmpty, sequence)
                        };
                }));
  };
  var toSequence = function (param) {
    return Curry._2(TailSequence.concat, Curry._1(TailSequence.Monad.pure, param._0), param._1);
  };
  var fromList = function (list) {
    if (list) {
      return /* NonEmpty */{
              _0: list.hd,
              _1: Curry._1(TailSequence.fromList, list.tl)
            };
    }
    
  };
  var fromArray = function (array) {
    return Relude__Relude_Option_Instances.map((function (param) {
                  return /* NonEmpty */{
                          _0: param[0],
                          _1: Curry._1(TailSequence.fromArray, param[1])
                        };
                }), Relude__Relude_Array_Base.uncons(array));
  };
  var cons = function (head, tailNonEmpty) {
    return /* NonEmpty */{
            _0: head,
            _1: toSequence(tailNonEmpty)
          };
  };
  var uncons = function (param) {
    return [
            param._0,
            param._1
          ];
  };
  var head = function (param) {
    return param._0;
  };
  var tail = function (param) {
    return param._1;
  };
  var concat = function (nonEmpty1, nonEmpty2) {
    return /* NonEmpty */{
            _0: head(nonEmpty1),
            _1: Curry._2(TailSequence.concat, tail(nonEmpty1), toSequence(nonEmpty2))
          };
  };
  var SemigroupAny = {
    append: concat
  };
  var include = Relude__Relude_Extensions_SemigroupAny.SemigroupAnyExtensions(SemigroupAny);
  var MagmaAny = {
    append: concat
  };
  var reduceLeft = function (f, param) {
    return Curry._3(TailSequence.Foldable.fold_left, f, param._0, param._1);
  };
  var foldLeft = function (f, init, param) {
    return Curry._3(TailSequence.Foldable.fold_left, f, Curry._2(f, init, param._0), param._1);
  };
  var foldRight = function (f, init, param) {
    return Curry._2(f, param._0, Curry._3(TailSequence.Foldable.fold_right, f, init, param._1));
  };
  var Foldable_Fold_Map = function (funarg) {
    var TailFoldMap = Curry._1(TailSequence.Foldable.Fold_Map, funarg);
    var fold_map = function (f, param) {
      return Curry._2(funarg.append, Curry._1(f, param._0), Curry._2(TailFoldMap.fold_map, f, param._1));
    };
    return {
            fold_map: fold_map
          };
  };
  var Foldable_Fold_Map_Any = function (funarg) {
    var SequenceFoldMapAny = Curry._1(TailSequence.Foldable.Fold_Map_Any, funarg);
    var fold_map = function (f, param) {
      return Curry._2(funarg.append, Curry._1(f, param._0), Curry._2(SequenceFoldMapAny.fold_map, f, param._1));
    };
    return {
            fold_map: fold_map
          };
  };
  var Foldable_Fold_Map_Plus = function (funarg) {
    var TailFoldMapPlus = Curry._1(TailSequence.Foldable.Fold_Map_Plus, funarg);
    var fold_map = function (f, param) {
      return Curry._2(funarg.alt, Curry._1(f, param._0), Curry._2(TailFoldMapPlus.fold_map, f, param._1));
    };
    return {
            fold_map: fold_map
          };
  };
  var Foldable = {
    fold_left: foldLeft,
    fold_right: foldRight,
    Fold_Map: Foldable_Fold_Map,
    Fold_Map_Any: Foldable_Fold_Map_Any,
    Fold_Map_Plus: Foldable_Fold_Map_Plus
  };
  var include$1 = Relude__Relude_Extensions_Foldable.FoldableExtensions(Foldable);
  var map = function (f, param) {
    return /* NonEmpty */{
            _0: Curry._1(f, param._0),
            _1: Curry._2(TailSequence.Monad.map, f, param._1)
          };
  };
  var Functor = {
    map: map
  };
  var include$2 = Relude__Relude_Extensions_Functor.FunctorExtensions(Functor);
  var apply = function (ff, fa) {
    return reduceLeft(concat, map((function (f) {
                      return map(f, fa);
                    }), ff));
  };
  var Apply = {
    map: map,
    apply: apply
  };
  var include$3 = Relude__Relude_Extensions_Apply.ApplyExtensions(Apply);
  var Applicative = {
    map: map,
    apply: apply,
    pure: one
  };
  var include$4 = Relude__Relude_Extensions_Applicative.ApplicativeExtensions(Applicative);
  var bind = function (nonEmpty, f) {
    return reduceLeft(concat, map(f, nonEmpty));
  };
  var Monad = {
    map: map,
    apply: apply,
    pure: one,
    flat_map: bind
  };
  var include$5 = Relude__Relude_Extensions_Monad.MonadExtensions(Monad);
  var mkString = function (delim, xs) {
    return xs._0 + (delim + Curry._2(TailSequence.mkString, delim, xs._1));
  };
  var reverse = function (param) {
    var head = param._0;
    return Relude__Relude_Option_Base.getOrElseLazy((function (param) {
                  return /* NonEmpty */{
                          _0: head,
                          _1: Curry._1(TailSequence.emptyLazy, undefined)
                        };
                }), Relude__Relude_Option_Instances.map((function (param) {
                      return /* NonEmpty */{
                              _0: param[0],
                              _1: Curry._2(TailSequence.append, head, param[1])
                            };
                    }), Curry._1(TailSequence.uncons, Curry._1(TailSequence.reverse, param._1))));
  };
  var eqBy = function (eqA, xs, ys) {
    if (Curry._2(eqA, xs._0, ys._0)) {
      return Curry._3(TailSequence.eqBy, eqA, xs._1, ys._1);
    } else {
      return false;
    }
  };
  var eq = function (eqA, xs, ys) {
    return eqBy(eqA.eq, xs, ys);
  };
  var Eq = function (EqA) {
    var eq = function (xs, ys) {
      return eqBy(EqA.eq, xs, ys);
    };
    return {
            eq: eq
          };
  };
  var showBy = function (showX, xs) {
    var strings = map(showX, xs);
    return "[!" + (mkString(", ", strings) + "!]");
  };
  var show = function (showA, xs) {
    return showBy(showA.show, xs);
  };
  var Show = function (S) {
    var show = function (param) {
      return showBy(S.show, param);
    };
    return {
            show: show
          };
  };
  var WithApplicative = function (A) {
    var TailTraversable = Curry._1(TailSequence.Traversable, A);
    var traverse = function (f, param) {
      return Curry._2(A.apply, Curry._2(A.map, make, Curry._1(f, param._0)), Curry._2(TailTraversable.traverse, f, param._1));
    };
    var sequence = function (fa) {
      return traverse((function (x) {
                    return x;
                  }), fa);
    };
    var Traversable_Fold_Map = Foldable_Fold_Map;
    var Traversable_Fold_Map_Any = Foldable_Fold_Map_Any;
    var Traversable_Fold_Map_Plus = Foldable_Fold_Map_Plus;
    var Traversable = {
      map: map,
      fold_left: foldLeft,
      fold_right: foldRight,
      Fold_Map: Traversable_Fold_Map,
      Fold_Map_Any: Traversable_Fold_Map_Any,
      Fold_Map_Plus: Traversable_Fold_Map_Plus,
      traverse: traverse,
      sequence: sequence
    };
    Relude__Relude_Extensions_Traversable.TraversableExtensions(Traversable);
    return {
            Traversable: Traversable,
            traverse: traverse,
            sequence: sequence
          };
  };
  return {
          one: one,
          make: make,
          fromSequence: fromSequence,
          toSequence: toSequence,
          fromList: fromList,
          fromArray: fromArray,
          cons: cons,
          uncons: uncons,
          head: head,
          tail: tail,
          concat: concat,
          SemigroupAny: SemigroupAny,
          concatNamed: include.concatNamed,
          MagmaAny: MagmaAny,
          reduceLeft: reduceLeft,
          foldLeft: foldLeft,
          foldRight: foldRight,
          Foldable: Foldable,
          BsFoldableExtensions: include$1.BsFoldableExtensions,
          any: include$1.any,
          containsBy: include$1.containsBy,
          contains: include$1.contains,
          indexOfBy: include$1.indexOfBy,
          indexOf: include$1.indexOf,
          minBy: include$1.minBy,
          min: include$1.min,
          maxBy: include$1.maxBy,
          max: include$1.max,
          countBy: include$1.countBy,
          length: include$1.length,
          size: include$1.size,
          count: include$1.count,
          forEach: include$1.forEach,
          forEachWithIndex: include$1.forEachWithIndex,
          find: include$1.find,
          findWithIndex: include$1.findWithIndex,
          toList: include$1.toList,
          toArray: include$1.toArray,
          FoldableSemigroupExtensions: include$1.FoldableSemigroupExtensions,
          FoldableMonoidExtensions: include$1.FoldableMonoidExtensions,
          foldMap: include$1.foldMap,
          foldWithMonoid: include$1.foldWithMonoid,
          intercalate: include$1.intercalate,
          FoldableApplicativeExtensions: include$1.FoldableApplicativeExtensions,
          FoldableMonadExtensions: include$1.FoldableMonadExtensions,
          FoldableEqExtensions: include$1.FoldableEqExtensions,
          FoldableOrdExtensions: include$1.FoldableOrdExtensions,
          map: map,
          Functor: Functor,
          BsFunctorExtensions: include$2.BsFunctorExtensions,
          flipMap: include$2.flipMap,
          $$void: include$2.$$void,
          voidRight: include$2.voidRight,
          voidLeft: include$2.voidLeft,
          flap: include$2.flap,
          apply: apply,
          Apply: Apply,
          BsApplyExtensions: include$3.BsApplyExtensions,
          applyFirst: include$3.applyFirst,
          applySecond: include$3.applySecond,
          map2: include$3.map2,
          map3: include$3.map3,
          map4: include$3.map4,
          map5: include$3.map5,
          tuple2: include$3.tuple2,
          tuple3: include$3.tuple3,
          tuple4: include$3.tuple4,
          tuple5: include$3.tuple5,
          mapTuple2: include$3.mapTuple2,
          mapTuple3: include$3.mapTuple3,
          mapTuple4: include$3.mapTuple4,
          mapTuple5: include$3.mapTuple5,
          pure: one,
          Applicative: Applicative,
          BsApplicativeExtensions: include$4.BsApplicativeExtensions,
          liftA1: include$4.liftA1,
          all: include$4.all,
          bind: bind,
          Monad: Monad,
          BsMonadExtensions: include$5.BsMonadExtensions,
          flatMap: include$5.flatMap,
          flatten: include$5.flatten,
          composeKleisli: include$5.composeKleisli,
          flipComposeKleisli: include$5.flipComposeKleisli,
          liftM1: include$5.liftM1,
          when_: include$5.when_,
          unless: include$5.unless,
          mkString: mkString,
          reverse: reverse,
          eqBy: eqBy,
          eq: eq,
          Eq: Eq,
          showBy: showBy,
          show: show,
          Show: Show,
          WithApplicative: WithApplicative
        };
}

function one(head) {
  return /* NonEmpty */{
          _0: head,
          _1: Curry._1(Relude__Relude_Sequence.List.emptyLazy, undefined)
        };
}

function make(head, tailSequence) {
  return /* NonEmpty */{
          _0: head,
          _1: tailSequence
        };
}

function fromSequence(sequence) {
  return Belt_Option.map(Curry._1(Relude__Relude_Sequence.List.head, sequence), (function (head) {
                return /* NonEmpty */{
                        _0: head,
                        _1: Curry._1(Relude__Relude_Sequence.List.tailOrEmpty, sequence)
                      };
              }));
}

function toSequence(param) {
  return Curry._2(Relude__Relude_Sequence.List.concat, Curry._1(Relude__Relude_Sequence.List.Monad.pure, param._0), param._1);
}

function fromList(list) {
  if (list) {
    return /* NonEmpty */{
            _0: list.hd,
            _1: Curry._1(Relude__Relude_Sequence.List.fromList, list.tl)
          };
  }
  
}

function fromArray(array) {
  return Relude__Relude_Option_Instances.map((function (param) {
                return /* NonEmpty */{
                        _0: param[0],
                        _1: Curry._1(Relude__Relude_Sequence.List.fromArray, param[1])
                      };
              }), Relude__Relude_Array_Base.uncons(array));
}

function cons(head, tailNonEmpty) {
  return /* NonEmpty */{
          _0: head,
          _1: toSequence(tailNonEmpty)
        };
}

function uncons(param) {
  return [
          param._0,
          param._1
        ];
}

function head(param) {
  return param._0;
}

function tail(param) {
  return param._1;
}

function concat(nonEmpty1, nonEmpty2) {
  return /* NonEmpty */{
          _0: head(nonEmpty1),
          _1: Curry._2(Relude__Relude_Sequence.List.concat, tail(nonEmpty1), toSequence(nonEmpty2))
        };
}

var SemigroupAny = {
  append: concat
};

var include = Relude__Relude_Extensions_SemigroupAny.SemigroupAnyExtensions(SemigroupAny);

var MagmaAny = {
  append: concat
};

function reduceLeft(f, param) {
  return Curry._3(Relude__Relude_Sequence.List.Foldable.fold_left, f, param._0, param._1);
}

function foldLeft(f, init, param) {
  return Curry._3(Relude__Relude_Sequence.List.Foldable.fold_left, f, Curry._2(f, init, param._0), param._1);
}

function foldRight(f, init, param) {
  return Curry._2(f, param._0, Curry._3(Relude__Relude_Sequence.List.Foldable.fold_right, f, init, param._1));
}

function Foldable_Fold_Map(funarg) {
  var TailFoldMap = Curry._1(Relude__Relude_Sequence.List.Foldable.Fold_Map, funarg);
  var fold_map = function (f, param) {
    return Curry._2(funarg.append, Curry._1(f, param._0), Curry._2(TailFoldMap.fold_map, f, param._1));
  };
  return {
          fold_map: fold_map
        };
}

function Foldable_Fold_Map_Any(funarg) {
  var SequenceFoldMapAny = Curry._1(Relude__Relude_Sequence.List.Foldable.Fold_Map_Any, funarg);
  var fold_map = function (f, param) {
    return Curry._2(funarg.append, Curry._1(f, param._0), Curry._2(SequenceFoldMapAny.fold_map, f, param._1));
  };
  return {
          fold_map: fold_map
        };
}

function Foldable_Fold_Map_Plus(funarg) {
  var TailFoldMapPlus = Curry._1(Relude__Relude_Sequence.List.Foldable.Fold_Map_Plus, funarg);
  var fold_map = function (f, param) {
    return Curry._2(funarg.alt, Curry._1(f, param._0), Curry._2(TailFoldMapPlus.fold_map, f, param._1));
  };
  return {
          fold_map: fold_map
        };
}

var Foldable = {
  fold_left: foldLeft,
  fold_right: foldRight,
  Fold_Map: Foldable_Fold_Map,
  Fold_Map_Any: Foldable_Fold_Map_Any,
  Fold_Map_Plus: Foldable_Fold_Map_Plus
};

var include$1 = Relude__Relude_Extensions_Foldable.FoldableExtensions(Foldable);

function map(f, param) {
  return /* NonEmpty */{
          _0: Curry._1(f, param._0),
          _1: Curry._2(Relude__Relude_Sequence.List.Monad.map, f, param._1)
        };
}

var Functor = {
  map: map
};

var include$2 = Relude__Relude_Extensions_Functor.FunctorExtensions(Functor);

function apply(ff, fa) {
  return reduceLeft(concat, map((function (f) {
                    return map(f, fa);
                  }), ff));
}

var Apply = {
  map: map,
  apply: apply
};

var include$3 = Relude__Relude_Extensions_Apply.ApplyExtensions(Apply);

var Applicative = {
  map: map,
  apply: apply,
  pure: one
};

var include$4 = Relude__Relude_Extensions_Applicative.ApplicativeExtensions(Applicative);

function bind(nonEmpty, f) {
  return reduceLeft(concat, map(f, nonEmpty));
}

var Monad = {
  map: map,
  apply: apply,
  pure: one,
  flat_map: bind
};

var include$5 = Relude__Relude_Extensions_Monad.MonadExtensions(Monad);

function mkString(delim, xs) {
  return xs._0 + (delim + Curry._2(Relude__Relude_Sequence.List.mkString, delim, xs._1));
}

function reverse(param) {
  var head = param._0;
  return Relude__Relude_Option_Base.getOrElseLazy((function (param) {
                return /* NonEmpty */{
                        _0: head,
                        _1: Curry._1(Relude__Relude_Sequence.List.emptyLazy, undefined)
                      };
              }), Relude__Relude_Option_Instances.map((function (param) {
                    return /* NonEmpty */{
                            _0: param[0],
                            _1: Curry._2(Relude__Relude_Sequence.List.append, head, param[1])
                          };
                  }), Curry._1(Relude__Relude_Sequence.List.uncons, Curry._1(Relude__Relude_Sequence.List.reverse, param._1))));
}

function eqBy(eqA, xs, ys) {
  if (Curry._2(eqA, xs._0, ys._0)) {
    return Curry._3(Relude__Relude_Sequence.List.eqBy, eqA, xs._1, ys._1);
  } else {
    return false;
  }
}

function eq(eqA, xs, ys) {
  return eqBy(eqA.eq, xs, ys);
}

function Eq(EqA) {
  var eq = function (xs, ys) {
    return eqBy(EqA.eq, xs, ys);
  };
  return {
          eq: eq
        };
}

function showBy(showX, xs) {
  var strings = map(showX, xs);
  return "[!" + (mkString(", ", strings) + "!]");
}

function show(showA, xs) {
  return showBy(showA.show, xs);
}

function Show(S) {
  var show = function (param) {
    return showBy(S.show, param);
  };
  return {
          show: show
        };
}

function WithApplicative(A) {
  var TailTraversable = Curry._1(Relude__Relude_Sequence.List.Traversable, A);
  var traverse = function (f, param) {
    return Curry._2(A.apply, Curry._2(A.map, make, Curry._1(f, param._0)), Curry._2(TailTraversable.traverse, f, param._1));
  };
  var sequence = function (fa) {
    return traverse((function (x) {
                  return x;
                }), fa);
  };
  var Traversable_Fold_Map = Foldable_Fold_Map;
  var Traversable_Fold_Map_Any = Foldable_Fold_Map_Any;
  var Traversable_Fold_Map_Plus = Foldable_Fold_Map_Plus;
  var Traversable = {
    map: map,
    fold_left: foldLeft,
    fold_right: foldRight,
    Fold_Map: Traversable_Fold_Map,
    Fold_Map_Any: Traversable_Fold_Map_Any,
    Fold_Map_Plus: Traversable_Fold_Map_Plus,
    traverse: traverse,
    sequence: sequence
  };
  Relude__Relude_Extensions_Traversable.TraversableExtensions(Traversable);
  return {
          Traversable: Traversable,
          traverse: traverse,
          sequence: sequence
        };
}

var List_concatNamed = include.concatNamed;

var List_BsFoldableExtensions = include$1.BsFoldableExtensions;

var List_any = include$1.any;

var List_containsBy = include$1.containsBy;

var List_contains = include$1.contains;

var List_indexOfBy = include$1.indexOfBy;

var List_indexOf = include$1.indexOf;

var List_minBy = include$1.minBy;

var List_min = include$1.min;

var List_maxBy = include$1.maxBy;

var List_max = include$1.max;

var List_countBy = include$1.countBy;

var List_length = include$1.length;

var List_size = include$1.size;

var List_count = include$1.count;

var List_forEach = include$1.forEach;

var List_forEachWithIndex = include$1.forEachWithIndex;

var List_find = include$1.find;

var List_findWithIndex = include$1.findWithIndex;

var List_toList = include$1.toList;

var List_toArray = include$1.toArray;

var List_FoldableSemigroupExtensions = include$1.FoldableSemigroupExtensions;

var List_FoldableMonoidExtensions = include$1.FoldableMonoidExtensions;

var List_foldMap = include$1.foldMap;

var List_foldWithMonoid = include$1.foldWithMonoid;

var List_intercalate = include$1.intercalate;

var List_FoldableApplicativeExtensions = include$1.FoldableApplicativeExtensions;

var List_FoldableMonadExtensions = include$1.FoldableMonadExtensions;

var List_FoldableEqExtensions = include$1.FoldableEqExtensions;

var List_FoldableOrdExtensions = include$1.FoldableOrdExtensions;

var List_BsFunctorExtensions = include$2.BsFunctorExtensions;

var List_flipMap = include$2.flipMap;

var List_void = include$2.$$void;

var List_voidRight = include$2.voidRight;

var List_voidLeft = include$2.voidLeft;

var List_flap = include$2.flap;

var List_BsApplyExtensions = include$3.BsApplyExtensions;

var List_applyFirst = include$3.applyFirst;

var List_applySecond = include$3.applySecond;

var List_map2 = include$3.map2;

var List_map3 = include$3.map3;

var List_map4 = include$3.map4;

var List_map5 = include$3.map5;

var List_tuple2 = include$3.tuple2;

var List_tuple3 = include$3.tuple3;

var List_tuple4 = include$3.tuple4;

var List_tuple5 = include$3.tuple5;

var List_mapTuple2 = include$3.mapTuple2;

var List_mapTuple3 = include$3.mapTuple3;

var List_mapTuple4 = include$3.mapTuple4;

var List_mapTuple5 = include$3.mapTuple5;

var List_BsApplicativeExtensions = include$4.BsApplicativeExtensions;

var List_liftA1 = include$4.liftA1;

var List_all = include$4.all;

var List_BsMonadExtensions = include$5.BsMonadExtensions;

var List_flatMap = include$5.flatMap;

var List_flatten = include$5.flatten;

var List_composeKleisli = include$5.composeKleisli;

var List_flipComposeKleisli = include$5.flipComposeKleisli;

var List_liftM1 = include$5.liftM1;

var List_when_ = include$5.when_;

var List_unless = include$5.unless;

var List = {
  one: one,
  make: make,
  fromSequence: fromSequence,
  toSequence: toSequence,
  fromList: fromList,
  fromArray: fromArray,
  cons: cons,
  uncons: uncons,
  head: head,
  tail: tail,
  concat: concat,
  SemigroupAny: SemigroupAny,
  concatNamed: List_concatNamed,
  MagmaAny: MagmaAny,
  reduceLeft: reduceLeft,
  foldLeft: foldLeft,
  foldRight: foldRight,
  Foldable: Foldable,
  BsFoldableExtensions: List_BsFoldableExtensions,
  any: List_any,
  containsBy: List_containsBy,
  contains: List_contains,
  indexOfBy: List_indexOfBy,
  indexOf: List_indexOf,
  minBy: List_minBy,
  min: List_min,
  maxBy: List_maxBy,
  max: List_max,
  countBy: List_countBy,
  length: List_length,
  size: List_size,
  count: List_count,
  forEach: List_forEach,
  forEachWithIndex: List_forEachWithIndex,
  find: List_find,
  findWithIndex: List_findWithIndex,
  toList: List_toList,
  toArray: List_toArray,
  FoldableSemigroupExtensions: List_FoldableSemigroupExtensions,
  FoldableMonoidExtensions: List_FoldableMonoidExtensions,
  foldMap: List_foldMap,
  foldWithMonoid: List_foldWithMonoid,
  intercalate: List_intercalate,
  FoldableApplicativeExtensions: List_FoldableApplicativeExtensions,
  FoldableMonadExtensions: List_FoldableMonadExtensions,
  FoldableEqExtensions: List_FoldableEqExtensions,
  FoldableOrdExtensions: List_FoldableOrdExtensions,
  map: map,
  Functor: Functor,
  BsFunctorExtensions: List_BsFunctorExtensions,
  flipMap: List_flipMap,
  $$void: List_void,
  voidRight: List_voidRight,
  voidLeft: List_voidLeft,
  flap: List_flap,
  apply: apply,
  Apply: Apply,
  BsApplyExtensions: List_BsApplyExtensions,
  applyFirst: List_applyFirst,
  applySecond: List_applySecond,
  map2: List_map2,
  map3: List_map3,
  map4: List_map4,
  map5: List_map5,
  tuple2: List_tuple2,
  tuple3: List_tuple3,
  tuple4: List_tuple4,
  tuple5: List_tuple5,
  mapTuple2: List_mapTuple2,
  mapTuple3: List_mapTuple3,
  mapTuple4: List_mapTuple4,
  mapTuple5: List_mapTuple5,
  pure: one,
  Applicative: Applicative,
  BsApplicativeExtensions: List_BsApplicativeExtensions,
  liftA1: List_liftA1,
  all: List_all,
  bind: bind,
  Monad: Monad,
  BsMonadExtensions: List_BsMonadExtensions,
  flatMap: List_flatMap,
  flatten: List_flatten,
  composeKleisli: List_composeKleisli,
  flipComposeKleisli: List_flipComposeKleisli,
  liftM1: List_liftM1,
  when_: List_when_,
  unless: List_unless,
  mkString: mkString,
  reverse: reverse,
  eqBy: eqBy,
  eq: eq,
  Eq: Eq,
  showBy: showBy,
  show: show,
  Show: Show,
  WithApplicative: WithApplicative
};

function one$1(head) {
  return /* NonEmpty */{
          _0: head,
          _1: Curry._1(Relude__Relude_Sequence.$$Array.emptyLazy, undefined)
        };
}

function make$1(head, tailSequence) {
  return /* NonEmpty */{
          _0: head,
          _1: tailSequence
        };
}

function fromSequence$1(sequence) {
  return Belt_Option.map(Curry._1(Relude__Relude_Sequence.$$Array.head, sequence), (function (head) {
                return /* NonEmpty */{
                        _0: head,
                        _1: Curry._1(Relude__Relude_Sequence.$$Array.tailOrEmpty, sequence)
                      };
              }));
}

function toSequence$1(param) {
  return Curry._2(Relude__Relude_Sequence.$$Array.concat, Curry._1(Relude__Relude_Sequence.$$Array.Monad.pure, param._0), param._1);
}

function fromList$1(list) {
  if (list) {
    return /* NonEmpty */{
            _0: list.hd,
            _1: Curry._1(Relude__Relude_Sequence.$$Array.fromList, list.tl)
          };
  }
  
}

function fromArray$1(array) {
  return Relude__Relude_Option_Instances.map((function (param) {
                return /* NonEmpty */{
                        _0: param[0],
                        _1: Curry._1(Relude__Relude_Sequence.$$Array.fromArray, param[1])
                      };
              }), Relude__Relude_Array_Base.uncons(array));
}

function cons$1(head, tailNonEmpty) {
  return /* NonEmpty */{
          _0: head,
          _1: toSequence$1(tailNonEmpty)
        };
}

function uncons$1(param) {
  return [
          param._0,
          param._1
        ];
}

function head$1(param) {
  return param._0;
}

function tail$1(param) {
  return param._1;
}

function concat$1(nonEmpty1, nonEmpty2) {
  return /* NonEmpty */{
          _0: head$1(nonEmpty1),
          _1: Curry._2(Relude__Relude_Sequence.$$Array.concat, tail$1(nonEmpty1), toSequence$1(nonEmpty2))
        };
}

var SemigroupAny$1 = {
  append: concat$1
};

var include$6 = Relude__Relude_Extensions_SemigroupAny.SemigroupAnyExtensions(SemigroupAny$1);

var MagmaAny$1 = {
  append: concat$1
};

function reduceLeft$1(f, param) {
  return Curry._3(Relude__Relude_Sequence.$$Array.Foldable.fold_left, f, param._0, param._1);
}

function foldLeft$1(f, init, param) {
  return Curry._3(Relude__Relude_Sequence.$$Array.Foldable.fold_left, f, Curry._2(f, init, param._0), param._1);
}

function foldRight$1(f, init, param) {
  return Curry._2(f, param._0, Curry._3(Relude__Relude_Sequence.$$Array.Foldable.fold_right, f, init, param._1));
}

function Foldable_Fold_Map$1(funarg) {
  var TailFoldMap = Curry._1(Relude__Relude_Sequence.$$Array.Foldable.Fold_Map, funarg);
  var fold_map = function (f, param) {
    return Curry._2(funarg.append, Curry._1(f, param._0), Curry._2(TailFoldMap.fold_map, f, param._1));
  };
  return {
          fold_map: fold_map
        };
}

function Foldable_Fold_Map_Any$1(funarg) {
  var SequenceFoldMapAny = Curry._1(Relude__Relude_Sequence.$$Array.Foldable.Fold_Map_Any, funarg);
  var fold_map = function (f, param) {
    return Curry._2(funarg.append, Curry._1(f, param._0), Curry._2(SequenceFoldMapAny.fold_map, f, param._1));
  };
  return {
          fold_map: fold_map
        };
}

function Foldable_Fold_Map_Plus$1(funarg) {
  var TailFoldMapPlus = Curry._1(Relude__Relude_Sequence.$$Array.Foldable.Fold_Map_Plus, funarg);
  var fold_map = function (f, param) {
    return Curry._2(funarg.alt, Curry._1(f, param._0), Curry._2(TailFoldMapPlus.fold_map, f, param._1));
  };
  return {
          fold_map: fold_map
        };
}

var Foldable$1 = {
  fold_left: foldLeft$1,
  fold_right: foldRight$1,
  Fold_Map: Foldable_Fold_Map$1,
  Fold_Map_Any: Foldable_Fold_Map_Any$1,
  Fold_Map_Plus: Foldable_Fold_Map_Plus$1
};

var include$7 = Relude__Relude_Extensions_Foldable.FoldableExtensions(Foldable$1);

function map$1(f, param) {
  return /* NonEmpty */{
          _0: Curry._1(f, param._0),
          _1: Curry._2(Relude__Relude_Sequence.$$Array.Monad.map, f, param._1)
        };
}

var Functor$1 = {
  map: map$1
};

var include$8 = Relude__Relude_Extensions_Functor.FunctorExtensions(Functor$1);

function apply$1(ff, fa) {
  return reduceLeft$1(concat$1, map$1((function (f) {
                    return map$1(f, fa);
                  }), ff));
}

var Apply$1 = {
  map: map$1,
  apply: apply$1
};

var include$9 = Relude__Relude_Extensions_Apply.ApplyExtensions(Apply$1);

var Applicative$1 = {
  map: map$1,
  apply: apply$1,
  pure: one$1
};

var include$10 = Relude__Relude_Extensions_Applicative.ApplicativeExtensions(Applicative$1);

function bind$1(nonEmpty, f) {
  return reduceLeft$1(concat$1, map$1(f, nonEmpty));
}

var Monad$1 = {
  map: map$1,
  apply: apply$1,
  pure: one$1,
  flat_map: bind$1
};

var include$11 = Relude__Relude_Extensions_Monad.MonadExtensions(Monad$1);

function mkString$1(delim, xs) {
  return xs._0 + (delim + Curry._2(Relude__Relude_Sequence.$$Array.mkString, delim, xs._1));
}

function reverse$1(param) {
  var head = param._0;
  return Relude__Relude_Option_Base.getOrElseLazy((function (param) {
                return /* NonEmpty */{
                        _0: head,
                        _1: Curry._1(Relude__Relude_Sequence.$$Array.emptyLazy, undefined)
                      };
              }), Relude__Relude_Option_Instances.map((function (param) {
                    return /* NonEmpty */{
                            _0: param[0],
                            _1: Curry._2(Relude__Relude_Sequence.$$Array.append, head, param[1])
                          };
                  }), Curry._1(Relude__Relude_Sequence.$$Array.uncons, Curry._1(Relude__Relude_Sequence.$$Array.reverse, param._1))));
}

function eqBy$1(eqA, xs, ys) {
  if (Curry._2(eqA, xs._0, ys._0)) {
    return Curry._3(Relude__Relude_Sequence.$$Array.eqBy, eqA, xs._1, ys._1);
  } else {
    return false;
  }
}

function eq$1(eqA, xs, ys) {
  return eqBy$1(eqA.eq, xs, ys);
}

function Eq$1(EqA) {
  var eq = function (xs, ys) {
    return eqBy$1(EqA.eq, xs, ys);
  };
  return {
          eq: eq
        };
}

function showBy$1(showX, xs) {
  var strings = map$1(showX, xs);
  return "[!" + (mkString$1(", ", strings) + "!]");
}

function show$1(showA, xs) {
  return showBy$1(showA.show, xs);
}

function Show$1(S) {
  var show = function (param) {
    return showBy$1(S.show, param);
  };
  return {
          show: show
        };
}

function WithApplicative$1(A) {
  var TailTraversable = Curry._1(Relude__Relude_Sequence.$$Array.Traversable, A);
  var traverse = function (f, param) {
    return Curry._2(A.apply, Curry._2(A.map, make$1, Curry._1(f, param._0)), Curry._2(TailTraversable.traverse, f, param._1));
  };
  var sequence = function (fa) {
    return traverse((function (x) {
                  return x;
                }), fa);
  };
  var Traversable_Fold_Map = Foldable_Fold_Map$1;
  var Traversable_Fold_Map_Any = Foldable_Fold_Map_Any$1;
  var Traversable_Fold_Map_Plus = Foldable_Fold_Map_Plus$1;
  var Traversable = {
    map: map$1,
    fold_left: foldLeft$1,
    fold_right: foldRight$1,
    Fold_Map: Traversable_Fold_Map,
    Fold_Map_Any: Traversable_Fold_Map_Any,
    Fold_Map_Plus: Traversable_Fold_Map_Plus,
    traverse: traverse,
    sequence: sequence
  };
  Relude__Relude_Extensions_Traversable.TraversableExtensions(Traversable);
  return {
          Traversable: Traversable,
          traverse: traverse,
          sequence: sequence
        };
}

function toNonEmptyList(param) {
  return /* NonEmpty */{
          _0: param._0,
          _1: Belt_List.fromArray(param._1)
        };
}

function fromNonEmptyList(param) {
  return /* NonEmpty */{
          _0: param._0,
          _1: Belt_List.toArray(param._1)
        };
}

var Array_concatNamed = include$6.concatNamed;

var Array_BsFoldableExtensions = include$7.BsFoldableExtensions;

var Array_any = include$7.any;

var Array_containsBy = include$7.containsBy;

var Array_contains = include$7.contains;

var Array_indexOfBy = include$7.indexOfBy;

var Array_indexOf = include$7.indexOf;

var Array_minBy = include$7.minBy;

var Array_min = include$7.min;

var Array_maxBy = include$7.maxBy;

var Array_max = include$7.max;

var Array_countBy = include$7.countBy;

var Array_length = include$7.length;

var Array_size = include$7.size;

var Array_count = include$7.count;

var Array_forEach = include$7.forEach;

var Array_forEachWithIndex = include$7.forEachWithIndex;

var Array_find = include$7.find;

var Array_findWithIndex = include$7.findWithIndex;

var Array_toList = include$7.toList;

var Array_toArray = include$7.toArray;

var Array_FoldableSemigroupExtensions = include$7.FoldableSemigroupExtensions;

var Array_FoldableMonoidExtensions = include$7.FoldableMonoidExtensions;

var Array_foldMap = include$7.foldMap;

var Array_foldWithMonoid = include$7.foldWithMonoid;

var Array_intercalate = include$7.intercalate;

var Array_FoldableApplicativeExtensions = include$7.FoldableApplicativeExtensions;

var Array_FoldableMonadExtensions = include$7.FoldableMonadExtensions;

var Array_FoldableEqExtensions = include$7.FoldableEqExtensions;

var Array_FoldableOrdExtensions = include$7.FoldableOrdExtensions;

var Array_BsFunctorExtensions = include$8.BsFunctorExtensions;

var Array_flipMap = include$8.flipMap;

var Array_void = include$8.$$void;

var Array_voidRight = include$8.voidRight;

var Array_voidLeft = include$8.voidLeft;

var Array_flap = include$8.flap;

var Array_BsApplyExtensions = include$9.BsApplyExtensions;

var Array_applyFirst = include$9.applyFirst;

var Array_applySecond = include$9.applySecond;

var Array_map2 = include$9.map2;

var Array_map3 = include$9.map3;

var Array_map4 = include$9.map4;

var Array_map5 = include$9.map5;

var Array_tuple2 = include$9.tuple2;

var Array_tuple3 = include$9.tuple3;

var Array_tuple4 = include$9.tuple4;

var Array_tuple5 = include$9.tuple5;

var Array_mapTuple2 = include$9.mapTuple2;

var Array_mapTuple3 = include$9.mapTuple3;

var Array_mapTuple4 = include$9.mapTuple4;

var Array_mapTuple5 = include$9.mapTuple5;

var Array_BsApplicativeExtensions = include$10.BsApplicativeExtensions;

var Array_liftA1 = include$10.liftA1;

var Array_all = include$10.all;

var Array_BsMonadExtensions = include$11.BsMonadExtensions;

var Array_flatMap = include$11.flatMap;

var Array_flatten = include$11.flatten;

var Array_composeKleisli = include$11.composeKleisli;

var Array_flipComposeKleisli = include$11.flipComposeKleisli;

var Array_liftM1 = include$11.liftM1;

var Array_when_ = include$11.when_;

var Array_unless = include$11.unless;

var $$Array = {
  one: one$1,
  make: make$1,
  fromSequence: fromSequence$1,
  toSequence: toSequence$1,
  fromList: fromList$1,
  fromArray: fromArray$1,
  cons: cons$1,
  uncons: uncons$1,
  head: head$1,
  tail: tail$1,
  concat: concat$1,
  SemigroupAny: SemigroupAny$1,
  concatNamed: Array_concatNamed,
  MagmaAny: MagmaAny$1,
  reduceLeft: reduceLeft$1,
  foldLeft: foldLeft$1,
  foldRight: foldRight$1,
  Foldable: Foldable$1,
  BsFoldableExtensions: Array_BsFoldableExtensions,
  any: Array_any,
  containsBy: Array_containsBy,
  contains: Array_contains,
  indexOfBy: Array_indexOfBy,
  indexOf: Array_indexOf,
  minBy: Array_minBy,
  min: Array_min,
  maxBy: Array_maxBy,
  max: Array_max,
  countBy: Array_countBy,
  length: Array_length,
  size: Array_size,
  count: Array_count,
  forEach: Array_forEach,
  forEachWithIndex: Array_forEachWithIndex,
  find: Array_find,
  findWithIndex: Array_findWithIndex,
  toList: Array_toList,
  toArray: Array_toArray,
  FoldableSemigroupExtensions: Array_FoldableSemigroupExtensions,
  FoldableMonoidExtensions: Array_FoldableMonoidExtensions,
  foldMap: Array_foldMap,
  foldWithMonoid: Array_foldWithMonoid,
  intercalate: Array_intercalate,
  FoldableApplicativeExtensions: Array_FoldableApplicativeExtensions,
  FoldableMonadExtensions: Array_FoldableMonadExtensions,
  FoldableEqExtensions: Array_FoldableEqExtensions,
  FoldableOrdExtensions: Array_FoldableOrdExtensions,
  map: map$1,
  Functor: Functor$1,
  BsFunctorExtensions: Array_BsFunctorExtensions,
  flipMap: Array_flipMap,
  $$void: Array_void,
  voidRight: Array_voidRight,
  voidLeft: Array_voidLeft,
  flap: Array_flap,
  apply: apply$1,
  Apply: Apply$1,
  BsApplyExtensions: Array_BsApplyExtensions,
  applyFirst: Array_applyFirst,
  applySecond: Array_applySecond,
  map2: Array_map2,
  map3: Array_map3,
  map4: Array_map4,
  map5: Array_map5,
  tuple2: Array_tuple2,
  tuple3: Array_tuple3,
  tuple4: Array_tuple4,
  tuple5: Array_tuple5,
  mapTuple2: Array_mapTuple2,
  mapTuple3: Array_mapTuple3,
  mapTuple4: Array_mapTuple4,
  mapTuple5: Array_mapTuple5,
  pure: one$1,
  Applicative: Applicative$1,
  BsApplicativeExtensions: Array_BsApplicativeExtensions,
  liftA1: Array_liftA1,
  all: Array_all,
  bind: bind$1,
  Monad: Monad$1,
  BsMonadExtensions: Array_BsMonadExtensions,
  flatMap: Array_flatMap,
  flatten: Array_flatten,
  composeKleisli: Array_composeKleisli,
  flipComposeKleisli: Array_flipComposeKleisli,
  liftM1: Array_liftM1,
  when_: Array_when_,
  unless: Array_unless,
  mkString: mkString$1,
  reverse: reverse$1,
  eqBy: eqBy$1,
  eq: eq$1,
  Eq: Eq$1,
  showBy: showBy$1,
  show: show$1,
  Show: Show$1,
  WithApplicative: WithApplicative$1,
  toNonEmptyList: toNonEmptyList,
  fromNonEmptyList: fromNonEmptyList
};

exports.WithSequence = WithSequence;
exports.List = List;
exports.$$Array = $$Array;
/* include Not a pure module */
