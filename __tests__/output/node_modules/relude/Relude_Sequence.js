// Generated by Melange
'use strict';

var Curry = require("melange.runtime/curry.js");
var Bastet__Array = require("bastet/./Array.js");
var Bastet__String = require("bastet/./String.js");
var Relude__Relude_List_Base = require("./list/Relude_List_Base.js");
var Relude__Relude_Array_Base = require("./array/Relude_Array_Base.js");
var Relude__Relude_List_Instances = require("./list/Relude_List_Instances.js");
var Relude__Relude_Array_Instances = require("./array/Relude_Array_Instances.js");

function emptyLazy(param) {
  return /* [] */0;
}

function fromList(a) {
  return a;
}

function toList(a) {
  return a;
}

var mkString = Curry._1(Relude__Relude_List_Instances.intercalate, Bastet__String.Monoid);

var List = {
  emptyLazy: emptyLazy,
  length: Relude__Relude_List_Instances.length,
  isEmpty: Relude__Relude_List_Base.isEmpty,
  isNotEmpty: Relude__Relude_List_Base.isNotEmpty,
  head: Relude__Relude_List_Base.head,
  tail: Relude__Relude_List_Base.tail,
  tailOrEmpty: Relude__Relude_List_Base.tailOrEmpty,
  uncons: Relude__Relude_List_Base.uncons,
  prepend: Relude__Relude_List_Base.prepend,
  append: Relude__Relude_List_Base.append,
  concat: Relude__Relude_List_Instances.concat,
  reverse: Relude__Relude_List_Base.reverse,
  mkString: mkString,
  zip: Relude__Relude_List_Base.zip,
  zipWith: Relude__Relude_List_Base.zipWith,
  fromArray: Relude__Relude_List_Instances.fromArray,
  fromList: fromList,
  toArray: Relude__Relude_List_Instances.toArray,
  toList: toList,
  eqBy: Relude__Relude_List_Instances.eqBy,
  showBy: Relude__Relude_List_Instances.showBy,
  Functor: Relude__Relude_List_Instances.Functor,
  Apply: Relude__Relude_List_Instances.Apply,
  Applicative: Relude__Relude_List_Instances.Applicative,
  Monad: Relude__Relude_List_Instances.Monad,
  Foldable: Relude__Relude_List_Instances.Foldable,
  Traversable: Relude__Relude_List_Instances.Traversable,
  Eq: Relude__Relude_List_Instances.Eq,
  Show: Relude__Relude_List_Instances.Show
};

function emptyLazy$1(param) {
  return [];
}

function fromArray(a) {
  return a;
}

function toArray(a) {
  return a;
}

var mkString$1 = Curry._1(Relude__Relude_Array_Instances.intercalate, Bastet__String.Monoid);

var $$Array = {
  emptyLazy: emptyLazy$1,
  length: Relude__Relude_Array_Base.length,
  isEmpty: Relude__Relude_Array_Base.isEmpty,
  isNotEmpty: Relude__Relude_Array_Base.isNotEmpty,
  head: Relude__Relude_Array_Base.head,
  tail: Relude__Relude_Array_Base.tail,
  tailOrEmpty: Relude__Relude_Array_Base.tailOrEmpty,
  uncons: Relude__Relude_Array_Base.uncons,
  prepend: Relude__Relude_Array_Base.prepend,
  append: Relude__Relude_Array_Base.append,
  concat: Relude__Relude_Array_Instances.concat,
  reverse: Relude__Relude_Array_Base.reverse,
  mkString: mkString$1,
  zip: Relude__Relude_Array_Base.zip,
  zipWith: Relude__Relude_Array_Base.zipWith,
  fromArray: fromArray,
  fromList: Relude__Relude_Array_Instances.fromList,
  toArray: toArray,
  toList: Relude__Relude_Array_Instances.toList,
  eqBy: Relude__Relude_Array_Instances.eqBy,
  showBy: Relude__Relude_Array_Instances.showBy,
  Functor: Relude__Relude_Array_Instances.Functor,
  Apply: Relude__Relude_Array_Instances.Apply,
  Applicative: Relude__Relude_Array_Instances.Applicative,
  Monad: Relude__Relude_Array_Instances.Monad,
  Foldable: Relude__Relude_Array_Instances.Foldable,
  Traversable: Bastet__Array.Traversable,
  Eq: Relude__Relude_Array_Instances.Eq,
  Show: Relude__Relude_Array_Instances.Show
};

exports.List = List;
exports.$$Array = $$Array;
/* mkString Not a pure module */
