// Generated by Melange
'use strict';

var Curry = require("melange.runtime/curry.js");
var Js_int = require("melange.belt/./js_int.js");
var Caml_int32 = require("melange.runtime/caml_int32.js");
var Bastet__Int = require("bastet/./Int.js");
var Caml_format = require("melange.runtime/caml_format.js");
var Relude__Relude_Map = require("./Relude_Map.js");
var Relude__Relude_Set = require("./Relude_Set.js");
var Relude__Relude_Extensions_Eq = require("./extensions/Relude_Extensions_Eq.js");
var Relude__Relude_Extensions_Ord = require("./extensions/Relude_Extensions_Ord.js");
var Relude__Relude_Array_Instances = require("./array/Relude_Array_Instances.js");
var Relude__Relude_Extensions_Enum = require("./extensions/Relude_Extensions_Enum.js");
var Relude__Relude_Extensions_Ring = require("./extensions/Relude_Extensions_Ring.js");
var Relude__Relude_Extensions_Bounded = require("./extensions/Relude_Extensions_Bounded.js");
var Relude__Relude_Extensions_Semiring = require("./extensions/Relude_Extensions_Semiring.js");

function toFloat(prim) {
  return prim;
}

function fromFloat(prim) {
  return prim | 0;
}

function add(prim0, prim1) {
  return prim0 + prim1 | 0;
}

function subtract(prim0, prim1) {
  return prim0 - prim1 | 0;
}

function multiply(prim0, prim1) {
  return Math.imul(prim0, prim1);
}

var divide = Caml_int32.div;

var modulo = Caml_int32.mod_;

function divideWithModulo(a, b) {
  return [
          Caml_int32.div(a, b),
          Caml_int32.mod_(a, b)
        ];
}

function divideAsFloat(a, b) {
  return a / b;
}

function degree(a) {
  return Math.min(Math.abs(a), Js_int.max);
}

function rangeAsList(start, end_) {
  if (start >= end_) {
    return /* [] */0;
  } else {
    return {
            hd: start,
            tl: rangeAsList(start + 1 | 0, end_)
          };
  }
}

function rangeAsArray(start, end_) {
  if (start >= end_) {
    return [];
  } else {
    return Relude__Relude_Array_Instances.concat([start], rangeAsArray(start + 1 | 0, end_));
  }
}

var eq = Bastet__Int.Eq.eq;

var Eq = {
  eq: eq
};

var include = Relude__Relude_Extensions_Eq.EqExtensions(Eq);

var compare = Bastet__Int.Ord.compare;

var Ord = {
  eq: eq,
  compare: compare
};

var include$1 = Relude__Relude_Extensions_Ord.OrdExtensions(Ord);

var OrdRingExtensions = include$1.OrdRingExtensions;

var Bounded = {
  eq: eq,
  compare: compare,
  top: Js_int.max,
  bottom: Js_int.min
};

Relude__Relude_Extensions_Bounded.BoundedExtensions(Bounded);

function pred(i) {
  if (i > Js_int.min) {
    return i - 1 | 0;
  }
  
}

function succ(i) {
  if (i < Js_int.max) {
    return i + 1 | 0;
  }
  
}

var Enum = {
  eq: eq,
  compare: compare,
  succ: succ,
  pred: pred
};

var include$2 = Relude__Relude_Extensions_Enum.EnumExtensions(Enum);

var Semiring = {
  add: add,
  zero: 0,
  multiply: multiply,
  one: 1
};

Relude__Relude_Extensions_Semiring.SemiringExtensions(Semiring);

var Ring = {
  add: add,
  zero: 0,
  multiply: multiply,
  one: 1,
  subtract: subtract
};

var include$3 = Relude__Relude_Extensions_Ring.RingExtensions(Ring);

var include$4 = Curry._1(OrdRingExtensions, Ring);

var EuclideanRing = {
  add: add,
  zero: 0,
  multiply: multiply,
  one: 1,
  subtract: subtract,
  degree: degree,
  divide: divide,
  modulo: modulo
};

var $$Map = Relude__Relude_Map.WithOrd(Ord);

var $$Set = Relude__Relude_Set.WithOrd(Ord);

function show(prim) {
  return String(prim);
}

var Show = {
  show: show
};

function fromString(v) {
  try {
    return Caml_format.caml_int_of_string(v);
  }
  catch (exn){
    return ;
  }
}

var Additive_Magma = Bastet__Int.Additive.Magma;

var Additive_Medial_Magma = Bastet__Int.Additive.Medial_Magma;

var Additive_Semigroup = Bastet__Int.Additive.Semigroup;

var Additive_Monoid = Bastet__Int.Additive.Monoid;

var Additive_Quasigroup = Bastet__Int.Additive.Quasigroup;

var Additive_Medial_Quasigroup = Bastet__Int.Additive.Medial_Quasigroup;

var Additive_Loop = Bastet__Int.Additive.Loop;

var Additive_Group = Bastet__Int.Additive.Group;

var Additive_Abelian_Group = Bastet__Int.Additive.Abelian_Group;

var Additive = {
  Magma: Additive_Magma,
  Medial_Magma: Additive_Medial_Magma,
  Semigroup: Additive_Semigroup,
  Monoid: Additive_Monoid,
  Quasigroup: Additive_Quasigroup,
  Medial_Quasigroup: Additive_Medial_Quasigroup,
  Loop: Additive_Loop,
  Group: Additive_Group,
  Abelian_Group: Additive_Abelian_Group
};

var Multiplicative_Magma = Bastet__Int.Multiplicative.Magma;

var Multiplicative_Medial_Magma = Bastet__Int.Multiplicative.Medial_Magma;

var Multiplicative_Semigroup = Bastet__Int.Multiplicative.Semigroup;

var Multiplicative_Monoid = Bastet__Int.Multiplicative.Monoid;

var Multiplicative_Quasigroup = Bastet__Int.Multiplicative.Quasigroup;

var Multiplicative_Loop = Bastet__Int.Multiplicative.Loop;

var Multiplicative = {
  Magma: Multiplicative_Magma,
  Medial_Magma: Multiplicative_Medial_Magma,
  Semigroup: Multiplicative_Semigroup,
  Monoid: Multiplicative_Monoid,
  Quasigroup: Multiplicative_Quasigroup,
  Loop: Multiplicative_Loop
};

var Subtractive_Magma = Bastet__Int.Subtractive.Magma;

var Subtractive_Medial_Magma = Bastet__Int.Subtractive.Medial_Magma;

var Subtractive_Quasigroup = Bastet__Int.Subtractive.Quasigroup;

var Subtractive = {
  Magma: Subtractive_Magma,
  Medial_Magma: Subtractive_Medial_Magma,
  Quasigroup: Subtractive_Quasigroup
};

var Divisive = {
  Magma: Bastet__Int.Divisive.Magma
};

var include$5 = Relude__Relude_Extensions_Eq.EqInfix(Eq);

var include$6 = Relude__Relude_Extensions_Ord.OrdInfix(Ord);

var Infix_Additive = Bastet__Int.Infix.Additive;

var Infix_Multiplicative = Bastet__Int.Infix.Multiplicative;

var Infix_$eq$pipe$eq = Bastet__Int.Infix.$eq$pipe$eq;

var Infix_$less$pipe$pipe = Bastet__Int.Infix.$less$pipe$pipe;

var Infix_$pipe$pipe$great = Bastet__Int.Infix.$pipe$pipe$great;

var Infix_$less$pipe$eq = Bastet__Int.Infix.$less$pipe$eq;

var Infix_$great$pipe$eq = Bastet__Int.Infix.$great$pipe$eq;

var Infix_$pipe$plus$pipe = Bastet__Int.Infix.$pipe$plus$pipe;

var Infix_$pipe$star$pipe = Bastet__Int.Infix.$pipe$star$pipe;

var Infix_$pipe$$pipe = Bastet__Int.Infix.$pipe$neg$pipe;

var Infix_$pipe$slash$pipe = Bastet__Int.Infix.$pipe$slash$pipe;

var Infix_$pipe$percent$pipe = Bastet__Int.Infix.$pipe$percent$pipe;

var Infix_EqExtensions = include$5.EqExtensions;

var Infix_$pipe$eq$pipe = include$5.$pipe$eq$pipe;

var Infix_$pipe$bang$eq$pipe = include$5.$pipe$bang$eq$pipe;

var Infix_OrdExtensions = include$6.OrdExtensions;

var Infix_$pipe$less$pipe = include$6.$pipe$less$pipe;

var Infix_$pipe$less$eq$pipe = include$6.$pipe$less$eq$pipe;

var Infix_$pipe$great$pipe = include$6.$pipe$great$pipe;

var Infix_$pipe$great$eq$pipe = include$6.$pipe$great$eq$pipe;

var Infix = {
  Additive: Infix_Additive,
  Multiplicative: Infix_Multiplicative,
  $eq$pipe$eq: Infix_$eq$pipe$eq,
  $less$pipe$pipe: Infix_$less$pipe$pipe,
  $pipe$pipe$great: Infix_$pipe$pipe$great,
  $less$pipe$eq: Infix_$less$pipe$eq,
  $great$pipe$eq: Infix_$great$pipe$eq,
  $pipe$plus$pipe: Infix_$pipe$plus$pipe,
  $pipe$star$pipe: Infix_$pipe$star$pipe,
  $pipe$neg$pipe: Infix_$pipe$$pipe,
  $pipe$slash$pipe: Infix_$pipe$slash$pipe,
  $pipe$percent$pipe: Infix_$pipe$percent$pipe,
  EqExtensions: Infix_EqExtensions,
  $pipe$eq$pipe: Infix_$pipe$eq$pipe,
  $pipe$bang$eq$pipe: Infix_$pipe$bang$eq$pipe,
  OrdExtensions: Infix_OrdExtensions,
  $pipe$less$pipe: Infix_$pipe$less$pipe,
  $pipe$less$eq$pipe: Infix_$pipe$less$eq$pipe,
  $pipe$great$pipe: Infix_$pipe$great$pipe,
  $pipe$great$eq$pipe: Infix_$pipe$great$eq$pipe
};

var zero = 0;

var one = 1;

var top = Js_int.max;

var bottom = Js_int.min;

var eqWithConversion = include.eqWithConversion;

var notEq = include.notEq;

var eqInverted = include.eqInverted;

var EqInverted = include.EqInverted;

var EqBy = include.EqBy;

var compareWithConversion = include$1.compareWithConversion;

var compareReversed = include$1.compareReversed;

var OrdReversed = include$1.OrdReversed;

var compareAsInt = include$1.compareAsInt;

var min = include$1.min;

var max = include$1.max;

var lessThan = include$1.lessThan;

var lt = include$1.lt;

var lessThanOrEq = include$1.lessThanOrEq;

var lte = include$1.lte;

var greaterThan = include$1.greaterThan;

var gt = include$1.gt;

var greaterThanOrEq = include$1.greaterThanOrEq;

var gte = include$1.gte;

var clamp = include$1.clamp;

var between = include$1.between;

var OrdNamed = include$1.OrdNamed;

var OrdBy = include$1.OrdBy;

var fromToAsList = include$2.fromToAsList;

var upFromAsList = include$2.upFromAsList;

var upFromIncludingAsList = include$2.upFromIncludingAsList;

var downFromAsList = include$2.downFromAsList;

var downFromIncludingAsList = include$2.downFromIncludingAsList;

var $neg = include$3.$neg;

var negate = include$3.negate;

var abs = include$4.abs;

var signum = include$4.signum;

var toString = show;

exports.toFloat = toFloat;
exports.fromFloat = fromFloat;
exports.zero = zero;
exports.one = one;
exports.add = add;
exports.subtract = subtract;
exports.multiply = multiply;
exports.divide = divide;
exports.modulo = modulo;
exports.divideWithModulo = divideWithModulo;
exports.divideAsFloat = divideAsFloat;
exports.top = top;
exports.bottom = bottom;
exports.degree = degree;
exports.rangeAsList = rangeAsList;
exports.rangeAsArray = rangeAsArray;
exports.eq = eq;
exports.Eq = Eq;
exports.eqWithConversion = eqWithConversion;
exports.notEq = notEq;
exports.eqInverted = eqInverted;
exports.EqInverted = EqInverted;
exports.EqBy = EqBy;
exports.compare = compare;
exports.Ord = Ord;
exports.compareWithConversion = compareWithConversion;
exports.compareReversed = compareReversed;
exports.OrdReversed = OrdReversed;
exports.compareAsInt = compareAsInt;
exports.min = min;
exports.max = max;
exports.lessThan = lessThan;
exports.lt = lt;
exports.lessThanOrEq = lessThanOrEq;
exports.lte = lte;
exports.greaterThan = greaterThan;
exports.gt = gt;
exports.greaterThanOrEq = greaterThanOrEq;
exports.gte = gte;
exports.clamp = clamp;
exports.between = between;
exports.OrdRingExtensions = OrdRingExtensions;
exports.OrdNamed = OrdNamed;
exports.OrdBy = OrdBy;
exports.Bounded = Bounded;
exports.Enum = Enum;
exports.fromToAsList = fromToAsList;
exports.upFromAsList = upFromAsList;
exports.upFromIncludingAsList = upFromIncludingAsList;
exports.downFromAsList = downFromAsList;
exports.downFromIncludingAsList = downFromIncludingAsList;
exports.Semiring = Semiring;
exports.Ring = Ring;
exports.$neg = $neg;
exports.negate = negate;
exports.abs = abs;
exports.signum = signum;
exports.EuclideanRing = EuclideanRing;
exports.$$Map = $$Map;
exports.$$Set = $$Set;
exports.show = show;
exports.toString = toString;
exports.Show = Show;
exports.fromString = fromString;
exports.Additive = Additive;
exports.Multiplicative = Multiplicative;
exports.Subtractive = Subtractive;
exports.Divisive = Divisive;
exports.Infix = Infix;
/* include Not a pure module */
