// Generated by Melange
'use strict';

var Curry = require("melange.runtime/curry.js");
var Caml_option = require("melange.runtime/caml_option.js");
var Bastet__Result = require("bastet/./Result.js");
var Caml_js_exceptions = require("melange.runtime/caml_js_exceptions.js");
var Relude__Relude_Function = require("./Relude_Function.js");
var Relude__Relude_NonEmpty = require("./Relude_NonEmpty.js");
var Relude__Relude_Validation = require("./Relude_Validation.js");
var Relude__Relude_Extensions_Alt = require("./extensions/Relude_Extensions_Alt.js");
var Relude__Relude_Extensions_Apply = require("./extensions/Relude_Extensions_Apply.js");
var Relude__Relude_Extensions_Monad = require("./extensions/Relude_Extensions_Monad.js");
var Relude__Relude_Extensions_Functor = require("./extensions/Relude_Extensions_Functor.js");
var Relude__Relude_Extensions_Foldable = require("./extensions/Relude_Extensions_Foldable.js");
var Relude__Relude_Extensions_Bifunctor = require("./extensions/Relude_Extensions_Bifunctor.js");
var Relude__Relude_Extensions_Semialign = require("./extensions/Relude_Extensions_Semialign.js");
var Relude__Relude_Extensions_Bifoldable = require("./extensions/Relude_Extensions_Bifoldable.js");
var Relude__Relude_Extensions_MonadError = require("./extensions/Relude_Extensions_MonadError.js");
var Relude__Relude_Extensions_MonadThrow = require("./extensions/Relude_Extensions_MonadThrow.js");
var Relude__Relude_Extensions_Applicative = require("./extensions/Relude_Extensions_Applicative.js");
var Relude__Relude_Extensions_Traversable = require("./extensions/Relude_Extensions_Traversable.js");
var Relude__Relude_Extensions_Semigroupoid = require("./extensions/Relude_Extensions_Semigroupoid.js");
var Relude__Relude_Extensions_Bitraversable = require("./extensions/Relude_Extensions_Bitraversable.js");

function ok(a) {
  return {
          TAG: /* Ok */0,
          _0: a
        };
}

function error(e) {
  return {
          TAG: /* Error */1,
          _0: e
        };
}

function getOk(a) {
  if (a.TAG === /* Ok */0) {
    return Caml_option.some(a._0);
  }
  
}

function getError(e) {
  if (e.TAG === /* Ok */0) {
    return ;
  } else {
    return Caml_option.some(e._0);
  }
}

function isOk(param) {
  if (param.TAG === /* Ok */0) {
    return true;
  } else {
    return false;
  }
}

function isError(param) {
  if (param.TAG === /* Ok */0) {
    return false;
  } else {
    return true;
  }
}

function fold(ec, ac, r) {
  if (r.TAG === /* Ok */0) {
    return Curry._1(ac, r._0);
  } else {
    return Curry._1(ec, r._0);
  }
}

function getOrElse($$default, fa) {
  if (fa.TAG === /* Ok */0) {
    return fa._0;
  } else {
    return $$default;
  }
}

function getOrElseBy(fn, fa) {
  if (fa.TAG === /* Ok */0) {
    return fa._0;
  } else {
    return Curry._1(fn, fa._0);
  }
}

function getOrElseLazy(getDefault, fa) {
  if (fa.TAG === /* Ok */0) {
    return fa._0;
  } else {
    return Curry._1(getDefault, undefined);
  }
}

function getErrorOrElse($$default, fa) {
  if (fa.TAG === /* Ok */0) {
    return $$default;
  } else {
    return fa._0;
  }
}

function getErrorOrElseBy(fn, fa) {
  if (fa.TAG === /* Ok */0) {
    return Curry._1(fn, fa._0);
  } else {
    return fa._0;
  }
}

function merge(a) {
  return a._0;
}

function flip(a) {
  if (a.TAG === /* Ok */0) {
    return {
            TAG: /* Error */1,
            _0: a._0
          };
  } else {
    return {
            TAG: /* Ok */0,
            _0: a._0
          };
  }
}

function compose(resultBToC, resultAToB) {
  if (resultAToB.TAG !== /* Ok */0) {
    return {
            TAG: /* Error */1,
            _0: resultAToB._0
          };
  }
  var aToB = resultAToB._0;
  if (resultBToC.TAG !== /* Ok */0) {
    return {
            TAG: /* Error */1,
            _0: resultBToC._0
          };
  }
  var bToC = resultBToC._0;
  return {
          TAG: /* Ok */0,
          _0: (function (param) {
              return Relude__Relude_Function.Infix.$great$great(aToB, bToC, param);
            })
        };
}

function andThen(resultAToB, resultBToC) {
  return compose(resultBToC, resultAToB);
}

function map(f, fa) {
  if (fa.TAG === /* Ok */0) {
    return {
            TAG: /* Ok */0,
            _0: Curry._1(f, fa._0)
          };
  } else {
    return fa;
  }
}

function bimap(mapA, mapE, result) {
  if (result.TAG === /* Ok */0) {
    return {
            TAG: /* Ok */0,
            _0: Curry._1(mapA, result._0)
          };
  } else {
    return {
            TAG: /* Error */1,
            _0: Curry._1(mapE, result._0)
          };
  }
}

function tap(f, ra) {
  if (ra.TAG === /* Ok */0) {
    Curry._1(f, ra._0);
  }
  return ra;
}

function tapError(f, ra) {
  if (ra.TAG !== /* Ok */0) {
    Curry._1(f, ra._0);
  }
  return ra;
}

function apply(rf, ra) {
  if (rf.TAG === /* Ok */0) {
    if (ra.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: Curry._1(rf._0, ra._0)
            };
    } else {
      return {
              TAG: /* Error */1,
              _0: ra._0
            };
    }
  } else if (ra.TAG === /* Ok */0) {
    return {
            TAG: /* Error */1,
            _0: rf._0
          };
  } else {
    return {
            TAG: /* Error */1,
            _0: ra._0
          };
  }
}

function map2(f, fa, fb) {
  return apply(map(f, fa), fb);
}

function map3(f, fa, fb, fc) {
  return apply(map2(f, fa, fb), fc);
}

function map4(f, fa, fb, fc, fd) {
  return apply(map3(f, fa, fb, fc), fd);
}

function map5(f, fa, fb, fc, fd, fe) {
  return apply(map4(f, fa, fb, fc, fd), fe);
}

function pure(a) {
  return {
          TAG: /* Ok */0,
          _0: a
        };
}

function bind(fa, f) {
  if (fa.TAG === /* Ok */0) {
    return Curry._1(f, fa._0);
  } else {
    return fa;
  }
}

function flatMap(f, fa) {
  return bind(fa, f);
}

function flatten(mma) {
  return bind(mma, (function (a) {
                return a;
              }));
}

function alt(fa1, fa2) {
  if (fa1.TAG === /* Ok */0) {
    return fa1;
  } else {
    return fa2;
  }
}

function align(fa, fb) {
  if (fa.TAG !== /* Ok */0) {
    if (fb.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: {
                TAG: /* That */1,
                _0: fb._0
              }
            };
    } else {
      return {
              TAG: /* Error */1,
              _0: fa._0
            };
    }
  }
  var a = fa._0;
  if (fb.TAG === /* Ok */0) {
    return {
            TAG: /* Ok */0,
            _0: {
              TAG: /* Both */2,
              _0: a,
              _1: fb._0
            }
          };
  } else {
    return {
            TAG: /* Ok */0,
            _0: {
              TAG: /* This */0,
              _0: a
            }
          };
  }
}

function alignWith(f, fa, fb) {
  return map(f, align(fa, fb));
}

function catchError(f, fa) {
  if (fa.TAG === /* Ok */0) {
    return fa;
  } else {
    return Curry._1(f, fa._0);
  }
}

function handleError(eToA, fa) {
  if (fa.TAG === /* Ok */0) {
    return fa;
  } else {
    return {
            TAG: /* Ok */0,
            _0: Curry._1(eToA, fa._0)
          };
  }
}

function mapHandleError(aToB, eToB, ioAE) {
  return handleError(eToB, map(aToB, ioAE));
}

function recover(a, fa) {
  return catchError((function (param) {
                return {
                        TAG: /* Ok */0,
                        _0: a
                      };
              }), fa);
}

function fromOption(defaultError, opt) {
  if (opt !== undefined) {
    return {
            TAG: /* Ok */0,
            _0: Caml_option.valFromOption(opt)
          };
  } else {
    return {
            TAG: /* Error */1,
            _0: defaultError
          };
  }
}

function fromOptionLazy(getError, opt) {
  if (opt !== undefined) {
    return {
            TAG: /* Ok */0,
            _0: Caml_option.valFromOption(opt)
          };
  } else {
    return {
            TAG: /* Error */1,
            _0: Curry._1(getError, undefined)
          };
  }
}

function eqBy(errorEq, okEq, a, b) {
  if (a.TAG === /* Ok */0) {
    if (b.TAG === /* Ok */0) {
      return Curry._2(okEq, a._0, b._0);
    } else {
      return false;
    }
  } else if (b.TAG === /* Ok */0) {
    return false;
  } else {
    return Curry._2(errorEq, a._0, b._0);
  }
}

function tries(fn) {
  try {
    return {
            TAG: /* Ok */0,
            _0: Curry._1(fn, undefined)
          };
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    return {
            TAG: /* Error */1,
            _0: exn
          };
  }
}

function triesAsString(fn) {
  var f = function (prim) {
    return String(prim);
  };
  var ra = tries(fn);
  if (ra.TAG === /* Ok */0) {
    return ra;
  } else {
    return {
            TAG: /* Error */1,
            _0: Curry._1(f, ra._0)
          };
  }
}

function toValidationNel(value) {
  if (value.TAG === /* Ok */0) {
    return {
            TAG: /* VOk */0,
            _0: value._0
          };
  } else {
    return {
            TAG: /* VError */1,
            _0: Relude__Relude_NonEmpty.List.pure(value._0)
          };
  }
}

function toValidationNea(value) {
  if (value.TAG === /* Ok */0) {
    return {
            TAG: /* VOk */0,
            _0: value._0
          };
  } else {
    return {
            TAG: /* VError */1,
            _0: Relude__Relude_NonEmpty.$$Array.pure(value._0)
          };
  }
}

var Bifunctor = {
  bimap: bimap
};

var include = Relude__Relude_Extensions_Bifunctor.BifunctorExtensions(Bifunctor);

var bifold_left = Bastet__Result.Bifoldable.bifold_left;

var bifold_right = Bastet__Result.Bifoldable.bifold_right;

var Bifoldable_Fold_Map = Bastet__Result.Bifoldable.Fold_Map;

var Bifoldable_Fold_Map_Any = Bastet__Result.Bifoldable.Fold_Map_Any;

var Bifoldable_Fold_Map_Plus = Bastet__Result.Bifoldable.Fold_Map_Plus;

var Bifoldable = {
  bifold_left: bifold_left,
  bifold_right: bifold_right,
  Fold_Map: Bifoldable_Fold_Map,
  Fold_Map_Any: Bifoldable_Fold_Map_Any,
  Fold_Map_Plus: Bifoldable_Fold_Map_Plus
};

Relude__Relude_Extensions_Bifoldable.BifoldableExtensions(Bifoldable);

function WithError(E) {
  var Functor = {
    map: map
  };
  var include = Relude__Relude_Extensions_Functor.FunctorExtensions(Functor);
  var Alt = {
    map: map,
    alt: alt
  };
  var include$1 = Relude__Relude_Extensions_Alt.AltExtensions(Alt);
  var Apply = {
    map: map,
    apply: apply
  };
  var include$2 = Relude__Relude_Extensions_Apply.ApplyExtensions(Apply);
  var Applicative = {
    map: map,
    apply: apply,
    pure: pure
  };
  var include$3 = Relude__Relude_Extensions_Applicative.ApplicativeExtensions(Applicative);
  var Semialign = {
    map: map,
    align: align,
    alignWith: alignWith
  };
  Relude__Relude_Extensions_Semialign.SemialignExtensions(Semialign);
  var Monad = {
    map: map,
    apply: apply,
    pure: pure,
    flat_map: bind
  };
  var include$4 = Relude__Relude_Extensions_Monad.MonadExtensions(Monad);
  var MonadThrow = {
    map: map,
    apply: apply,
    pure: pure,
    flat_map: bind,
    throwError: error
  };
  Relude__Relude_Extensions_MonadThrow.MonadThrowExtensions(MonadThrow);
  var MonadError = {
    map: map,
    apply: apply,
    pure: pure,
    flat_map: bind,
    throwError: error,
    catchError: catchError
  };
  Relude__Relude_Extensions_MonadError.MonadErrorExtensions(MonadError);
  var Semigroupoid = {
    compose: compose
  };
  var include$5 = Relude__Relude_Extensions_Semigroupoid.SemigroupoidExtensions(Semigroupoid);
  var include$6 = Bastet__Result.Foldable(E);
  var fold_left = include$6.fold_left;
  var fold_right = include$6.fold_right;
  var Foldable_Fold_Map = include$6.Fold_Map;
  var Foldable_Fold_Map_Any = include$6.Fold_Map_Any;
  var Foldable_Fold_Map_Plus = include$6.Fold_Map_Plus;
  var Foldable = {
    fold_left: fold_left,
    fold_right: fold_right,
    Fold_Map: Foldable_Fold_Map,
    Fold_Map_Any: Foldable_Fold_Map_Any,
    Fold_Map_Plus: Foldable_Fold_Map_Plus
  };
  var include$7 = Relude__Relude_Extensions_Foldable.FoldableExtensions(Foldable);
  var WithApplicative = function (A) {
    var include = Bastet__Result.Traversable(E, A);
    var traverse = include.traverse;
    var sequence = include.sequence;
    var Traversable_map = include.map;
    var Traversable_fold_left = include.fold_left;
    var Traversable_fold_right = include.fold_right;
    var Traversable_Fold_Map = include.Fold_Map;
    var Traversable_Fold_Map_Any = include.Fold_Map_Any;
    var Traversable_Fold_Map_Plus = include.Fold_Map_Plus;
    var Traversable = {
      map: Traversable_map,
      fold_left: Traversable_fold_left,
      fold_right: Traversable_fold_right,
      Fold_Map: Traversable_Fold_Map,
      Fold_Map_Any: Traversable_Fold_Map_Any,
      Fold_Map_Plus: Traversable_Fold_Map_Plus,
      traverse: traverse,
      sequence: sequence
    };
    Relude__Relude_Extensions_Traversable.TraversableExtensions(Traversable);
    var include$1 = Bastet__Result.Bitraversable(A);
    var bitraverse = include$1.bitraverse;
    var bisequence = include$1.bisequence;
    var Bitraversable_bimap = include$1.bimap;
    var Bitraversable_bifold_left = include$1.bifold_left;
    var Bitraversable_bifold_right = include$1.bifold_right;
    var Bitraversable_Fold_Map = include$1.Fold_Map;
    var Bitraversable_Fold_Map_Any = include$1.Fold_Map_Any;
    var Bitraversable_Fold_Map_Plus = include$1.Fold_Map_Plus;
    var Bitraversable = {
      bimap: Bitraversable_bimap,
      bifold_left: Bitraversable_bifold_left,
      bifold_right: Bitraversable_bifold_right,
      Fold_Map: Bitraversable_Fold_Map,
      Fold_Map_Any: Bitraversable_Fold_Map_Any,
      Fold_Map_Plus: Bitraversable_Fold_Map_Plus,
      bitraverse: bitraverse,
      bisequence: bisequence
    };
    Relude__Relude_Extensions_Bitraversable.BitraversableExtensions(Bitraversable);
    return {
            Traversable: Traversable,
            traverse: traverse,
            sequence: sequence,
            Bitraversable: Bitraversable,
            bitraverse: bitraverse,
            bisequence: bisequence
          };
  };
  var include$8 = Relude__Relude_Extensions_Functor.FunctorInfix(Functor);
  var include$9 = Relude__Relude_Extensions_Bifunctor.BifunctorInfix(Bifunctor);
  var include$10 = Relude__Relude_Extensions_Apply.ApplyInfix(Apply);
  var include$11 = Relude__Relude_Extensions_Monad.MonadInfix(Monad);
  var include$12 = Relude__Relude_Extensions_Semigroupoid.SemigroupoidInfix(Semigroupoid);
  var Infix_FunctorExtensions = include$8.FunctorExtensions;
  var Infix_$less$$great = include$8.$less$$great;
  var Infix_$less$$$great = include$8.$less$$$great;
  var Infix_$less$ = include$8.$less$;
  var Infix_$$great = include$8.$$great;
  var Infix_$less$at$great = include$8.$less$at$great;
  var Infix_$less$less$$great$great = include$9.$less$less$$great$great;
  var Infix_ApplyExtensions = include$10.ApplyExtensions;
  var Infix_$less$star$great = include$10.$less$star$great;
  var Infix_$less$star = include$10.$less$star;
  var Infix_$star$great = include$10.$star$great;
  var Infix_MonadExtensions = include$11.MonadExtensions;
  var Infix_$great$great$eq = include$11.$great$great$eq;
  var Infix_$eq$less$less = include$11.$eq$less$less;
  var Infix_$great$eq$great = include$11.$great$eq$great;
  var Infix_$less$eq$less = include$11.$less$eq$less;
  var Infix_SE = include$12.SE;
  var Infix_$less$less$less = include$12.$less$less$less;
  var Infix_$great$great$great = include$12.$great$great$great;
  var Infix = {
    FunctorExtensions: Infix_FunctorExtensions,
    $less$$great: Infix_$less$$great,
    $less$$$great: Infix_$less$$$great,
    $less$: Infix_$less$,
    $$great: Infix_$$great,
    $less$at$great: Infix_$less$at$great,
    $less$less$$great$great: Infix_$less$less$$great$great,
    ApplyExtensions: Infix_ApplyExtensions,
    $less$star$great: Infix_$less$star$great,
    $less$star: Infix_$less$star,
    $star$great: Infix_$star$great,
    MonadExtensions: Infix_MonadExtensions,
    $great$great$eq: Infix_$great$great$eq,
    $eq$less$less: Infix_$eq$less$less,
    $great$eq$great: Infix_$great$eq$great,
    $less$eq$less: Infix_$less$eq$less,
    SE: Infix_SE,
    $less$less$less: Infix_$less$less$less,
    $great$great$great: Infix_$great$great$great
  };
  return {
          Functor: Functor,
          map: map,
          BsFunctorExtensions: include.BsFunctorExtensions,
          flipMap: include.flipMap,
          $$void: include.$$void,
          voidRight: include.voidRight,
          voidLeft: include.voidLeft,
          flap: include.flap,
          Alt: Alt,
          alt: alt,
          orElse: include$1.orElse,
          Apply: Apply,
          apply: apply,
          BsApplyExtensions: include$2.BsApplyExtensions,
          applyFirst: include$2.applyFirst,
          applySecond: include$2.applySecond,
          map2: include$2.map2,
          map3: include$2.map3,
          map4: include$2.map4,
          map5: include$2.map5,
          tuple2: include$2.tuple2,
          tuple3: include$2.tuple3,
          tuple4: include$2.tuple4,
          tuple5: include$2.tuple5,
          mapTuple2: include$2.mapTuple2,
          mapTuple3: include$2.mapTuple3,
          mapTuple4: include$2.mapTuple4,
          mapTuple5: include$2.mapTuple5,
          Applicative: Applicative,
          pure: pure,
          BsApplicativeExtensions: include$3.BsApplicativeExtensions,
          liftA1: include$3.liftA1,
          Semialign: Semialign,
          Monad: Monad,
          bind: bind,
          BsMonadExtensions: include$4.BsMonadExtensions,
          flatMap: include$4.flatMap,
          flatten: include$4.flatten,
          composeKleisli: include$4.composeKleisli,
          flipComposeKleisli: include$4.flipComposeKleisli,
          liftM1: include$4.liftM1,
          when_: include$4.when_,
          unless: include$4.unless,
          MonadThrow: MonadThrow,
          throwError: error,
          MonadError: MonadError,
          catchError: catchError,
          Semigroupoid: Semigroupoid,
          compose: compose,
          andThen: include$5.andThen,
          Foldable: Foldable,
          foldLeft: fold_left,
          foldRight: fold_right,
          BsFoldableExtensions: include$7.BsFoldableExtensions,
          any: include$7.any,
          all: include$7.all,
          containsBy: include$7.containsBy,
          contains: include$7.contains,
          indexOfBy: include$7.indexOfBy,
          indexOf: include$7.indexOf,
          minBy: include$7.minBy,
          min: include$7.min,
          maxBy: include$7.maxBy,
          max: include$7.max,
          countBy: include$7.countBy,
          length: include$7.length,
          size: include$7.size,
          count: include$7.count,
          forEach: include$7.forEach,
          forEachWithIndex: include$7.forEachWithIndex,
          find: include$7.find,
          findWithIndex: include$7.findWithIndex,
          toList: include$7.toList,
          toArray: include$7.toArray,
          FoldableSemigroupExtensions: include$7.FoldableSemigroupExtensions,
          FoldableMonoidExtensions: include$7.FoldableMonoidExtensions,
          foldMap: include$7.foldMap,
          foldWithMonoid: include$7.foldWithMonoid,
          intercalate: include$7.intercalate,
          FoldableApplicativeExtensions: include$7.FoldableApplicativeExtensions,
          FoldableMonadExtensions: include$7.FoldableMonadExtensions,
          FoldableEqExtensions: include$7.FoldableEqExtensions,
          FoldableOrdExtensions: include$7.FoldableOrdExtensions,
          WithApplicative: WithApplicative,
          Infix: Infix
        };
}

var unit = {
  TAG: /* Ok */0,
  _0: undefined
};

var toOption = getOk;

var mapOk = map;

var tapOk = tap;

var toValidation = Relude__Relude_Validation.fromResult;

var fromValidation = Relude__Relude_Validation.toResult;

var mapLeft = include.mapLeft;

var mapRight = include.mapRight;

var mapError = include.mapError;

var bifoldLeft = bifold_left;

var bifoldRight = bifold_right;

exports.ok = ok;
exports.error = error;
exports.unit = unit;
exports.getOk = getOk;
exports.toOption = toOption;
exports.getError = getError;
exports.isOk = isOk;
exports.isError = isError;
exports.fold = fold;
exports.getOrElse = getOrElse;
exports.getOrElseBy = getOrElseBy;
exports.getOrElseLazy = getOrElseLazy;
exports.getErrorOrElse = getErrorOrElse;
exports.getErrorOrElseBy = getErrorOrElseBy;
exports.merge = merge;
exports.flip = flip;
exports.compose = compose;
exports.andThen = andThen;
exports.map = map;
exports.mapOk = mapOk;
exports.tap = tap;
exports.tapOk = tapOk;
exports.tapError = tapError;
exports.apply = apply;
exports.map2 = map2;
exports.map3 = map3;
exports.map4 = map4;
exports.map5 = map5;
exports.pure = pure;
exports.bind = bind;
exports.flatMap = flatMap;
exports.flatten = flatten;
exports.alt = alt;
exports.align = align;
exports.alignWith = alignWith;
exports.catchError = catchError;
exports.handleError = handleError;
exports.mapHandleError = mapHandleError;
exports.recover = recover;
exports.fromOption = fromOption;
exports.fromOptionLazy = fromOptionLazy;
exports.eqBy = eqBy;
exports.tries = tries;
exports.triesAsString = triesAsString;
exports.toValidation = toValidation;
exports.fromValidation = fromValidation;
exports.toValidationNel = toValidationNel;
exports.toValidationNea = toValidationNea;
exports.Bifunctor = Bifunctor;
exports.bimap = bimap;
exports.mapLeft = mapLeft;
exports.mapRight = mapRight;
exports.mapError = mapError;
exports.Bifoldable = Bifoldable;
exports.bifoldLeft = bifoldLeft;
exports.bifoldRight = bifoldRight;
exports.WithError = WithError;
/* include Not a pure module */
