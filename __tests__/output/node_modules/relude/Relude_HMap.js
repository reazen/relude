// Generated by Melange
'use strict';

var Caml = require("melange.runtime/caml.js");
var Curry = require("melange.runtime/curry.js");
var Stdlib = require("melange/./stdlib.js");
var Caml_option = require("melange.runtime/caml_option.js");
var Stdlib__Map = require("melange/./map.js");
var Caml_exceptions = require("melange.runtime/caml_exceptions.js");
var Caml_js_exceptions = require("melange.runtime/caml_js_exceptions.js");

var Witness = {};

function makeWitness(param) {
  var Witness = /* @__PURE__ */Caml_exceptions.create("Witness");
  return {
          Witness: Witness
        };
}

function typeEq(l, r) {
  if (l.Witness === r.Witness) {
    return /* TypeEq */0;
  }
  
}

function WithKeyMeta(KeyMeta) {
  var id = {
    contents: -1
  };
  var create = function (keyMeta) {
    id.contents = id.contents + 1 | 0;
    var intId = id.contents;
    var Witness = /* @__PURE__ */Caml_exceptions.create("Witness");
    var witness = {
      Witness: Witness
    };
    return {
            intId: intId,
            witness: witness,
            keyMeta: keyMeta
          };
  };
  var keyMeta = function (keyData) {
    return keyData.keyMeta;
  };
  var hideType = function (k) {
    return /* Key */{
            _0: k
          };
  };
  var eq = function (a, b) {
    return a._0.intId === b._0.intId;
  };
  var compare = function (a, b) {
    return Caml.caml_int_compare(a._0.intId, b._0.intId);
  };
  var HMap = Stdlib__Map.Make({
        compare: compare
      });
  var hasKey = function (k, m) {
    return Curry._2(HMap.mem, /* Key */{
                _0: k
              }, m);
  };
  var add = function (k, v, m) {
    return Curry._3(HMap.add, /* Key */{
                _0: k
              }, /* KeyValue */{
                _0: k,
                _1: v
              }, m);
  };
  var singleton = function (k, v) {
    return Curry._2(HMap.singleton, /* Key */{
                _0: k
              }, /* KeyValue */{
                _0: k,
                _1: v
              });
  };
  var remove = function (k, m) {
    return Curry._2(HMap.remove, /* Key */{
                _0: k
              }, m);
  };
  var find = function (k, s) {
    try {
      var match = Curry._2(HMap.find, /* Key */{
            _0: k
          }, s);
      var match$1 = typeEq(k.witness, match._0.witness);
      if (match$1 !== undefined) {
        return Caml_option.some(match._1);
      } else {
        return ;
      }
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === Stdlib.Not_found) {
        return ;
      }
      throw exn;
    }
  };
  var forEach = function (f, m) {
    Curry._2(HMap.iter, (function (_key, value) {
            Curry._1(f, value);
          }), m);
  };
  var fold = function (f, acc, m) {
    return Curry._3(HMap.fold, (function (_key, value, acc) {
                  return Curry._2(f, value, acc);
                }), m, acc);
  };
  var all = function (p, m) {
    return Curry._2(HMap.for_all, (function (param, b) {
                  return Curry._1(p, b);
                }), m);
  };
  var any = function (p, m) {
    return Curry._2(HMap.exists, (function (param, b) {
                  return Curry._1(p, b);
                }), m);
  };
  var filter = function (p, m) {
    return Curry._2(HMap.filter, (function (param, b) {
                  return Curry._1(p, b);
                }), m);
  };
  var size = function (m) {
    return Curry._1(HMap.cardinal, m);
  };
  return {
          Key: {
            create: create,
            keyMeta: keyMeta,
            hideType: hideType,
            eq: eq,
            compare: compare
          },
          empty: HMap.empty,
          isEmpty: HMap.is_empty,
          hasKey: hasKey,
          add: add,
          singleton: singleton,
          remove: remove,
          find: find,
          forEach: forEach,
          fold: fold,
          all: all,
          any: any,
          filter: filter,
          size: size
        };
}

var id = {
  contents: -1
};

function create(keyMeta) {
  id.contents = id.contents + 1 | 0;
  var intId = id.contents;
  var Witness = /* @__PURE__ */Caml_exceptions.create("Witness");
  var witness = {
    Witness: Witness
  };
  return {
          intId: intId,
          witness: witness,
          keyMeta: keyMeta
        };
}

function keyMeta(keyData) {
  return keyData.keyMeta;
}

function hideType(k) {
  return /* Key */{
          _0: k
        };
}

function eq(a, b) {
  return a._0.intId === b._0.intId;
}

function compare(a, b) {
  return Caml.caml_int_compare(a._0.intId, b._0.intId);
}

var HMap = Stdlib__Map.Make({
      compare: compare
    });

var empty = HMap.empty;

var isEmpty = HMap.is_empty;

function hasKey(k, m) {
  return Curry._2(HMap.mem, /* Key */{
              _0: k
            }, m);
}

function add(k, v, m) {
  return Curry._3(HMap.add, /* Key */{
              _0: k
            }, /* KeyValue */{
              _0: k,
              _1: v
            }, m);
}

function singleton(k, v) {
  return Curry._2(HMap.singleton, /* Key */{
              _0: k
            }, /* KeyValue */{
              _0: k,
              _1: v
            });
}

function remove(k, m) {
  return Curry._2(HMap.remove, /* Key */{
              _0: k
            }, m);
}

function find(k, s) {
  try {
    var match = Curry._2(HMap.find, /* Key */{
          _0: k
        }, s);
    var match$1 = typeEq(k.witness, match._0.witness);
    if (match$1 !== undefined) {
      return Caml_option.some(match._1);
    } else {
      return ;
    }
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Stdlib.Not_found) {
      return ;
    }
    throw exn;
  }
}

function forEach(f, m) {
  Curry._2(HMap.iter, (function (_key, value) {
          Curry._1(f, value);
        }), m);
}

function fold(f, acc, m) {
  return Curry._3(HMap.fold, (function (_key, value, acc) {
                return Curry._2(f, value, acc);
              }), m, acc);
}

function all(p, m) {
  return Curry._2(HMap.for_all, (function (param, b) {
                return Curry._1(p, b);
              }), m);
}

function any(p, m) {
  return Curry._2(HMap.exists, (function (param, b) {
                return Curry._1(p, b);
              }), m);
}

function filter(p, m) {
  return Curry._2(HMap.filter, (function (param, b) {
                return Curry._1(p, b);
              }), m);
}

function size(m) {
  return Curry._1(HMap.cardinal, m);
}

var WithKeyMetaUnit_Key = {
  create: create,
  keyMeta: keyMeta,
  hideType: hideType,
  eq: eq,
  compare: compare
};

var WithKeyMetaUnit = {
  Key: WithKeyMetaUnit_Key,
  empty: empty,
  isEmpty: isEmpty,
  hasKey: hasKey,
  add: add,
  singleton: singleton,
  remove: remove,
  find: find,
  forEach: forEach,
  fold: fold,
  all: all,
  any: any,
  filter: filter,
  size: size
};

var Key = WithKeyMetaUnit_Key;

exports.Witness = Witness;
exports.makeWitness = makeWitness;
exports.typeEq = typeEq;
exports.WithKeyMeta = WithKeyMeta;
exports.WithKeyMetaUnit = WithKeyMetaUnit;
exports.Key = Key;
exports.empty = empty;
exports.isEmpty = isEmpty;
exports.hasKey = hasKey;
exports.add = add;
exports.singleton = singleton;
exports.remove = remove;
exports.find = find;
exports.forEach = forEach;
exports.fold = fold;
exports.all = all;
exports.any = any;
exports.filter = filter;
exports.size = size;
/* HMap Not a pure module */
