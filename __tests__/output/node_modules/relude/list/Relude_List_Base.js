// Generated by Melange
'use strict';

var Curry = require("melange.runtime/curry.js");
var Belt_List = require("melange.belt/./belt_List.js");
var Caml_option = require("melange.runtime/caml_option.js");
var Relude__Relude_Ordering = require("../Relude_Ordering.js");
var Relude__Relude_Option_Base = require("../option/Relude_Option_Base.js");
var Relude__Relude_List_Instances = require("./Relude_List_Instances.js");
var Relude__Relude_Option_Instances = require("../option/Relude_Option_Instances.js");

function cons(x, xs) {
  return {
          hd: x,
          tl: xs
        };
}

function consOption(x, xs) {
  return Relude__Relude_Option_Base.fold(xs, (function (x) {
                return {
                        hd: x,
                        tl: xs
                      };
              }), x);
}

function uncons(param) {
  if (param) {
    return [
            param.hd,
            param.tl
          ];
  }
  
}

function append(x, xs) {
  return Relude__Relude_List_Instances.SemigroupAny.append(xs, {
              hd: x,
              tl: /* [] */0
            });
}

function appendOption(x, xs) {
  return Relude__Relude_Option_Base.fold(xs, (function (__x) {
                return append(__x, xs);
              }), x);
}

var repeat = Belt_List.make;

function mapWithIndex(f, xs) {
  return Belt_List.mapWithIndex(xs, (function (i, x) {
                return Curry._2(f, x, i);
              }));
}

function isEmpty(param) {
  if (param) {
    return false;
  } else {
    return true;
  }
}

function isNotEmpty(xs) {
  return !(
          xs ? false : true
        );
}

function at(i, xs) {
  return Belt_List.get(xs, i);
}

function head(param) {
  if (param) {
    return Caml_option.some(param.hd);
  }
  
}

function tail(param) {
  if (param) {
    return param.tl;
  }
  
}

function tailOrEmpty(xs) {
  return Relude__Relude_Option_Base.getOrElse(/* [] */0, tail(xs));
}

function init(param) {
  if (param) {
    if (param.tl) {
      return {
              hd: param.hd,
              tl: Relude__Relude_Option_Base.getOrElse(/* [] */0, init(param.tl))
            };
    } else {
      return /* [] */0;
    }
  }
  
}

function initOrEmpty(xs) {
  var ys = init(xs);
  if (ys !== undefined) {
    return ys;
  } else {
    return /* [] */0;
  }
}

function last(_param) {
  while(true) {
    var param = _param;
    if (!param) {
      return ;
    }
    if (!param.tl) {
      return Caml_option.some(param.hd);
    }
    _param = param.tl;
    continue ;
  };
}

function take(i, xs) {
  var go = function (_acc, _count, _rest) {
    while(true) {
      var rest = _rest;
      var count = _count;
      var acc = _acc;
      if (count <= 0) {
        return acc;
      }
      if (!rest) {
        return acc;
      }
      _rest = rest.tl;
      _count = count - 1 | 0;
      _acc = {
        hd: rest.hd,
        tl: acc
      };
      continue ;
    };
  };
  return Belt_List.reverse(go(/* [] */0, i, xs));
}

function takeExactly(i, xs) {
  var go = function (_acc, _count, _rest) {
    while(true) {
      var rest = _rest;
      var count = _count;
      var acc = _acc;
      if (count <= 0) {
        return acc;
      }
      if (!rest) {
        return ;
      }
      _rest = rest.tl;
      _count = count - 1 | 0;
      _acc = {
        hd: rest.hd,
        tl: acc
      };
      continue ;
    };
  };
  if (i >= 0) {
    return Relude__Relude_Option_Instances.map(Belt_List.reverse, go(/* [] */0, i, xs));
  }
  
}

function takeWhile(f, xs) {
  var go = function (_acc, _rest) {
    while(true) {
      var rest = _rest;
      var acc = _acc;
      if (!rest) {
        return acc;
      }
      var y = rest.hd;
      if (!Curry._1(f, y)) {
        return acc;
      }
      _rest = rest.tl;
      _acc = {
        hd: y,
        tl: acc
      };
      continue ;
    };
  };
  return Belt_List.reverse(go(/* [] */0, xs));
}

function drop(_i, _xs) {
  while(true) {
    var xs = _xs;
    var i = _i;
    if (!xs) {
      return /* [] */0;
    }
    if (i <= 0) {
      return xs;
    }
    _xs = xs.tl;
    _i = i - 1 | 0;
    continue ;
  };
}

function dropExactly(i, xs) {
  return Belt_List.drop(xs, i);
}

function dropWhile(f, _xs) {
  while(true) {
    var xs = _xs;
    if (!xs) {
      return xs;
    }
    if (!Curry._1(f, xs.hd)) {
      return xs;
    }
    _xs = xs.tl;
    continue ;
  };
}

function filter(f, xs) {
  return Belt_List.keep(xs, f);
}

function filterWithIndex(f, xs) {
  return Belt_List.keepWithIndex(xs, f);
}

function filterNot(f) {
  return function (param) {
    return Belt_List.keep(param, (function (a) {
                  return !Curry._1(f, a);
                }));
  };
}

function filterNotWithIndex(f) {
  return function (param) {
    return Belt_List.keepWithIndex(param, (function (a, i) {
                  return !Curry._2(f, a, i);
                }));
  };
}

function mapOption(f, xs) {
  return Belt_List.reverse(Relude__Relude_List_Instances.foldLeft((function (acc, curr) {
                      return Relude__Relude_Option_Base.fold(acc, (function (v) {
                                    return {
                                            hd: v,
                                            tl: acc
                                          };
                                  }), Curry._1(f, curr));
                    }), /* [] */0)(xs));
}

function catOptions(xs) {
  return mapOption((function (a) {
                return a;
              }), xs);
}

function partition(f, xs) {
  return Belt_List.partition(xs, f);
}

function splitAt(i, xs) {
  return Belt_List.splitAt(xs, i);
}

function prependToAll(delim, xs) {
  var go = function (_acc, _param) {
    while(true) {
      var param = _param;
      var acc = _acc;
      if (!param) {
        return acc;
      }
      _param = param.tl;
      _acc = {
        hd: param.hd,
        tl: {
          hd: delim,
          tl: acc
        }
      };
      continue ;
    };
  };
  return Belt_List.reverse(go(/* [] */0, xs));
}

function intersperse(delim, xs) {
  if (xs) {
    return {
            hd: xs.hd,
            tl: prependToAll(delim, xs.tl)
          };
  } else {
    return /* [] */0;
  }
}

function replicate(i, xs) {
  if (i <= 0) {
    return /* [] */0;
  } else {
    var _count = i;
    var _acc = xs;
    while(true) {
      var acc = _acc;
      var count = _count;
      if (count <= 1) {
        return acc;
      }
      _acc = Relude__Relude_List_Instances.concat(xs, acc);
      _count = count - 1 | 0;
      continue ;
    };
  }
}

function zipWith(f, xs, ys) {
  return Belt_List.zipBy(xs, ys, f);
}

function zipWithIndex(xs) {
  return mapWithIndex((function (v, i) {
                return [
                        v,
                        i
                      ];
              }), xs);
}

function sortWithInt(f, xs) {
  return Belt_List.sort(xs, f);
}

function sortBy(f, xs) {
  return Belt_List.sort(xs, (function (a, b) {
                return Relude__Relude_Ordering.toInt(Curry._2(f, a, b));
              }));
}

function sort(ordA, xs) {
  return sortBy(ordA.compare, xs);
}

function distinctBy(eq, xs) {
  return Belt_List.reverse(Relude__Relude_List_Instances.foldLeft((function (ys, x) {
                      if (Curry._3(Relude__Relude_List_Instances.containsBy, eq, x, ys)) {
                        return ys;
                      } else {
                        return {
                                hd: x,
                                tl: ys
                              };
                      }
                    }), /* [] */0)(xs));
}

function removeFirstBy(innerEq, v, xs) {
  var go = function (param, x) {
    var ys = param[1];
    if (param[0]) {
      return [
              true,
              {
                hd: x,
                tl: ys
              }
            ];
    } else if (Curry._2(innerEq, v, x)) {
      return [
              true,
              ys
            ];
    } else {
      return [
              false,
              {
                hd: x,
                tl: ys
              }
            ];
    }
  };
  return Belt_List.reverse(Relude__Relude_List_Instances.foldLeft(go, [
                      false,
                      /* [] */0
                    ])(xs)[1]);
}

function removeEachBy(innerEq, x, xs) {
  return Belt_List.reverse(Relude__Relude_List_Instances.foldLeft((function (ys, y) {
                      if (Curry._2(innerEq, x, y)) {
                        return ys;
                      } else {
                        return {
                                hd: y,
                                tl: ys
                              };
                      }
                    }), /* [] */0)(xs));
}

function distinct(eqA, xs) {
  return distinctBy(eqA.eq, xs);
}

function removeFirst(eqA, x, xs) {
  return removeFirstBy(eqA.eq, x, xs);
}

function removeEach(eqA, x, xs) {
  return removeEachBy(eqA.eq, x, xs);
}

function replaceAt(targetIndex, newX, xs) {
  return mapWithIndex((function (x, currentIndex) {
                if (currentIndex === targetIndex) {
                  return newX;
                } else {
                  return x;
                }
              }), xs);
}

function scanLeft(f, init, xs) {
  return Belt_List.reverse(Relude__Relude_List_Instances.foldLeft((function (param, curr) {
                        var nextAcc = Curry._2(f, param[0], curr);
                        return [
                                nextAcc,
                                {
                                  hd: nextAcc,
                                  tl: param[1]
                                }
                              ];
                      }), [
                      init,
                      /* [] */0
                    ])(xs)[1]);
}

function scanRight(f, init, xs) {
  return Relude__Relude_List_Instances.foldRight((function (curr, param) {
                    var nextAcc = Curry._2(f, curr, param[0]);
                    return [
                            nextAcc,
                            {
                              hd: nextAcc,
                              tl: param[1]
                            }
                          ];
                  }), [
                  init,
                  /* [] */0
                ])(xs)[1];
}

function insertAt(targetIndex, newX, xs) {
  var match = Belt_List.splitAt(xs, targetIndex);
  if (match !== undefined) {
    return Relude__Relude_List_Instances.concat(match[0], {
                hd: newX,
                tl: match[1]
              });
  } else {
    return xs;
  }
}

function updateAt(targetIndex, f, xs) {
  return mapWithIndex((function (x, index) {
                if (index === targetIndex) {
                  return Curry._1(f, x);
                } else {
                  return x;
                }
              }), xs);
}

function swapAt(i, j, xs) {
  var match = Belt_List.get(xs, i);
  var match$1 = Belt_List.get(xs, j);
  if (match === undefined) {
    return xs;
  }
  if (match$1 === undefined) {
    return xs;
  }
  var b = Caml_option.valFromOption(match$1);
  var a = Caml_option.valFromOption(match);
  return mapWithIndex((function (x, k) {
                if (i === k) {
                  return b;
                } else if (j === k) {
                  return a;
                } else {
                  return x;
                }
              }), xs);
}

function removeAt(targetIndex, xs) {
  return Belt_List.keepWithIndex(xs, (function (param, i) {
                return i !== targetIndex;
              }));
}

function chunk(size, xs) {
  if (Curry._1(Relude__Relude_List_Instances.length, xs) <= size) {
    return {
            hd: xs,
            tl: /* [] */0
          };
  } else {
    return {
            hd: take(size, xs),
            tl: chunk(size, drop(size, xs))
          };
  }
}

var prepend = cons;

var makeWithIndex = Belt_List.makeBy;

var reverse = Belt_List.reverse;

var shuffle = Belt_List.shuffle;

var keep = filter;

var keepWithIndex = filterWithIndex;

var reject = filterNot;

var rejectWithIndex = filterNotWithIndex;

var zip = Belt_List.zip;

var unzip = Belt_List.unzip;

exports.cons = cons;
exports.consOption = consOption;
exports.prepend = prepend;
exports.uncons = uncons;
exports.append = append;
exports.appendOption = appendOption;
exports.repeat = repeat;
exports.makeWithIndex = makeWithIndex;
exports.mapWithIndex = mapWithIndex;
exports.reverse = reverse;
exports.shuffle = shuffle;
exports.isEmpty = isEmpty;
exports.isNotEmpty = isNotEmpty;
exports.at = at;
exports.head = head;
exports.tail = tail;
exports.tailOrEmpty = tailOrEmpty;
exports.init = init;
exports.initOrEmpty = initOrEmpty;
exports.last = last;
exports.take = take;
exports.takeExactly = takeExactly;
exports.takeWhile = takeWhile;
exports.drop = drop;
exports.dropExactly = dropExactly;
exports.dropWhile = dropWhile;
exports.filter = filter;
exports.keep = keep;
exports.filterWithIndex = filterWithIndex;
exports.keepWithIndex = keepWithIndex;
exports.filterNot = filterNot;
exports.reject = reject;
exports.filterNotWithIndex = filterNotWithIndex;
exports.rejectWithIndex = rejectWithIndex;
exports.mapOption = mapOption;
exports.catOptions = catOptions;
exports.partition = partition;
exports.splitAt = splitAt;
exports.prependToAll = prependToAll;
exports.intersperse = intersperse;
exports.replicate = replicate;
exports.zip = zip;
exports.zipWith = zipWith;
exports.zipWithIndex = zipWithIndex;
exports.unzip = unzip;
exports.sortWithInt = sortWithInt;
exports.sortBy = sortBy;
exports.sort = sort;
exports.distinctBy = distinctBy;
exports.removeFirstBy = removeFirstBy;
exports.removeEachBy = removeEachBy;
exports.distinct = distinct;
exports.removeFirst = removeFirst;
exports.removeEach = removeEach;
exports.replaceAt = replaceAt;
exports.scanLeft = scanLeft;
exports.scanRight = scanRight;
exports.insertAt = insertAt;
exports.updateAt = updateAt;
exports.swapAt = swapAt;
exports.removeAt = removeAt;
exports.chunk = chunk;
/* Relude__Relude_Ordering Not a pure module */
