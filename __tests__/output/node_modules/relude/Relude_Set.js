// Generated by Melange
'use strict';

var Curry = require("melange.runtime/curry.js");
var Belt_Id = require("melange.belt/./belt_Id.js");
var Belt_Set = require("melange.belt/./belt_Set.js");
var Belt_List = require("melange.belt/./belt_List.js");
var Stdlib__Array = require("melange/./array.js");
var Relude__Relude_Ordering = require("./Relude_Ordering.js");
var Relude__Relude_Option_Base = require("./option/Relude_Option_Base.js");

var empty = Belt_Set.make;

function singleton(id, value) {
  return Belt_Set.add(Belt_Set.make(id), value);
}

function fromArray(id, value) {
  return Belt_Set.fromArray(value, id);
}

function fromList(id, value) {
  return Belt_Set.fromArray(Belt_List.toArray(value), id);
}

function contains(value, set) {
  return Belt_Set.has(set, value);
}

function add(value, set) {
  return Belt_Set.add(set, value);
}

function mergeMany(value, set) {
  return Belt_Set.mergeMany(set, value);
}

function remove(value, set) {
  return Belt_Set.remove(set, value);
}

function removeMany(value, set) {
  return Belt_Set.removeMany(set, value);
}

function update(value, set) {
  return Belt_Set.add(Belt_Set.remove(set, value), value);
}

function toggle(value, set) {
  if (Belt_Set.has(set, value)) {
    return Belt_Set.remove(set, value);
  } else {
    return Belt_Set.add(set, value);
  }
}

function forEach(fn, set) {
  Belt_Set.forEach(set, fn);
}

function foldLeft(fn, acc, set) {
  return Belt_Set.reduce(set, acc, fn);
}

function foldRight(fn, acc, set) {
  return Stdlib__Array.fold_right(fn, Belt_Set.toArray(set), acc);
}

function all(predicate, set) {
  return Belt_Set.every(set, predicate);
}

function any(predicate, set) {
  return Belt_Set.some(set, predicate);
}

function filter(predicate, set) {
  return Belt_Set.keep(set, predicate);
}

function filterNot(predicate, set) {
  return Belt_Set.keep(set, (function (x) {
                return !Curry._1(predicate, x);
              }));
}

function partition(predicate, set) {
  return Belt_Set.partition(set, predicate);
}

function get(value, set) {
  return Belt_Set.get(set, value);
}

function getOrElse(value, $$default, set) {
  return Relude__Relude_Option_Base.getOrElse($$default, Belt_Set.get(set, value));
}

function split(value, set) {
  return Belt_Set.split(set, value);
}

function WithOrd(M) {
  var cmp = function (a, b) {
    return Relude__Relude_Ordering.toInt(Curry._2(M.compare, a, b));
  };
  var Comparable = Belt_Id.MakeComparable({
        cmp: cmp
      });
  var empty = Belt_Set.make(Comparable);
  var singleton = function (param) {
    return Belt_Set.add(Belt_Set.make(Comparable), param);
  };
  var fromArray = function (param) {
    return Belt_Set.fromArray(param, Comparable);
  };
  var fromList = function (param) {
    return Belt_Set.fromArray(Belt_List.toArray(param), Comparable);
  };
  return {
          Comparable: {},
          empty: empty,
          singleton: singleton,
          fromArray: fromArray,
          fromList: fromList,
          isEmpty: Belt_Set.isEmpty,
          contains: contains,
          add: add,
          mergeMany: mergeMany,
          remove: remove,
          removeMany: removeMany,
          update: update,
          toggle: toggle,
          union: Belt_Set.union,
          intersect: Belt_Set.intersect,
          diff: Belt_Set.diff,
          subset: Belt_Set.subset,
          compare: Belt_Set.cmp,
          eq: Belt_Set.eq,
          forEach: forEach,
          foldLeft: foldLeft,
          foldRight: foldRight,
          all: all,
          any: any,
          filter: filter,
          keep: filter,
          filterNot: filterNot,
          reject: filterNot,
          partition: partition,
          length: Belt_Set.size,
          toArray: Belt_Set.toArray,
          toList: Belt_Set.toList,
          minimum: Belt_Set.minimum,
          maximum: Belt_Set.maximum,
          get: get,
          getOrElse: getOrElse,
          split: split
        };
}

var isEmpty = Belt_Set.isEmpty;

var union = Belt_Set.union;

var intersect = Belt_Set.intersect;

var diff = Belt_Set.diff;

var subset = Belt_Set.subset;

var compare = Belt_Set.cmp;

var eq = Belt_Set.eq;

var keep = filter;

var reject = filterNot;

var length = Belt_Set.size;

var toArray = Belt_Set.toArray;

var toList = Belt_Set.toList;

var minimum = Belt_Set.minimum;

var maximum = Belt_Set.maximum;

exports.empty = empty;
exports.singleton = singleton;
exports.fromArray = fromArray;
exports.fromList = fromList;
exports.isEmpty = isEmpty;
exports.contains = contains;
exports.add = add;
exports.mergeMany = mergeMany;
exports.remove = remove;
exports.removeMany = removeMany;
exports.update = update;
exports.toggle = toggle;
exports.union = union;
exports.intersect = intersect;
exports.diff = diff;
exports.subset = subset;
exports.compare = compare;
exports.eq = eq;
exports.forEach = forEach;
exports.foldLeft = foldLeft;
exports.foldRight = foldRight;
exports.all = all;
exports.any = any;
exports.filter = filter;
exports.keep = keep;
exports.filterNot = filterNot;
exports.reject = reject;
exports.partition = partition;
exports.length = length;
exports.toArray = toArray;
exports.toList = toList;
exports.minimum = minimum;
exports.maximum = maximum;
exports.get = get;
exports.getOrElse = getOrElse;
exports.split = split;
exports.WithOrd = WithOrd;
/* Relude__Relude_Ordering Not a pure module */
