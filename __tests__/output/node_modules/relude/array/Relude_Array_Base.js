// Generated by Melange
'use strict';

var Curry = require("melange.runtime/curry.js");
var Belt_Array = require("melange.belt/./belt_Array.js");
var Caml_option = require("melange.runtime/caml_option.js");
var Belt_SortArray = require("melange.belt/./belt_SortArray.js");
var Relude__Relude_Int = require("../Relude_Int.js");
var Relude__Relude_Ordering = require("../Relude_Ordering.js");
var Relude__Relude_Option_Base = require("../option/Relude_Option_Base.js");
var Relude__Relude_Array_Instances = require("./Relude_Array_Instances.js");

function cons(x, xs) {
  return Relude__Relude_Array_Instances.concat([x], xs);
}

function uncons(xs) {
  if (xs.length) {
    return [
            Belt_Array.getExn(xs, 0),
            Belt_Array.sliceToEnd(xs, 1)
          ];
  }
  
}

function append(x, xs) {
  return Relude__Relude_Array_Instances.concat(xs, [x]);
}

var repeat = Belt_Array.make;

function mapWithIndex(f, xs) {
  return Belt_Array.mapWithIndex(xs, (function (i, x) {
                return Curry._2(f, x, i);
              }));
}

function shuffleInPlace(xs) {
  Belt_Array.shuffleInPlace(xs);
  return xs;
}

function length(prim) {
  return prim.length;
}

function isEmpty(arr) {
  return arr.length === 0;
}

function isNotEmpty(arr) {
  return arr.length !== 0;
}

function at(i, xs) {
  return Belt_Array.get(xs, i);
}

function setAt(i, x, xs) {
  if (Belt_Array.set(xs, i, x)) {
    return xs;
  }
  
}

function head(arr) {
  return Belt_Array.get(arr, 0);
}

function tail(xs) {
  var l = xs.length;
  if (l === 0) {
    return ;
  }
  if (l === 1) {
    return [];
  }
  var ys = Belt_Array.sliceToEnd(xs, 1);
  if (ys.length !== 0) {
    return ys;
  }
  
}

function tailOrEmpty(xs) {
  var ys = tail(xs);
  if (ys !== undefined) {
    return ys;
  } else {
    return [];
  }
}

function init(xs) {
  var l = xs.length;
  if (l === 0) {
    return ;
  } else {
    return Belt_Array.slice(xs, 0, l - 1 | 0);
  }
}

function initOrEmpty(xs) {
  var arr = init(xs);
  if (arr !== undefined) {
    return arr;
  } else {
    return [];
  }
}

function last(xs) {
  var l = xs.length;
  if (l === 0) {
    return ;
  } else {
    return Belt_Array.get(xs, l - 1 | 0);
  }
}

function take(i, xs) {
  var l = xs.length;
  var len = i < 0 ? 0 : (
      l < i ? l : i
    );
  return Belt_Array.slice(xs, 0, len);
}

function takeExactly(i, xs) {
  if (i < 0 || i > xs.length) {
    return ;
  } else {
    return Belt_Array.slice(xs, 0, i);
  }
}

function takeWhile(f, xs) {
  var x = Belt_Array.get(xs, 0);
  if (x === undefined) {
    return [];
  }
  var x$1 = Caml_option.valFromOption(x);
  if (!Curry._1(f, x$1)) {
    return [];
  }
  var xs$1 = takeWhile(f, tailOrEmpty(xs));
  return Relude__Relude_Array_Instances.concat([x$1], xs$1);
}

function drop(i, xs) {
  var l = xs.length;
  var start = i < 0 ? 0 : (
      l < i ? l : i
    );
  return Belt_Array.sliceToEnd(xs, start);
}

function dropExactly(i, xs) {
  if (i < 0 || i > xs.length) {
    return ;
  } else {
    return Belt_Array.sliceToEnd(xs, i);
  }
}

function dropWhile(f, _xs) {
  while(true) {
    var xs = _xs;
    var x = Belt_Array.get(xs, 0);
    if (x === undefined) {
      return xs;
    }
    if (!Curry._1(f, Caml_option.valFromOption(x))) {
      return xs;
    }
    _xs = tailOrEmpty(xs);
    continue ;
  };
}

function filter(f, xs) {
  return Belt_Array.keep(xs, f);
}

function filterWithIndex(f, xs) {
  return Belt_Array.keepWithIndex(xs, f);
}

function filterNot(f) {
  return function (param) {
    return Belt_Array.keep(param, (function (a) {
                  return !Curry._1(f, a);
                }));
  };
}

function filterNotWithIndex(f) {
  return function (param) {
    return Belt_Array.keepWithIndex(param, (function (a, i) {
                  return !Curry._2(f, a, i);
                }));
  };
}

function mapOption(f, xs) {
  return Curry._3(Relude__Relude_Array_Instances.foldLeft, (function (acc, curr) {
                return Relude__Relude_Option_Base.fold(acc, (function (v) {
                              return Relude__Relude_Array_Instances.concat(acc, [v]);
                            }), Curry._1(f, curr));
              }), [], xs);
}

function catOption(xs) {
  return mapOption((function (v) {
                return v;
              }), xs);
}

function partition(f, xs) {
  return Belt_Array.partition(xs, f);
}

function splitAt(i, xs) {
  if (i < 0 || i > xs.length) {
    return ;
  } else {
    return [
            Belt_Array.slice(xs, 0, i),
            Belt_Array.sliceToEnd(xs, i)
          ];
  }
}

function prependToAll(delim, xs) {
  return Curry._2(Relude__Relude_Array_Instances.flatMap, (function (v) {
                return [
                        delim,
                        v
                      ];
              }), xs);
}

function intersperse(delim, xs) {
  var x = Belt_Array.get(xs, 0);
  if (x === undefined) {
    return [];
  }
  var xs$1 = prependToAll(delim, tailOrEmpty(xs));
  return Relude__Relude_Array_Instances.concat([Caml_option.valFromOption(x)], xs$1);
}

function replicate(i, xs) {
  return Curry._3(Relude__Relude_Array_Instances.foldLeft, (function (acc, _i) {
                return Relude__Relude_Array_Instances.concat(acc, xs);
              }), [], Relude__Relude_Int.rangeAsArray(0, i));
}

function zipWith(f, xs, ys) {
  return Belt_Array.zipBy(xs, ys, f);
}

function zipWithIndex(xs) {
  return Belt_Array.zip(xs, Relude__Relude_Int.rangeAsArray(0, xs.length));
}

function sortWithInt(f, xs) {
  return Belt_SortArray.stableSortBy(xs, f);
}

function sortBy(f, xs) {
  return Belt_SortArray.stableSortBy(xs, (function (a, b) {
                return Relude__Relude_Ordering.toInt(Curry._2(f, a, b));
              }));
}

function sort(ordA, xs) {
  return sortBy(ordA.compare, xs);
}

function distinctBy(eq, xs) {
  return Curry._3(Relude__Relude_Array_Instances.foldLeft, (function (acc, curr) {
                if (Curry._3(Relude__Relude_Array_Instances.containsBy, eq, curr, acc)) {
                  return acc;
                } else {
                  return Relude__Relude_Array_Instances.concat(acc, [curr]);
                }
              }), [], xs);
}

function removeFirstBy(innerEq, v, xs) {
  return Curry._3(Relude__Relude_Array_Instances.foldLeft, (function (param, x) {
                  var ys = param[1];
                  if (param[0]) {
                    return [
                            true,
                            Relude__Relude_Array_Instances.concat(ys, [x])
                          ];
                  } else if (Curry._2(innerEq, v, x)) {
                    return [
                            true,
                            ys
                          ];
                  } else {
                    return [
                            false,
                            Relude__Relude_Array_Instances.concat(ys, [x])
                          ];
                  }
                }), [
                false,
                []
              ], xs)[1];
}

function removeEachBy(innerEq, x, xs) {
  return Curry._3(Relude__Relude_Array_Instances.foldLeft, (function (ys, y) {
                if (Curry._2(innerEq, x, y)) {
                  return ys;
                } else {
                  return Relude__Relude_Array_Instances.concat(ys, [y]);
                }
              }), [], xs);
}

function distinct(eqA, xs) {
  return distinctBy(eqA.eq, xs);
}

function removeFirst(eqA, x, xs) {
  return removeFirstBy(eqA.eq, x, xs);
}

function removeEach(eqA, x, xs) {
  return removeEachBy(eqA.eq, x, xs);
}

function replaceAt(targetIndex, newX, xs) {
  return mapWithIndex((function (x, currentIndex) {
                if (currentIndex === targetIndex) {
                  return newX;
                } else {
                  return x;
                }
              }), xs);
}

function scanLeft(f, init, xs) {
  return Curry._3(Relude__Relude_Array_Instances.foldLeft, (function (param, curr) {
                  var nextAcc = Curry._2(f, param[0], curr);
                  return [
                          nextAcc,
                          Relude__Relude_Array_Instances.concat(param[1], [nextAcc])
                        ];
                }), [
                init,
                []
              ], xs)[1];
}

function scanRight(f, init, xs) {
  return Curry._3(Relude__Relude_Array_Instances.foldRight, (function (curr, param) {
                  var nextAcc = Curry._2(f, curr, param[0]);
                  return [
                          nextAcc,
                          Relude__Relude_Array_Instances.concat([nextAcc], param[1])
                        ];
                }), [
                init,
                []
              ], xs)[1];
}

function insertAt(targetIndex, newX, xs) {
  var match = splitAt(targetIndex, xs);
  if (match !== undefined) {
    return Relude__Relude_Array_Instances.concat(match[0], Relude__Relude_Array_Instances.concat([newX], match[1]));
  } else {
    return xs;
  }
}

function updateAt(targetIndex, f, xs) {
  return mapWithIndex((function (x, index) {
                if (index === targetIndex) {
                  return Curry._1(f, x);
                } else {
                  return x;
                }
              }), xs);
}

function swapAt(i, j, xs) {
  var match = Belt_Array.get(xs, i);
  var match$1 = Belt_Array.get(xs, j);
  if (match === undefined) {
    return xs;
  }
  if (match$1 === undefined) {
    return xs;
  }
  var b = Caml_option.valFromOption(match$1);
  var a = Caml_option.valFromOption(match);
  return mapWithIndex((function (x, k) {
                if (i === k) {
                  return b;
                } else if (j === k) {
                  return a;
                } else {
                  return x;
                }
              }), xs);
}

function removeAt(targetIndex, xs) {
  return Belt_Array.keepWithIndex(xs, (function (param, i) {
                return i !== targetIndex;
              }));
}

function chunk(size, xs) {
  if (size < 1) {
    return [xs];
  } else if (xs.length <= size) {
    return [xs];
  } else {
    return Relude__Relude_Array_Instances.concat([take(size, xs)], chunk(size, drop(size, xs)));
  }
}

var prepend = cons;

var makeWithIndex = Belt_Array.makeBy;

var reverse = Belt_Array.reverse;

var shuffle = Belt_Array.shuffle;

var keep = filter;

var keepWithIndex = filterWithIndex;

var reject = filterNot;

var rejectWithIndex = filterNotWithIndex;

var zip = Belt_Array.zip;

var unzip = Belt_Array.unzip;

exports.cons = cons;
exports.prepend = prepend;
exports.uncons = uncons;
exports.append = append;
exports.repeat = repeat;
exports.makeWithIndex = makeWithIndex;
exports.mapWithIndex = mapWithIndex;
exports.reverse = reverse;
exports.shuffleInPlace = shuffleInPlace;
exports.shuffle = shuffle;
exports.length = length;
exports.isEmpty = isEmpty;
exports.isNotEmpty = isNotEmpty;
exports.at = at;
exports.setAt = setAt;
exports.head = head;
exports.tail = tail;
exports.tailOrEmpty = tailOrEmpty;
exports.init = init;
exports.initOrEmpty = initOrEmpty;
exports.last = last;
exports.take = take;
exports.takeExactly = takeExactly;
exports.takeWhile = takeWhile;
exports.drop = drop;
exports.dropExactly = dropExactly;
exports.dropWhile = dropWhile;
exports.filter = filter;
exports.keep = keep;
exports.filterWithIndex = filterWithIndex;
exports.keepWithIndex = keepWithIndex;
exports.filterNot = filterNot;
exports.reject = reject;
exports.filterNotWithIndex = filterNotWithIndex;
exports.rejectWithIndex = rejectWithIndex;
exports.mapOption = mapOption;
exports.catOption = catOption;
exports.partition = partition;
exports.splitAt = splitAt;
exports.prependToAll = prependToAll;
exports.intersperse = intersperse;
exports.replicate = replicate;
exports.zip = zip;
exports.zipWith = zipWith;
exports.zipWithIndex = zipWithIndex;
exports.unzip = unzip;
exports.sortWithInt = sortWithInt;
exports.sortBy = sortBy;
exports.sort = sort;
exports.distinctBy = distinctBy;
exports.removeFirstBy = removeFirstBy;
exports.removeEachBy = removeEachBy;
exports.distinct = distinct;
exports.removeFirst = removeFirst;
exports.removeEach = removeEach;
exports.replaceAt = replaceAt;
exports.scanLeft = scanLeft;
exports.scanRight = scanRight;
exports.insertAt = insertAt;
exports.updateAt = updateAt;
exports.swapAt = swapAt;
exports.removeAt = removeAt;
exports.chunk = chunk;
/* Relude__Relude_Int Not a pure module */
