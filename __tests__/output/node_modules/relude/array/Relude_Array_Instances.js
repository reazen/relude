// Generated by Melange
'use strict';

var Curry = require("melange.runtime/curry.js");
var Belt_List = require("melange.belt/./belt_List.js");
var Belt_Array = require("melange.belt/./belt_Array.js");
var Caml_option = require("melange.runtime/caml_option.js");
var Bastet__Array = require("bastet/./Array.js");
var Bastet__String = require("bastet/./String.js");
var Relude__Relude_Extensions_Alt = require("../extensions/Relude_Extensions_Alt.js");
var Relude__Relude_Extensions_Apply = require("../extensions/Relude_Extensions_Apply.js");
var Relude__Relude_Extensions_Monad = require("../extensions/Relude_Extensions_Monad.js");
var Relude__Relude_Extensions_Functor = require("../extensions/Relude_Extensions_Functor.js");
var Relude__Relude_Extensions_Foldable = require("../extensions/Relude_Extensions_Foldable.js");
var Relude__Relude_Extensions_Applicative = require("../extensions/Relude_Extensions_Applicative.js");
var Relude__Relude_Extensions_SemigroupAny = require("../extensions/Relude_Extensions_SemigroupAny.js");

var SemigroupAny = {
  append: Belt_Array.concat
};

var include = Relude__Relude_Extensions_SemigroupAny.SemigroupAnyExtensions(SemigroupAny);

var map = Bastet__Array.Functor.map;

var Functor = {
  map: map
};

var include$1 = Relude__Relude_Extensions_Functor.FunctorExtensions(Functor);

var apply = Bastet__Array.Apply.apply;

var Apply = {
  map: map,
  apply: apply
};

var include$2 = Relude__Relude_Extensions_Apply.ApplyExtensions(Apply);

function pure(a) {
  return [a];
}

var Applicative = {
  map: map,
  apply: apply,
  pure: pure
};

var include$3 = Relude__Relude_Extensions_Applicative.ApplicativeExtensions(Applicative);

var bind = Bastet__Array.Monad.flat_map;

var Monad = {
  map: map,
  apply: apply,
  pure: pure,
  flat_map: bind
};

var include$4 = Relude__Relude_Extensions_Monad.MonadExtensions(Monad);

var alt = Bastet__Array.Alt.alt;

var Alt = {
  map: map,
  alt: alt
};

var include$5 = Relude__Relude_Extensions_Alt.AltExtensions(Alt);

var imap = Bastet__Array.Invariant.imap;

var Invariant = {
  imap: imap
};

var extend = Bastet__Array.Extend.extend;

var Extend = {
  map: map,
  extend: extend
};

var foldLeft = Bastet__Array.Foldable.fold_left;

var foldRight = Bastet__Array.Foldable.fold_right;

var Foldable_Fold_Map = Bastet__Array.Foldable.Fold_Map;

var Foldable_Fold_Map_Any = Bastet__Array.Foldable.Fold_Map_Any;

var Foldable_Fold_Map_Plus = Bastet__Array.Foldable.Fold_Map_Plus;

var Foldable = {
  fold_left: foldLeft,
  fold_right: foldRight,
  Fold_Map: Foldable_Fold_Map,
  Fold_Map_Any: Foldable_Fold_Map_Any,
  Fold_Map_Plus: Foldable_Fold_Map_Plus
};

var include$6 = Relude__Relude_Extensions_Foldable.FoldableExtensions(Foldable);

var intercalate = include$6.intercalate;

function eqBy(innerEq, _xs, _ys) {
  while(true) {
    var ys = _ys;
    var xs = _xs;
    var match = Belt_Array.get(xs, 0);
    var match$1 = Belt_Array.get(ys, 0);
    if (match === undefined) {
      return match$1 === undefined;
    }
    if (match$1 === undefined) {
      return false;
    }
    if (!Curry._2(innerEq, Caml_option.valFromOption(match), Caml_option.valFromOption(match$1))) {
      return false;
    }
    _ys = Belt_Array.sliceToEnd(ys, 1);
    _xs = Belt_Array.sliceToEnd(xs, 1);
    continue ;
  };
}

function eq(eqA, xs, ys) {
  return eqBy(eqA.eq, xs, ys);
}

function Eq(EqA) {
  var eq = function (param, param$1) {
    return eqBy(EqA.eq, param, param$1);
  };
  return {
          eq: eq
        };
}

function showBy(innerShow, xs) {
  var join = Curry._1(intercalate, Bastet__String.Monoid);
  return "[" + (Curry._2(join, ", ", Curry._2(map, innerShow, xs)) + "]");
}

function show(showA, xs) {
  return showBy(showA.show, xs);
}

function Show(ShowA) {
  var show = function (param) {
    return showBy(ShowA.show, param);
  };
  return {
          show: show
        };
}

var IsoList = {
  fromList: Belt_List.toArray,
  toList: Belt_List.fromArray
};

var concat = Belt_Array.concat;

var concatNamed = include.concatNamed;

var BsFunctorExtensions = include$1.BsFunctorExtensions;

var flipMap = include$1.flipMap;

var $$void = include$1.$$void;

var voidRight = include$1.voidRight;

var voidLeft = include$1.voidLeft;

var flap = include$1.flap;

var BsApplyExtensions = include$2.BsApplyExtensions;

var applyFirst = include$2.applyFirst;

var applySecond = include$2.applySecond;

var map2 = include$2.map2;

var map3 = include$2.map3;

var map4 = include$2.map4;

var map5 = include$2.map5;

var tuple2 = include$2.tuple2;

var tuple3 = include$2.tuple3;

var tuple4 = include$2.tuple4;

var tuple5 = include$2.tuple5;

var mapTuple2 = include$2.mapTuple2;

var mapTuple3 = include$2.mapTuple3;

var mapTuple4 = include$2.mapTuple4;

var mapTuple5 = include$2.mapTuple5;

var BsApplicativeExtensions = include$3.BsApplicativeExtensions;

var liftA1 = include$3.liftA1;

var BsMonadExtensions = include$4.BsMonadExtensions;

var flatMap = include$4.flatMap;

var flatten = include$4.flatten;

var composeKleisli = include$4.composeKleisli;

var flipComposeKleisli = include$4.flipComposeKleisli;

var liftM1 = include$4.liftM1;

var when_ = include$4.when_;

var unless = include$4.unless;

var orElse = include$5.orElse;

var BsFoldableExtensions = include$6.BsFoldableExtensions;

var any = include$6.any;

var all = include$6.all;

var containsBy = include$6.containsBy;

var contains = include$6.contains;

var indexOfBy = include$6.indexOfBy;

var indexOf = include$6.indexOf;

var minBy = include$6.minBy;

var min = include$6.min;

var maxBy = include$6.maxBy;

var max = include$6.max;

var countBy = include$6.countBy;

var length = include$6.length;

var size = include$6.size;

var count = include$6.count;

var forEach = include$6.forEach;

var forEachWithIndex = include$6.forEachWithIndex;

var find = include$6.find;

var findWithIndex = include$6.findWithIndex;

var toArray = include$6.toArray;

var FoldableSemigroupExtensions = include$6.FoldableSemigroupExtensions;

var FoldableMonoidExtensions = include$6.FoldableMonoidExtensions;

var foldMap = include$6.foldMap;

var foldWithMonoid = include$6.foldWithMonoid;

var FoldableApplicativeExtensions = include$6.FoldableApplicativeExtensions;

var FoldableMonadExtensions = include$6.FoldableMonadExtensions;

var FoldableEqExtensions = include$6.FoldableEqExtensions;

var FoldableOrdExtensions = include$6.FoldableOrdExtensions;

var fromList = Belt_List.toArray;

var toList = Belt_List.fromArray;

exports.concat = concat;
exports.SemigroupAny = SemigroupAny;
exports.concatNamed = concatNamed;
exports.map = map;
exports.Functor = Functor;
exports.BsFunctorExtensions = BsFunctorExtensions;
exports.flipMap = flipMap;
exports.$$void = $$void;
exports.voidRight = voidRight;
exports.voidLeft = voidLeft;
exports.flap = flap;
exports.apply = apply;
exports.Apply = Apply;
exports.BsApplyExtensions = BsApplyExtensions;
exports.applyFirst = applyFirst;
exports.applySecond = applySecond;
exports.map2 = map2;
exports.map3 = map3;
exports.map4 = map4;
exports.map5 = map5;
exports.tuple2 = tuple2;
exports.tuple3 = tuple3;
exports.tuple4 = tuple4;
exports.tuple5 = tuple5;
exports.mapTuple2 = mapTuple2;
exports.mapTuple3 = mapTuple3;
exports.mapTuple4 = mapTuple4;
exports.mapTuple5 = mapTuple5;
exports.pure = pure;
exports.Applicative = Applicative;
exports.BsApplicativeExtensions = BsApplicativeExtensions;
exports.liftA1 = liftA1;
exports.bind = bind;
exports.Monad = Monad;
exports.BsMonadExtensions = BsMonadExtensions;
exports.flatMap = flatMap;
exports.flatten = flatten;
exports.composeKleisli = composeKleisli;
exports.flipComposeKleisli = flipComposeKleisli;
exports.liftM1 = liftM1;
exports.when_ = when_;
exports.unless = unless;
exports.alt = alt;
exports.Alt = Alt;
exports.orElse = orElse;
exports.imap = imap;
exports.Invariant = Invariant;
exports.extend = extend;
exports.Extend = Extend;
exports.foldLeft = foldLeft;
exports.foldRight = foldRight;
exports.Foldable = Foldable;
exports.BsFoldableExtensions = BsFoldableExtensions;
exports.any = any;
exports.all = all;
exports.containsBy = containsBy;
exports.contains = contains;
exports.indexOfBy = indexOfBy;
exports.indexOf = indexOf;
exports.minBy = minBy;
exports.min = min;
exports.maxBy = maxBy;
exports.max = max;
exports.countBy = countBy;
exports.length = length;
exports.size = size;
exports.count = count;
exports.forEach = forEach;
exports.forEachWithIndex = forEachWithIndex;
exports.find = find;
exports.findWithIndex = findWithIndex;
exports.toArray = toArray;
exports.FoldableSemigroupExtensions = FoldableSemigroupExtensions;
exports.FoldableMonoidExtensions = FoldableMonoidExtensions;
exports.foldMap = foldMap;
exports.foldWithMonoid = foldWithMonoid;
exports.intercalate = intercalate;
exports.FoldableApplicativeExtensions = FoldableApplicativeExtensions;
exports.FoldableMonadExtensions = FoldableMonadExtensions;
exports.FoldableEqExtensions = FoldableEqExtensions;
exports.FoldableOrdExtensions = FoldableOrdExtensions;
exports.eqBy = eqBy;
exports.eq = eq;
exports.Eq = Eq;
exports.showBy = showBy;
exports.show = show;
exports.Show = Show;
exports.fromList = fromList;
exports.toList = toList;
exports.IsoList = IsoList;
/* include Not a pure module */
