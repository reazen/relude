// Generated by Melange
'use strict';

var Curry = require("melange.runtime/curry.js");
var Relude__Relude_Function = require("./Relude_Function.js");
var Relude__Relude_Extensions_Apply = require("./extensions/Relude_Extensions_Apply.js");
var Relude__Relude_Extensions_Functor = require("./extensions/Relude_Extensions_Functor.js");
var Relude__Relude_Extensions_Applicative = require("./extensions/Relude_Extensions_Applicative.js");

function WithFunctor(F) {
  var map = function (aToB, freeA) {
    if (freeA.TAG === /* Pure */0) {
      return {
              TAG: /* Pure */0,
              _0: Curry._1(aToB, freeA._0)
            };
    } else {
      return {
              TAG: /* Apply */1,
              _0: freeA._0,
              _1: map((function (xToA) {
                      return function (param) {
                        return Relude__Relude_Function.Infix.$great$great(xToA, aToB, param);
                      };
                    }), freeA._1)
            };
    }
  };
  var Functor = {
    map: map
  };
  var include = Relude__Relude_Extensions_Functor.FunctorExtensions(Functor);
  var apply = function (freeAToB, freeA) {
    if (freeAToB.TAG === /* Pure */0) {
      return map(freeAToB._0, freeA);
    }
    var freeAToXToB = map(Relude__Relude_Function.flip, freeAToB._1);
    var freeXToB = apply(freeAToXToB, freeA);
    return {
            TAG: /* Apply */1,
            _0: freeAToB._0,
            _1: freeXToB
          };
  };
  var Apply = {
    map: map,
    apply: apply
  };
  var include$1 = Relude__Relude_Extensions_Apply.ApplyExtensions(Apply);
  var pure = function (a) {
    return {
            TAG: /* Pure */0,
            _0: a
          };
  };
  var Applicative = {
    map: map,
    apply: apply,
    pure: pure
  };
  var include$2 = Relude__Relude_Extensions_Applicative.ApplicativeExtensions(Applicative);
  var liftF = function (fa) {
    return {
            TAG: /* Apply */1,
            _0: fa,
            _1: {
              TAG: /* Pure */0,
              _0: (function (a) {
                  return a;
                })
            }
          };
  };
  var WithApplicative = function (A) {
    var WithNT = function (NT) {
      var foldFree = function (freeA) {
        if (freeA.TAG === /* Pure */0) {
          return Curry._1(A.pure, freeA._0);
        } else {
          return Curry._2(A.apply, foldFree(freeA._1), Curry._1(NT.f, freeA._0));
        }
      };
      return {
              foldFree: foldFree
            };
    };
    return {
            WithNT: WithNT
          };
  };
  var WithApplicativeAndNT = function (A, NT) {
    var WithNT = function (NT) {
      var foldFree = function (freeA) {
        if (freeA.TAG === /* Pure */0) {
          return Curry._1(A.pure, freeA._0);
        } else {
          return Curry._2(A.apply, foldFree(freeA._1), Curry._1(NT.f, freeA._0));
        }
      };
      return {
              foldFree: foldFree
            };
    };
    var A$1 = {
      WithNT: WithNT
    };
    var foldFree = function (freeA) {
      if (freeA.TAG === /* Pure */0) {
        return Curry._1(A.pure, freeA._0);
      } else {
        return Curry._2(A.apply, foldFree(freeA._1), Curry._1(NT.f, freeA._0));
      }
    };
    var include = {
      foldFree: foldFree
    };
    return {
            A: A$1,
            foldFree: include.foldFree
          };
  };
  var include$3 = Relude__Relude_Extensions_Functor.FunctorInfix(Functor);
  var include$4 = Relude__Relude_Extensions_Apply.ApplyInfix(Apply);
  var Infix_FunctorExtensions = include$3.FunctorExtensions;
  var Infix_$less$$great = include$3.$less$$great;
  var Infix_$less$$$great = include$3.$less$$$great;
  var Infix_$less$ = include$3.$less$;
  var Infix_$$great = include$3.$$great;
  var Infix_$less$at$great = include$3.$less$at$great;
  var Infix_ApplyExtensions = include$4.ApplyExtensions;
  var Infix_$less$star$great = include$4.$less$star$great;
  var Infix_$less$star = include$4.$less$star;
  var Infix_$star$great = include$4.$star$great;
  var Infix = {
    FunctorExtensions: Infix_FunctorExtensions,
    $less$$great: Infix_$less$$great,
    $less$$$great: Infix_$less$$$great,
    $less$: Infix_$less$,
    $$great: Infix_$$great,
    $less$at$great: Infix_$less$at$great,
    ApplyExtensions: Infix_ApplyExtensions,
    $less$star$great: Infix_$less$star$great,
    $less$star: Infix_$less$star,
    $star$great: Infix_$star$great
  };
  return {
          map: map,
          Functor: Functor,
          BsFunctorExtensions: include.BsFunctorExtensions,
          flipMap: include.flipMap,
          $$void: include.$$void,
          voidRight: include.voidRight,
          voidLeft: include.voidLeft,
          flap: include.flap,
          apply: apply,
          Apply: Apply,
          BsApplyExtensions: include$1.BsApplyExtensions,
          applyFirst: include$1.applyFirst,
          applySecond: include$1.applySecond,
          map2: include$1.map2,
          map3: include$1.map3,
          map4: include$1.map4,
          map5: include$1.map5,
          tuple2: include$1.tuple2,
          tuple3: include$1.tuple3,
          tuple4: include$1.tuple4,
          tuple5: include$1.tuple5,
          mapTuple2: include$1.mapTuple2,
          mapTuple3: include$1.mapTuple3,
          mapTuple4: include$1.mapTuple4,
          mapTuple5: include$1.mapTuple5,
          pure: pure,
          Applicative: Applicative,
          BsApplicativeExtensions: include$2.BsApplicativeExtensions,
          liftA1: include$2.liftA1,
          when_: include$2.when_,
          unless: include$2.unless,
          all: include$2.all,
          liftF: liftF,
          WithApplicative: WithApplicative,
          WithApplicativeAndNT: WithApplicativeAndNT,
          Infix: Infix
        };
}

exports.WithFunctor = WithFunctor;
/* Relude__Relude_Function Not a pure module */
