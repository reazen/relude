// Generated by Melange
'use strict';

var Curry = require("melange.runtime/curry.js");
var Belt_Id = require("melange.belt/./belt_Id.js");
var Belt_Map = require("melange.belt/./belt_Map.js");
var Belt_List = require("melange.belt/./belt_List.js");
var Belt_Array = require("melange.belt/./belt_Array.js");
var Relude__Relude_Function = require("./Relude_Function.js");
var Relude__Relude_Ordering = require("./Relude_Ordering.js");
var Relude__Relude_List_Instances = require("./list/Relude_List_Instances.js");
var Relude__Relude_Array_Instances = require("./array/Relude_Array_Instances.js");
var Relude__Relude_Extensions_Functor = require("./extensions/Relude_Extensions_Functor.js");

var make = Belt_Map.make;

function set(key, value, __x) {
  return Belt_Map.set(__x, key, value);
}

function singleton(comparable, key, value) {
  return Belt_Map.set(Belt_Map.make(comparable), key, value);
}

function contains(key, __x) {
  return Belt_Map.has(__x, key);
}

function compareInt(comparator, a, b) {
  return Belt_Map.cmp(a, b, comparator);
}

function compareBy(comparator, a, b) {
  return Relude__Relude_Ordering.fromInt(Belt_Map.cmp(a, b, (function (a, b) {
                    return Relude__Relude_Ordering.toInt(Curry._2(comparator, a, b));
                  })));
}

function eqBy(comparator, a, b) {
  return Belt_Map.eq(a, b, comparator);
}

function find(by, __x) {
  return Belt_Map.findFirstBy(__x, by);
}

function forEach(fn, __x) {
  Belt_Map.forEach(__x, fn);
}

function foldLeft(fn, acc, __x) {
  return Belt_Map.reduce(__x, acc, fn);
}

function all(cond, __x) {
  return Belt_Map.every(__x, cond);
}

function any(cond, __x) {
  return Belt_Map.some(__x, cond);
}

function fromArray(comparable, arr) {
  return Belt_Map.fromArray(arr, comparable);
}

function fromValueArray(comparable, toKey) {
  return Curry._2(Relude__Relude_Array_Instances.foldLeft, (function (map, v) {
                return Belt_Map.set(map, Curry._1(toKey, v), v);
              }), Belt_Map.make(comparable));
}

function fromList(comparable, lst) {
  return Belt_Map.fromArray(Belt_List.toArray(lst), comparable);
}

function fromValueList(comparable, toKey) {
  return Relude__Relude_List_Instances.foldLeft((function (map, v) {
                return Belt_Map.set(map, Curry._1(toKey, v), v);
              }), Belt_Map.make(comparable));
}

function keys(map) {
  return Belt_List.fromArray(Belt_Map.keysToArray(map));
}

function values(map) {
  return Belt_List.fromArray(Belt_Map.valuesToArray(map));
}

function get(key, __x) {
  return Belt_Map.get(__x, key);
}

function getOrElse(key, $$default, __x) {
  return Belt_Map.getWithDefault(__x, key, $$default);
}

function remove(key, __x) {
  return Belt_Map.remove(__x, key);
}

function removeMany(keys, __x) {
  return Belt_Map.removeMany(__x, keys);
}

function update(key, updateFn, __x) {
  return Belt_Map.update(__x, key, updateFn);
}

function merge(mergeFn, a, b) {
  return Belt_Map.merge(a, b, mergeFn);
}

function mergeMany(arr, __x) {
  return Belt_Map.mergeMany(__x, arr);
}

function filter(fn, __x) {
  return Belt_Map.keep(__x, fn);
}

function filterNot(fn, __x) {
  return Belt_Map.keep(__x, (function (key, value) {
                return !Curry._2(fn, key, value);
              }));
}

function partition(fn, __x) {
  return Belt_Map.partition(__x, fn);
}

function map(fn, __x) {
  return Belt_Map.map(__x, fn);
}

function mapWithKey(fn, __x) {
  return Belt_Map.mapWithKey(__x, fn);
}

function groupListBy(comparable, groupBy) {
  var addItemToGroup = function (x) {
    var partial_arg = Curry._1(groupBy, x);
    var partial_arg$1 = function (param) {
      return Belt_Map.getWithDefault(param, partial_arg, /* [] */0);
    };
    return function (param) {
      return Relude__Relude_Function.Infix.$great$great(partial_arg$1, (function (xs) {
                    return {
                            hd: x,
                            tl: xs
                          };
                  }), param);
    };
  };
  var addItemToMap = function (dict, x) {
    return Belt_Map.set(dict, Curry._1(groupBy, x), addItemToGroup(x)(dict));
  };
  return function (param) {
    return Relude__Relude_Function.Infix.$great$great((function (__x) {
                  return Belt_List.reduce(__x, Belt_Map.make(comparable), addItemToMap);
                }), (function (param) {
                  return Belt_Map.map(param, Belt_List.reverse);
                }), param);
  };
}

function groupArrayBy(comparable, groupBy) {
  var addItemToGroup = function (x) {
    var partial_arg = [];
    var partial_arg$1 = Curry._1(groupBy, x);
    var partial_arg$2 = function (param) {
      return Belt_Map.getWithDefault(param, partial_arg$1, partial_arg);
    };
    return function (param) {
      return Relude__Relude_Function.Infix.$great$great(partial_arg$2, (function (__x) {
                    return Belt_Array.concat(__x, [x]);
                  }), param);
    };
  };
  var addItemToMap = function (dict, x) {
    return Belt_Map.set(dict, Curry._1(groupBy, x), addItemToGroup(x)(dict));
  };
  return function (__x) {
    return Belt_Array.reduce(__x, Belt_Map.make(comparable), addItemToMap);
  };
}

function WithOrd(M) {
  var cmp = function (a, b) {
    return Relude__Relude_Ordering.toInt(Curry._2(M.compare, a, b));
  };
  var Comparable = Belt_Id.MakeComparable({
        cmp: cmp
      });
  var make = function (param) {
    return Belt_Map.make(Comparable);
  };
  var singleton = function (key, value) {
    return Belt_Map.set(Belt_Map.make(Comparable), key, value);
  };
  var fromArray = function (arr) {
    return Belt_Map.fromArray(arr, Comparable);
  };
  var fromValueArray$1 = function (toKey, arr) {
    return Curry._1(fromValueArray(Comparable, toKey), arr);
  };
  var fromList = function (lst) {
    return Belt_Map.fromArray(Belt_List.toArray(lst), Comparable);
  };
  var fromValueList$1 = function (toKey, lst) {
    return fromValueList(Comparable, toKey)(lst);
  };
  var groupListBy$1 = function (groupBy, lst) {
    return groupListBy(Comparable, groupBy)(lst);
  };
  var groupArrayBy$1 = function (groupBy, arr) {
    return groupArrayBy(Comparable, groupBy)(arr);
  };
  var Functor = {
    map: map
  };
  Relude__Relude_Extensions_Functor.FunctorExtensions(Functor);
  return {
          Comparable: {},
          make: make,
          set: set,
          singleton: singleton,
          isEmpty: Belt_Map.isEmpty,
          contains: contains,
          compareInt: compareInt,
          compareBy: compareBy,
          eqBy: eqBy,
          find: find,
          forEach: forEach,
          foldLeft: foldLeft,
          all: all,
          any: any,
          length: Belt_Map.size,
          toArray: Belt_Map.toArray,
          fromArray: fromArray,
          fromValueArray: fromValueArray$1,
          toList: Belt_Map.toList,
          fromList: fromList,
          fromValueList: fromValueList$1,
          keys: keys,
          keyArray: Belt_Map.keysToArray,
          values: values,
          valueArray: Belt_Map.valuesToArray,
          minKey: Belt_Map.minKey,
          maxKey: Belt_Map.maxKey,
          min: Belt_Map.minimum,
          max: Belt_Map.maximum,
          get: get,
          getOrElse: getOrElse,
          remove: remove,
          removeMany: removeMany,
          update: update,
          merge: merge,
          mergeMany: mergeMany,
          filter: filter,
          keep: filter,
          filterNot: filterNot,
          reject: filterNot,
          partition: partition,
          map: map,
          mapWithKey: mapWithKey,
          groupListBy: groupListBy$1,
          groupArrayBy: groupArrayBy$1
        };
}

var isEmpty = Belt_Map.isEmpty;

var length = Belt_Map.size;

var toArray = Belt_Map.toArray;

var toList = Belt_Map.toList;

var keyArray = Belt_Map.keysToArray;

var valueArray = Belt_Map.valuesToArray;

var minKey = Belt_Map.minKey;

var maxKey = Belt_Map.maxKey;

var min = Belt_Map.minimum;

var max = Belt_Map.maximum;

var keep = filter;

var reject = filterNot;

exports.make = make;
exports.set = set;
exports.singleton = singleton;
exports.isEmpty = isEmpty;
exports.contains = contains;
exports.compareInt = compareInt;
exports.compareBy = compareBy;
exports.eqBy = eqBy;
exports.find = find;
exports.forEach = forEach;
exports.foldLeft = foldLeft;
exports.all = all;
exports.any = any;
exports.length = length;
exports.toArray = toArray;
exports.fromArray = fromArray;
exports.fromValueArray = fromValueArray;
exports.toList = toList;
exports.fromList = fromList;
exports.fromValueList = fromValueList;
exports.keyArray = keyArray;
exports.keys = keys;
exports.valueArray = valueArray;
exports.values = values;
exports.minKey = minKey;
exports.maxKey = maxKey;
exports.min = min;
exports.max = max;
exports.get = get;
exports.getOrElse = getOrElse;
exports.remove = remove;
exports.removeMany = removeMany;
exports.update = update;
exports.merge = merge;
exports.mergeMany = mergeMany;
exports.filter = filter;
exports.keep = keep;
exports.filterNot = filterNot;
exports.reject = reject;
exports.partition = partition;
exports.map = map;
exports.mapWithKey = mapWithKey;
exports.groupListBy = groupListBy;
exports.groupArrayBy = groupArrayBy;
exports.WithOrd = WithOrd;
/* Relude__Relude_Function Not a pure module */
