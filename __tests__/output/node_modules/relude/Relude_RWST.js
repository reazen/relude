// Generated by Melange
'use strict';

var Curry = require("melange.runtime/curry.js");
var Relude__Relude_Extensions_Apply = require("./extensions/Relude_Extensions_Apply.js");
var Relude__Relude_Extensions_Monad = require("./extensions/Relude_Extensions_Monad.js");
var Relude__Relude_Extensions_Functor = require("./extensions/Relude_Extensions_Functor.js");
var Relude__Relude_Extensions_Applicative = require("./extensions/Relude_Extensions_Applicative.js");

var RWSResult = {};

function WithMonad(M) {
  var runRWST = function (r, s, f) {
    return Curry._2(f._0, r, s);
  };
  var evalRWST = function (r, s, f) {
    return Curry._2(M.map, (function (param) {
                  return [
                          param._0,
                          param._2
                        ];
                }), Curry._2(f._0, r, s));
  };
  var execRWST = function (r, s, f) {
    return Curry._2(M.map, (function (param) {
                  return [
                          param._1,
                          param._2
                        ];
                }), Curry._2(f._0, r, s));
  };
  var mapRWST = function (f, m) {
    var m$1 = m._0;
    return /* RWST */{
            _0: (function (r, s) {
                return Curry._1(f, Curry._2(m$1, r, s));
              })
          };
  };
  var withRWST = function (convert, f) {
    var f$1 = f._0;
    return /* RWST */{
            _0: (function (r1, s1) {
                var match = Curry._2(convert, r1, s1);
                return Curry._2(f$1, match[0], match[1]);
              })
          };
  };
  var map = function (aToB, f) {
    var f$1 = f._0;
    return /* RWST */{
            _0: (function (r, s) {
                return Curry._2(M.map, (function (param) {
                              return /* RWSResult */{
                                      _0: Curry._1(aToB, param._0),
                                      _1: param._1,
                                      _2: param._2
                                    };
                            }), Curry._2(f$1, r, s));
              })
          };
  };
  var applyWithAppendLog = function (appendLog, runAToB, runA) {
    var runA$1 = runA._0;
    var runAToB$1 = runAToB._0;
    return /* RWST */{
            _0: (function (r, s) {
                var mAToB = Curry._2(runAToB$1, r, s);
                var mA = Curry._2(runA$1, r, s);
                var f = function (param, param$1) {
                  return /* RWSResult */{
                          _0: Curry._1(param._0, param$1._0),
                          _1: param$1._1,
                          _2: Curry._2(appendLog, param._2, param$1._2)
                        };
                };
                return Curry._2(M.apply, Curry._2(M.map, f, mAToB), mA);
              })
          };
  };
  var pureWithEmptyLog = function (w, a) {
    return /* RWST */{
            _0: (function (_r, s) {
                return Curry._1(M.pure, /* RWSResult */{
                            _0: a,
                            _1: s,
                            _2: w
                          });
              })
          };
  };
  var bindWithAppendLog = function (appendLog, runA, aToRWSTB) {
    var runA$1 = runA._0;
    return /* RWST */{
            _0: (function (r1, s1) {
                return Curry._2(M.flat_map, Curry._2(runA$1, r1, s1), (function (param) {
                              var w1 = param._2;
                              var runB = Curry._1(aToRWSTB, param._0);
                              return Curry._2(M.map, (function (param) {
                                            return /* RWSResult */{
                                                    _0: param._0,
                                                    _1: param._1,
                                                    _2: Curry._2(appendLog, w1, param._2)
                                                  };
                                          }), Curry._2(runB._0, r1, param._1));
                            }));
              })
          };
  };
  var WithEnvAndStateAndLog = function (R, S, Log) {
    var Functor = {
      map: map
    };
    var include = Relude__Relude_Extensions_Functor.FunctorExtensions(Functor);
    var apply = function (ff, fa) {
      return applyWithAppendLog(Log.Monoid.append, ff, fa);
    };
    var Apply = {
      map: map,
      apply: apply
    };
    var include$1 = Relude__Relude_Extensions_Apply.ApplyExtensions(Apply);
    var pure = function (a) {
      return pureWithEmptyLog(Log.Monoid.empty, a);
    };
    var Applicative = {
      map: map,
      apply: apply,
      pure: pure
    };
    var include$2 = Relude__Relude_Extensions_Applicative.ApplicativeExtensions(Applicative);
    var flat_map = function (f, ma) {
      return bindWithAppendLog(Log.Monoid.append, f, ma);
    };
    var Monad = {
      map: map,
      apply: apply,
      pure: pure,
      flat_map: flat_map
    };
    var include$3 = Relude__Relude_Extensions_Monad.MonadExtensions(Monad);
    var include$4 = Relude__Relude_Extensions_Functor.FunctorInfix(Functor);
    var include$5 = Relude__Relude_Extensions_Apply.ApplyInfix(Apply);
    var include$6 = Relude__Relude_Extensions_Monad.MonadInfix(Monad);
    var Infix_FunctorExtensions = include$4.FunctorExtensions;
    var Infix_$less$$great = include$4.$less$$great;
    var Infix_$less$$$great = include$4.$less$$$great;
    var Infix_$less$ = include$4.$less$;
    var Infix_$$great = include$4.$$great;
    var Infix_$less$at$great = include$4.$less$at$great;
    var Infix_ApplyExtensions = include$5.ApplyExtensions;
    var Infix_$less$star$great = include$5.$less$star$great;
    var Infix_$less$star = include$5.$less$star;
    var Infix_$star$great = include$5.$star$great;
    var Infix_MonadExtensions = include$6.MonadExtensions;
    var Infix_$great$great$eq = include$6.$great$great$eq;
    var Infix_$eq$less$less = include$6.$eq$less$less;
    var Infix_$great$eq$great = include$6.$great$eq$great;
    var Infix_$less$eq$less = include$6.$less$eq$less;
    var Infix = {
      FunctorExtensions: Infix_FunctorExtensions,
      $less$$great: Infix_$less$$great,
      $less$$$great: Infix_$less$$$great,
      $less$: Infix_$less$,
      $$great: Infix_$$great,
      $less$at$great: Infix_$less$at$great,
      ApplyExtensions: Infix_ApplyExtensions,
      $less$star$great: Infix_$less$star$great,
      $less$star: Infix_$less$star,
      $star$great: Infix_$star$great,
      MonadExtensions: Infix_MonadExtensions,
      $great$great$eq: Infix_$great$great$eq,
      $eq$less$less: Infix_$eq$less$less,
      $great$eq$great: Infix_$great$eq$great,
      $less$eq$less: Infix_$less$eq$less
    };
    return {
            runRWST: runRWST,
            evalRWST: evalRWST,
            execRWST: execRWST,
            mapRWST: mapRWST,
            withRWST: withRWST,
            Functor: Functor,
            map: map,
            BsFunctorExtensions: include.BsFunctorExtensions,
            flipMap: include.flipMap,
            $$void: include.$$void,
            voidRight: include.voidRight,
            voidLeft: include.voidLeft,
            flap: include.flap,
            Apply: Apply,
            apply: apply,
            BsApplyExtensions: include$1.BsApplyExtensions,
            applyFirst: include$1.applyFirst,
            applySecond: include$1.applySecond,
            map2: include$1.map2,
            map3: include$1.map3,
            map4: include$1.map4,
            map5: include$1.map5,
            tuple2: include$1.tuple2,
            tuple3: include$1.tuple3,
            tuple4: include$1.tuple4,
            tuple5: include$1.tuple5,
            mapTuple2: include$1.mapTuple2,
            mapTuple3: include$1.mapTuple3,
            mapTuple4: include$1.mapTuple4,
            mapTuple5: include$1.mapTuple5,
            Applicative: Applicative,
            pure: pure,
            BsApplicativeExtensions: include$2.BsApplicativeExtensions,
            liftA1: include$2.liftA1,
            all: include$2.all,
            Monad: Monad,
            bind: flat_map,
            BsMonadExtensions: include$3.BsMonadExtensions,
            flatMap: include$3.flatMap,
            flatten: include$3.flatten,
            composeKleisli: include$3.composeKleisli,
            flipComposeKleisli: include$3.flipComposeKleisli,
            liftM1: include$3.liftM1,
            when_: include$3.when_,
            unless: include$3.unless,
            Infix: Infix
          };
  };
  return {
          runRWST: runRWST,
          evalRWST: evalRWST,
          execRWST: execRWST,
          mapRWST: mapRWST,
          withRWST: withRWST,
          map: map,
          applyWithAppendLog: applyWithAppendLog,
          pureWithEmptyLog: pureWithEmptyLog,
          bindWithAppendLog: bindWithAppendLog,
          WithEnvAndStateAndLog: WithEnvAndStateAndLog
        };
}

exports.RWSResult = RWSResult;
exports.WithMonad = WithMonad;
/* Relude__Relude_Extensions_Apply Not a pure module */
