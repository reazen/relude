// Generated by Melange
'use strict';

var Curry = require("melange.runtime/curry.js");
var Stdlib = require("./stdlib.js");
var Caml_array = require("melange.runtime/caml_array.js");
var Caml_option = require("melange.runtime/caml_option.js");
var Stdlib__Int = require("./int.js");
var Stdlib__Obj = require("./obj.js");
var Stdlib__Seq = require("./seq.js");
var Stdlib__Sys = require("./sys.js");
var Stdlib__List = require("./list.js");
var Stdlib__Array = require("./array.js");
var Stdlib__Random = require("./random.js");
var Stdlib__Hashtbl = require("./hashtbl.js");
var CamlinternalLazy = require("./camlinternalLazy.js");
var Caml_js_exceptions = require("melange.runtime/caml_js_exceptions.js");

function create(param) {
  return Stdlib__Obj.Ephemeron.create(1);
}

function get_key(t) {
  return Stdlib__Obj.Ephemeron.get_key(t, 0);
}

function get_key_copy(t) {
  return Stdlib__Obj.Ephemeron.get_key_copy(t, 0);
}

function set_key(t, k) {
  Stdlib__Obj.Ephemeron.set_key(t, 0, k);
}

function unset_key(t) {
  Stdlib__Obj.Ephemeron.unset_key(t, 0);
}

function check_key(t) {
  return Stdlib__Obj.Ephemeron.check_key(t, 0);
}

function blit_key(t1, t2) {
  Stdlib__Obj.Ephemeron.blit_key(t1, 0, t2, 0, 1);
}

function get_data(t) {
  return Stdlib__Obj.Ephemeron.get_data(t);
}

function get_data_copy(t) {
  return Stdlib__Obj.Ephemeron.get_data_copy(t);
}

function set_data(t, d) {
  Stdlib__Obj.Ephemeron.set_data(t, d);
}

function unset_data(t) {
  Stdlib__Obj.Ephemeron.unset_data(t);
}

function check_data(t) {
  return Stdlib__Obj.Ephemeron.check_data(t);
}

function blit_data(t1, t2) {
  Stdlib__Obj.Ephemeron.blit_data(t1, t2);
}

function make(key, data) {
  var eph = Stdlib__Obj.Ephemeron.create(1);
  Stdlib__Obj.Ephemeron.set_data(eph, data);
  set_key(eph, key);
  return eph;
}

function query(eph, key) {
  var k = Stdlib__Obj.Ephemeron.get_key(eph, 0);
  if (k !== undefined && Caml_option.valFromOption(k) === key) {
    return Stdlib__Obj.Ephemeron.get_data(eph);
  }
  
}

function MakeSeeded(H) {
  var create = function (k, d) {
    var c = Stdlib__Obj.Ephemeron.create(1);
    Stdlib__Obj.Ephemeron.set_data(c, d);
    set_key(c, k);
    return c;
  };
  var hash = H.hash;
  var equal = function (c, k) {
    var k$p = Stdlib__Obj.Ephemeron.get_key(c, 0);
    if (k$p !== undefined) {
      if (Curry._2(H.equal, k, Caml_option.valFromOption(k$p))) {
        return /* ETrue */0;
      } else {
        return /* EFalse */1;
      }
    } else {
      return /* EDead */2;
    }
  };
  var set_key_data = function (c, k, d) {
    Stdlib__Obj.Ephemeron.unset_data(c);
    set_key(c, k);
    Stdlib__Obj.Ephemeron.set_data(c, d);
  };
  var power_2_above = function (_x, n) {
    while(true) {
      var x = _x;
      if (x >= n) {
        return x;
      }
      if ((x << 1) > Stdlib__Sys.max_array_length) {
        return x;
      }
      _x = (x << 1);
      continue ;
    };
  };
  var prng = {
    LAZY_DONE: false,
    VAL: (function () {
        return Stdlib__Random.State.make_self_init(undefined);
      })
  };
  var create$1 = function (randomOpt, initial_size) {
    var random = randomOpt !== undefined ? randomOpt : Stdlib__Hashtbl.is_randomized(undefined);
    var s = power_2_above(16, initial_size);
    var seed = random ? Stdlib__Random.State.bits(CamlinternalLazy.force(prng)) : 0;
    return {
            size: 0,
            data: Caml_array.make(s, /* Empty */0),
            seed: seed,
            initial_size: s
          };
  };
  var clear = function (h) {
    h.size = 0;
    var len = h.data.length;
    for(var i = 0; i < len; ++i){
      Caml_array.set(h.data, i, /* Empty */0);
    }
  };
  var reset = function (h) {
    var len = h.data.length;
    if (len === h.initial_size) {
      return clear(h);
    } else {
      h.size = 0;
      h.data = Caml_array.make(h.initial_size, /* Empty */0);
      return ;
    }
  };
  var copy = function (h) {
    return {
            size: h.size,
            data: Stdlib__Array.copy(h.data),
            seed: h.seed,
            initial_size: h.initial_size
          };
  };
  var key_index = function (h, hkey) {
    return hkey & (h.data.length - 1 | 0);
  };
  var clean = function (h) {
    var do_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        if (check_key(param._1)) {
          return /* Cons */{
                  _0: param._0,
                  _1: param._1,
                  _2: do_bucket(param._2)
                };
        }
        h.size = h.size - 1 | 0;
        _param = param._2;
        continue ;
      };
    };
    var d = h.data;
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  var resize = function (h) {
    var odata = h.data;
    var osize = odata.length;
    var nsize = (osize << 1);
    clean(h);
    if (!(nsize < Stdlib__Sys.max_array_length && h.size >= (osize >>> 1))) {
      return ;
    }
    var ndata = Caml_array.make(nsize, /* Empty */0);
    h.data = ndata;
    var insert_bucket = function (param) {
      if (!param) {
        return ;
      }
      var hkey = param._0;
      insert_bucket(param._2);
      var nidx = key_index(h, hkey);
      Caml_array.set(ndata, nidx, /* Cons */{
            _0: hkey,
            _1: param._1,
            _2: Caml_array.get(ndata, nidx)
          });
    };
    for(var i = 0; i < osize; ++i){
      insert_bucket(Caml_array.get(odata, i));
    }
  };
  var add = function (h, key, info) {
    var hkey = Curry._2(hash, h.seed, key);
    var i = key_index(h, hkey);
    var container = create(key, info);
    var bucket_2 = Caml_array.get(h.data, i);
    var bucket = /* Cons */{
      _0: hkey,
      _1: container,
      _2: bucket_2
    };
    Caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(h);
    }
    
  };
  var remove = function (h, key) {
    var hkey = Curry._2(hash, h.seed, key);
    var remove_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        var hk = param._0;
        if (hkey !== hk) {
          return /* Cons */{
                  _0: hk,
                  _1: param._1,
                  _2: remove_bucket(param._2)
                };
        }
        var next = param._2;
        var c = param._1;
        var match = equal(c, key);
        switch (match) {
          case /* ETrue */0 :
              h.size = h.size - 1 | 0;
              return next;
          case /* EFalse */1 :
              return /* Cons */{
                      _0: hk,
                      _1: c,
                      _2: remove_bucket(next)
                    };
          case /* EDead */2 :
              h.size = h.size - 1 | 0;
              _param = next;
              continue ;
          
        }
      };
    };
    var i = key_index(h, hkey);
    Caml_array.set(h.data, i, remove_bucket(Caml_array.get(h.data, i)));
  };
  var find = function (h, key) {
    var hkey = Curry._2(hash, h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (param) {
        if (hkey === param._0) {
          var rest = param._2;
          var c = param._1;
          var match = equal(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          var d = get_data(c);
          if (d !== undefined) {
            return Caml_option.valFromOption(d);
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      }
      throw {
            RE_EXN_ID: Stdlib.Not_found,
            Error: new Error()
          };
    };
  };
  var find_opt = function (h, key) {
    var hkey = Curry._2(hash, h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (!param) {
        return ;
      }
      if (hkey === param._0) {
        var rest = param._2;
        var c = param._1;
        var match = equal(c, key);
        if (match) {
          _param = rest;
          continue ;
        }
        var d = get_data(c);
        if (d !== undefined) {
          return d;
        }
        _param = rest;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var find_all = function (h, key) {
    var hkey = Curry._2(hash, h.seed, key);
    var find_in_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* [] */0;
        }
        if (hkey === param._0) {
          var rest = param._2;
          var c = param._1;
          var match = equal(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          var d = get_data(c);
          if (d !== undefined) {
            return {
                    hd: Caml_option.valFromOption(d),
                    tl: find_in_bucket(rest)
                  };
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      };
    };
    return find_in_bucket(Caml_array.get(h.data, key_index(h, hkey)));
  };
  var replace = function (h, key, info) {
    var hkey = Curry._2(hash, h.seed, key);
    var i = key_index(h, hkey);
    var l = Caml_array.get(h.data, i);
    try {
      var _param = l;
      while(true) {
        var param = _param;
        if (param) {
          if (hkey === param._0) {
            var c = param._1;
            var match = equal(c, key);
            if (!match) {
              return set_key_data(c, key, info);
            }
            _param = param._2;
            continue ;
          }
          _param = param._2;
          continue ;
        }
        throw {
              RE_EXN_ID: Stdlib.Not_found,
              Error: new Error()
            };
      };
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === Stdlib.Not_found) {
        var container = create(key, info);
        Caml_array.set(h.data, i, /* Cons */{
              _0: hkey,
              _1: container,
              _2: l
            });
        h.size = h.size + 1 | 0;
        if (h.size > (h.data.length << 1)) {
          return resize(h);
        } else {
          return ;
        }
      }
      throw exn;
    }
  };
  var mem = function (h, key) {
    var hkey = Curry._2(hash, h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (!param) {
        return false;
      }
      if (param._0 === hkey) {
        var match = equal(param._1, key);
        if (!match) {
          return true;
        }
        _param = param._2;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var iter = function (f, h) {
    var do_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return ;
        }
        var c = param._1;
        var match = get_key(c);
        var match$1 = get_data(c);
        if (match !== undefined && match$1 !== undefined) {
          Curry._2(f, Caml_option.valFromOption(match), Caml_option.valFromOption(match$1));
        }
        _param = param._2;
        continue ;
      };
    };
    var d = h.data;
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      do_bucket(Caml_array.get(d, i));
    }
  };
  var fold = function (f, h, init) {
    var do_bucket = function (_b, _accu) {
      while(true) {
        var accu = _accu;
        var b = _b;
        if (!b) {
          return accu;
        }
        var c = b._1;
        var match = get_key(c);
        var match$1 = get_data(c);
        var accu$1 = match !== undefined && match$1 !== undefined ? Curry._3(f, Caml_option.valFromOption(match), Caml_option.valFromOption(match$1), accu) : accu;
        _accu = accu$1;
        _b = b._2;
        continue ;
      };
    };
    var d = h.data;
    var accu = init;
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      accu = do_bucket(Caml_array.get(d, i), accu);
    }
    return accu;
  };
  var filter_map_inplace = function (f, h) {
    var do_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        var rest = param._2;
        var c = param._1;
        var match = get_key(c);
        var match$1 = get_data(c);
        if (match !== undefined) {
          if (match$1 !== undefined) {
            var k = Caml_option.valFromOption(match);
            var new_d = Curry._2(f, k, Caml_option.valFromOption(match$1));
            if (new_d !== undefined) {
              set_key_data(c, k, Caml_option.valFromOption(new_d));
              return /* Cons */{
                      _0: param._0,
                      _1: c,
                      _2: do_bucket(rest)
                    };
            }
            _param = rest;
            continue ;
          }
          _param = rest;
          continue ;
        }
        _param = rest;
        continue ;
      };
    };
    var d = h.data;
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  var length = function (h) {
    return h.size;
  };
  var bucket_length = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (!param) {
        return accu;
      }
      _param = param._2;
      _accu = accu + 1 | 0;
      continue ;
    };
  };
  var stats = function (h) {
    var mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length(0, b));
          }), 0, h.data);
    var histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            var l = bucket_length(0, b);
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: h.size,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  var bucket_length_alive = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (!param) {
        return accu;
      }
      if (check_key(param._1)) {
        _param = param._2;
        _accu = accu + 1 | 0;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var stats_alive = function (h) {
    var size = {
      contents: 0
    };
    var mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length_alive(0, b));
          }), 0, h.data);
    var histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            var l = bucket_length_alive(0, b);
            size.contents = size.contents + l | 0;
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: size.contents,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  var to_seq = function (tbl) {
    var tbl_data = tbl.data;
    var aux = function (_i, _buck, _param) {
      while(true) {
        var buck = _buck;
        var i = _i;
        if (buck) {
          var next = buck._2;
          var c = buck._1;
          var match = get_key(c);
          var match$1 = get_data(c);
          if (match !== undefined) {
            if (match$1 !== undefined) {
              return /* Cons */{
                      _0: [
                        Caml_option.valFromOption(match),
                        Caml_option.valFromOption(match$1)
                      ],
                      _1: (function(i,next){
                      return function (param) {
                        return aux(i, next, param);
                      }
                      }(i,next))
                    };
            }
            _param = undefined;
            _buck = next;
            continue ;
          }
          _param = undefined;
          _buck = next;
          continue ;
        }
        if (i === tbl_data.length) {
          return /* Nil */0;
        }
        _param = undefined;
        _buck = Caml_array.get(tbl_data, i);
        _i = i + 1 | 0;
        continue ;
      };
    };
    return function (param) {
      return aux(0, /* Empty */0, param);
    };
  };
  var to_seq_keys = function (m) {
    var partial_arg = to_seq(m);
    return function (param) {
      return Stdlib__Seq.map((function (prim) {
                    return prim[0];
                  }), partial_arg, param);
    };
  };
  var to_seq_values = function (m) {
    var partial_arg = to_seq(m);
    return function (param) {
      return Stdlib__Seq.map((function (prim) {
                    return prim[1];
                  }), partial_arg, param);
    };
  };
  var add_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            add(tbl, param[0], param[1]);
          }), i);
  };
  var replace_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            replace(tbl, param[0], param[1]);
          }), i);
  };
  var of_seq = function (i) {
    var tbl = create$1(undefined, 16);
    replace_seq(tbl, i);
    return tbl;
  };
  return {
          create: create$1,
          clear: clear,
          reset: reset,
          copy: copy,
          add: add,
          remove: remove,
          find: find,
          find_opt: find_opt,
          find_all: find_all,
          replace: replace,
          mem: mem,
          iter: iter,
          filter_map_inplace: filter_map_inplace,
          fold: fold,
          length: length,
          stats: stats,
          to_seq: to_seq,
          to_seq_keys: to_seq_keys,
          to_seq_values: to_seq_values,
          add_seq: add_seq,
          replace_seq: replace_seq,
          of_seq: of_seq,
          clean: clean,
          stats_alive: stats_alive
        };
}

function Make(H) {
  var equal = H.equal;
  var hash = function (_seed, x) {
    return Curry._1(H.hash, x);
  };
  var create = function (k, d) {
    var c = Stdlib__Obj.Ephemeron.create(1);
    Stdlib__Obj.Ephemeron.set_data(c, d);
    set_key(c, k);
    return c;
  };
  var equal$1 = function (c, k) {
    var k$p = Stdlib__Obj.Ephemeron.get_key(c, 0);
    if (k$p !== undefined) {
      if (Curry._2(equal, k, Caml_option.valFromOption(k$p))) {
        return /* ETrue */0;
      } else {
        return /* EFalse */1;
      }
    } else {
      return /* EDead */2;
    }
  };
  var set_key_data = function (c, k, d) {
    Stdlib__Obj.Ephemeron.unset_data(c);
    set_key(c, k);
    Stdlib__Obj.Ephemeron.set_data(c, d);
  };
  var power_2_above = function (_x, n) {
    while(true) {
      var x = _x;
      if (x >= n) {
        return x;
      }
      if ((x << 1) > Stdlib__Sys.max_array_length) {
        return x;
      }
      _x = (x << 1);
      continue ;
    };
  };
  var prng = {
    LAZY_DONE: false,
    VAL: (function () {
        return Stdlib__Random.State.make_self_init(undefined);
      })
  };
  var create$1 = function (randomOpt, initial_size) {
    var random = randomOpt !== undefined ? randomOpt : Stdlib__Hashtbl.is_randomized(undefined);
    var s = power_2_above(16, initial_size);
    var seed = random ? Stdlib__Random.State.bits(CamlinternalLazy.force(prng)) : 0;
    return {
            size: 0,
            data: Caml_array.make(s, /* Empty */0),
            seed: seed,
            initial_size: s
          };
  };
  var clear = function (h) {
    h.size = 0;
    var len = h.data.length;
    for(var i = 0; i < len; ++i){
      Caml_array.set(h.data, i, /* Empty */0);
    }
  };
  var reset = function (h) {
    var len = h.data.length;
    if (len === h.initial_size) {
      return clear(h);
    } else {
      h.size = 0;
      h.data = Caml_array.make(h.initial_size, /* Empty */0);
      return ;
    }
  };
  var copy = function (h) {
    return {
            size: h.size,
            data: Stdlib__Array.copy(h.data),
            seed: h.seed,
            initial_size: h.initial_size
          };
  };
  var key_index = function (h, hkey) {
    return hkey & (h.data.length - 1 | 0);
  };
  var clean = function (h) {
    var do_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        if (check_key(param._1)) {
          return /* Cons */{
                  _0: param._0,
                  _1: param._1,
                  _2: do_bucket(param._2)
                };
        }
        h.size = h.size - 1 | 0;
        _param = param._2;
        continue ;
      };
    };
    var d = h.data;
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  var resize = function (h) {
    var odata = h.data;
    var osize = odata.length;
    var nsize = (osize << 1);
    clean(h);
    if (!(nsize < Stdlib__Sys.max_array_length && h.size >= (osize >>> 1))) {
      return ;
    }
    var ndata = Caml_array.make(nsize, /* Empty */0);
    h.data = ndata;
    var insert_bucket = function (param) {
      if (!param) {
        return ;
      }
      var hkey = param._0;
      insert_bucket(param._2);
      var nidx = key_index(h, hkey);
      Caml_array.set(ndata, nidx, /* Cons */{
            _0: hkey,
            _1: param._1,
            _2: Caml_array.get(ndata, nidx)
          });
    };
    for(var i = 0; i < osize; ++i){
      insert_bucket(Caml_array.get(odata, i));
    }
  };
  var add = function (h, key, info) {
    var hkey = hash(h.seed, key);
    var i = key_index(h, hkey);
    var container = create(key, info);
    var bucket_2 = Caml_array.get(h.data, i);
    var bucket = /* Cons */{
      _0: hkey,
      _1: container,
      _2: bucket_2
    };
    Caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(h);
    }
    
  };
  var remove = function (h, key) {
    var hkey = hash(h.seed, key);
    var remove_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        var hk = param._0;
        if (hkey !== hk) {
          return /* Cons */{
                  _0: hk,
                  _1: param._1,
                  _2: remove_bucket(param._2)
                };
        }
        var next = param._2;
        var c = param._1;
        var match = equal$1(c, key);
        switch (match) {
          case /* ETrue */0 :
              h.size = h.size - 1 | 0;
              return next;
          case /* EFalse */1 :
              return /* Cons */{
                      _0: hk,
                      _1: c,
                      _2: remove_bucket(next)
                    };
          case /* EDead */2 :
              h.size = h.size - 1 | 0;
              _param = next;
              continue ;
          
        }
      };
    };
    var i = key_index(h, hkey);
    Caml_array.set(h.data, i, remove_bucket(Caml_array.get(h.data, i)));
  };
  var find = function (h, key) {
    var hkey = hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (param) {
        if (hkey === param._0) {
          var rest = param._2;
          var c = param._1;
          var match = equal$1(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          var d = get_data(c);
          if (d !== undefined) {
            return Caml_option.valFromOption(d);
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      }
      throw {
            RE_EXN_ID: Stdlib.Not_found,
            Error: new Error()
          };
    };
  };
  var find_opt = function (h, key) {
    var hkey = hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (!param) {
        return ;
      }
      if (hkey === param._0) {
        var rest = param._2;
        var c = param._1;
        var match = equal$1(c, key);
        if (match) {
          _param = rest;
          continue ;
        }
        var d = get_data(c);
        if (d !== undefined) {
          return d;
        }
        _param = rest;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var find_all = function (h, key) {
    var hkey = hash(h.seed, key);
    var find_in_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* [] */0;
        }
        if (hkey === param._0) {
          var rest = param._2;
          var c = param._1;
          var match = equal$1(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          var d = get_data(c);
          if (d !== undefined) {
            return {
                    hd: Caml_option.valFromOption(d),
                    tl: find_in_bucket(rest)
                  };
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      };
    };
    return find_in_bucket(Caml_array.get(h.data, key_index(h, hkey)));
  };
  var replace = function (h, key, info) {
    var hkey = hash(h.seed, key);
    var i = key_index(h, hkey);
    var l = Caml_array.get(h.data, i);
    try {
      var _param = l;
      while(true) {
        var param = _param;
        if (param) {
          if (hkey === param._0) {
            var c = param._1;
            var match = equal$1(c, key);
            if (!match) {
              return set_key_data(c, key, info);
            }
            _param = param._2;
            continue ;
          }
          _param = param._2;
          continue ;
        }
        throw {
              RE_EXN_ID: Stdlib.Not_found,
              Error: new Error()
            };
      };
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === Stdlib.Not_found) {
        var container = create(key, info);
        Caml_array.set(h.data, i, /* Cons */{
              _0: hkey,
              _1: container,
              _2: l
            });
        h.size = h.size + 1 | 0;
        if (h.size > (h.data.length << 1)) {
          return resize(h);
        } else {
          return ;
        }
      }
      throw exn;
    }
  };
  var mem = function (h, key) {
    var hkey = hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (!param) {
        return false;
      }
      if (param._0 === hkey) {
        var match = equal$1(param._1, key);
        if (!match) {
          return true;
        }
        _param = param._2;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var iter = function (f, h) {
    var do_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return ;
        }
        var c = param._1;
        var match = get_key(c);
        var match$1 = get_data(c);
        if (match !== undefined && match$1 !== undefined) {
          Curry._2(f, Caml_option.valFromOption(match), Caml_option.valFromOption(match$1));
        }
        _param = param._2;
        continue ;
      };
    };
    var d = h.data;
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      do_bucket(Caml_array.get(d, i));
    }
  };
  var fold = function (f, h, init) {
    var do_bucket = function (_b, _accu) {
      while(true) {
        var accu = _accu;
        var b = _b;
        if (!b) {
          return accu;
        }
        var c = b._1;
        var match = get_key(c);
        var match$1 = get_data(c);
        var accu$1 = match !== undefined && match$1 !== undefined ? Curry._3(f, Caml_option.valFromOption(match), Caml_option.valFromOption(match$1), accu) : accu;
        _accu = accu$1;
        _b = b._2;
        continue ;
      };
    };
    var d = h.data;
    var accu = init;
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      accu = do_bucket(Caml_array.get(d, i), accu);
    }
    return accu;
  };
  var filter_map_inplace = function (f, h) {
    var do_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        var rest = param._2;
        var c = param._1;
        var match = get_key(c);
        var match$1 = get_data(c);
        if (match !== undefined) {
          if (match$1 !== undefined) {
            var k = Caml_option.valFromOption(match);
            var new_d = Curry._2(f, k, Caml_option.valFromOption(match$1));
            if (new_d !== undefined) {
              set_key_data(c, k, Caml_option.valFromOption(new_d));
              return /* Cons */{
                      _0: param._0,
                      _1: c,
                      _2: do_bucket(rest)
                    };
            }
            _param = rest;
            continue ;
          }
          _param = rest;
          continue ;
        }
        _param = rest;
        continue ;
      };
    };
    var d = h.data;
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  var length = function (h) {
    return h.size;
  };
  var bucket_length = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (!param) {
        return accu;
      }
      _param = param._2;
      _accu = accu + 1 | 0;
      continue ;
    };
  };
  var stats = function (h) {
    var mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length(0, b));
          }), 0, h.data);
    var histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            var l = bucket_length(0, b);
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: h.size,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  var bucket_length_alive = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (!param) {
        return accu;
      }
      if (check_key(param._1)) {
        _param = param._2;
        _accu = accu + 1 | 0;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var stats_alive = function (h) {
    var size = {
      contents: 0
    };
    var mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length_alive(0, b));
          }), 0, h.data);
    var histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            var l = bucket_length_alive(0, b);
            size.contents = size.contents + l | 0;
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: size.contents,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  var to_seq = function (tbl) {
    var tbl_data = tbl.data;
    var aux = function (_i, _buck, _param) {
      while(true) {
        var buck = _buck;
        var i = _i;
        if (buck) {
          var next = buck._2;
          var c = buck._1;
          var match = get_key(c);
          var match$1 = get_data(c);
          if (match !== undefined) {
            if (match$1 !== undefined) {
              return /* Cons */{
                      _0: [
                        Caml_option.valFromOption(match),
                        Caml_option.valFromOption(match$1)
                      ],
                      _1: (function(i,next){
                      return function (param) {
                        return aux(i, next, param);
                      }
                      }(i,next))
                    };
            }
            _param = undefined;
            _buck = next;
            continue ;
          }
          _param = undefined;
          _buck = next;
          continue ;
        }
        if (i === tbl_data.length) {
          return /* Nil */0;
        }
        _param = undefined;
        _buck = Caml_array.get(tbl_data, i);
        _i = i + 1 | 0;
        continue ;
      };
    };
    return function (param) {
      return aux(0, /* Empty */0, param);
    };
  };
  var to_seq_keys = function (m) {
    var partial_arg = to_seq(m);
    return function (param) {
      return Stdlib__Seq.map((function (prim) {
                    return prim[0];
                  }), partial_arg, param);
    };
  };
  var to_seq_values = function (m) {
    var partial_arg = to_seq(m);
    return function (param) {
      return Stdlib__Seq.map((function (prim) {
                    return prim[1];
                  }), partial_arg, param);
    };
  };
  var add_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            add(tbl, param[0], param[1]);
          }), i);
  };
  var replace_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            replace(tbl, param[0], param[1]);
          }), i);
  };
  var create$2 = function (sz) {
    return create$1(false, sz);
  };
  var of_seq = function (i) {
    var tbl = create$1(false, 16);
    replace_seq(tbl, i);
    return tbl;
  };
  return {
          create: create$2,
          clear: clear,
          reset: reset,
          copy: copy,
          add: add,
          remove: remove,
          find: find,
          find_opt: find_opt,
          find_all: find_all,
          replace: replace,
          mem: mem,
          iter: iter,
          filter_map_inplace: filter_map_inplace,
          fold: fold,
          length: length,
          stats: stats,
          to_seq: to_seq,
          to_seq_keys: to_seq_keys,
          to_seq_values: to_seq_values,
          add_seq: add_seq,
          replace_seq: replace_seq,
          of_seq: of_seq,
          clean: clean,
          stats_alive: stats_alive
        };
}

function make$1(param) {
  return {
          contents: /* [] */0
        };
}

function add(b, k, d) {
  b.contents = {
    hd: make(k, d),
    tl: b.contents
  };
}

function test_key(k, e) {
  var x = Stdlib__Obj.Ephemeron.get_key(e, 0);
  if (x !== undefined) {
    return Caml_option.valFromOption(x) === k;
  } else {
    return false;
  }
}

function remove(b, k) {
  var _l = b.contents;
  var _acc = /* [] */0;
  while(true) {
    var acc = _acc;
    var l = _l;
    if (!l) {
      return ;
    }
    var h = l.hd;
    if (test_key(k, h)) {
      b.contents = Stdlib__List.rev_append(acc, l.tl);
      return ;
    }
    _acc = {
      hd: h,
      tl: acc
    };
    _l = l.tl;
    continue ;
  };
}

function find(b, k) {
  var e = Stdlib__List.find_opt((function (param) {
          return test_key(k, param);
        }), b.contents);
  if (e !== undefined) {
    return Stdlib__Obj.Ephemeron.get_data(Caml_option.valFromOption(e));
  }
  
}

function length(b) {
  return Stdlib__List.length(b.contents);
}

function clear(b) {
  b.contents = /* [] */0;
}

function create$1(param) {
  return Stdlib__Obj.Ephemeron.create(2);
}

function get_key1(t) {
  return Stdlib__Obj.Ephemeron.get_key(t, 0);
}

function get_key1_copy(t) {
  return Stdlib__Obj.Ephemeron.get_key_copy(t, 0);
}

function set_key1(t, k) {
  Stdlib__Obj.Ephemeron.set_key(t, 0, k);
}

function unset_key1(t) {
  Stdlib__Obj.Ephemeron.unset_key(t, 0);
}

function check_key1(t) {
  return Stdlib__Obj.Ephemeron.check_key(t, 0);
}

function get_key2(t) {
  return Stdlib__Obj.Ephemeron.get_key(t, 1);
}

function get_key2_copy(t) {
  return Stdlib__Obj.Ephemeron.get_key_copy(t, 1);
}

function set_key2(t, k) {
  Stdlib__Obj.Ephemeron.set_key(t, 1, k);
}

function unset_key2(t) {
  Stdlib__Obj.Ephemeron.unset_key(t, 1);
}

function check_key2(t) {
  return Stdlib__Obj.Ephemeron.check_key(t, 1);
}

function blit_key1(t1, t2) {
  Stdlib__Obj.Ephemeron.blit_key(t1, 0, t2, 0, 1);
}

function blit_key2(t1, t2) {
  Stdlib__Obj.Ephemeron.blit_key(t1, 1, t2, 1, 1);
}

function blit_key12(t1, t2) {
  Stdlib__Obj.Ephemeron.blit_key(t1, 0, t2, 0, 2);
}

function get_data$1(t) {
  return Stdlib__Obj.Ephemeron.get_data(t);
}

function get_data_copy$1(t) {
  return Stdlib__Obj.Ephemeron.get_data_copy(t);
}

function set_data$1(t, d) {
  Stdlib__Obj.Ephemeron.set_data(t, d);
}

function unset_data$1(t) {
  Stdlib__Obj.Ephemeron.unset_data(t);
}

function check_data$1(t) {
  return Stdlib__Obj.Ephemeron.check_data(t);
}

function blit_data$1(t1, t2) {
  Stdlib__Obj.Ephemeron.blit_data(t1, t2);
}

function make$2(key1, key2, data) {
  var eph = Stdlib__Obj.Ephemeron.create(2);
  Stdlib__Obj.Ephemeron.set_data(eph, data);
  set_key1(eph, key1);
  set_key2(eph, key2);
  return eph;
}

function query$1(eph, key1, key2) {
  var k = Stdlib__Obj.Ephemeron.get_key(eph, 0);
  if (k === undefined) {
    return ;
  }
  if (Caml_option.valFromOption(k) !== key1) {
    return ;
  }
  var k$1 = Stdlib__Obj.Ephemeron.get_key(eph, 1);
  if (k$1 !== undefined && Caml_option.valFromOption(k$1) === key2) {
    return Stdlib__Obj.Ephemeron.get_data(eph);
  }
  
}

function MakeSeeded$1(H1, H2) {
  var create = function (param, d) {
    var c = Stdlib__Obj.Ephemeron.create(2);
    Stdlib__Obj.Ephemeron.set_data(c, d);
    set_key1(c, param[0]);
    set_key2(c, param[1]);
    return c;
  };
  var hash = function (seed, param) {
    return Curry._2(H1.hash, seed, param[0]) + Math.imul(Curry._2(H2.hash, seed, param[1]), 65599) | 0;
  };
  var equal = function (c, param) {
    var match = Stdlib__Obj.Ephemeron.get_key(c, 0);
    var match$1 = Stdlib__Obj.Ephemeron.get_key(c, 1);
    if (match !== undefined && match$1 !== undefined) {
      if (Curry._2(H1.equal, param[0], Caml_option.valFromOption(match)) && Curry._2(H2.equal, param[1], Caml_option.valFromOption(match$1))) {
        return /* ETrue */0;
      } else {
        return /* EFalse */1;
      }
    } else {
      return /* EDead */2;
    }
  };
  var get_key = function (c) {
    var match = Stdlib__Obj.Ephemeron.get_key(c, 0);
    var match$1 = Stdlib__Obj.Ephemeron.get_key(c, 1);
    if (match !== undefined && match$1 !== undefined) {
      return [
              Caml_option.valFromOption(match),
              Caml_option.valFromOption(match$1)
            ];
    }
    
  };
  var set_key_data = function (c, param, d) {
    Stdlib__Obj.Ephemeron.unset_data(c);
    set_key1(c, param[0]);
    set_key2(c, param[1]);
    Stdlib__Obj.Ephemeron.set_data(c, d);
  };
  var check_key = function (c) {
    if (Stdlib__Obj.Ephemeron.check_key(c, 0)) {
      return Stdlib__Obj.Ephemeron.check_key(c, 1);
    } else {
      return false;
    }
  };
  var power_2_above = function (_x, n) {
    while(true) {
      var x = _x;
      if (x >= n) {
        return x;
      }
      if ((x << 1) > Stdlib__Sys.max_array_length) {
        return x;
      }
      _x = (x << 1);
      continue ;
    };
  };
  var prng = {
    LAZY_DONE: false,
    VAL: (function () {
        return Stdlib__Random.State.make_self_init(undefined);
      })
  };
  var create$1 = function (randomOpt, initial_size) {
    var random = randomOpt !== undefined ? randomOpt : Stdlib__Hashtbl.is_randomized(undefined);
    var s = power_2_above(16, initial_size);
    var seed = random ? Stdlib__Random.State.bits(CamlinternalLazy.force(prng)) : 0;
    return {
            size: 0,
            data: Caml_array.make(s, /* Empty */0),
            seed: seed,
            initial_size: s
          };
  };
  var clear = function (h) {
    h.size = 0;
    var len = h.data.length;
    for(var i = 0; i < len; ++i){
      Caml_array.set(h.data, i, /* Empty */0);
    }
  };
  var reset = function (h) {
    var len = h.data.length;
    if (len === h.initial_size) {
      return clear(h);
    } else {
      h.size = 0;
      h.data = Caml_array.make(h.initial_size, /* Empty */0);
      return ;
    }
  };
  var copy = function (h) {
    return {
            size: h.size,
            data: Stdlib__Array.copy(h.data),
            seed: h.seed,
            initial_size: h.initial_size
          };
  };
  var key_index = function (h, hkey) {
    return hkey & (h.data.length - 1 | 0);
  };
  var clean = function (h) {
    var do_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        if (check_key(param._1)) {
          return /* Cons */{
                  _0: param._0,
                  _1: param._1,
                  _2: do_bucket(param._2)
                };
        }
        h.size = h.size - 1 | 0;
        _param = param._2;
        continue ;
      };
    };
    var d = h.data;
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  var resize = function (h) {
    var odata = h.data;
    var osize = odata.length;
    var nsize = (osize << 1);
    clean(h);
    if (!(nsize < Stdlib__Sys.max_array_length && h.size >= (osize >>> 1))) {
      return ;
    }
    var ndata = Caml_array.make(nsize, /* Empty */0);
    h.data = ndata;
    var insert_bucket = function (param) {
      if (!param) {
        return ;
      }
      var hkey = param._0;
      insert_bucket(param._2);
      var nidx = key_index(h, hkey);
      Caml_array.set(ndata, nidx, /* Cons */{
            _0: hkey,
            _1: param._1,
            _2: Caml_array.get(ndata, nidx)
          });
    };
    for(var i = 0; i < osize; ++i){
      insert_bucket(Caml_array.get(odata, i));
    }
  };
  var add = function (h, key, info) {
    var hkey = hash(h.seed, key);
    var i = key_index(h, hkey);
    var container = create(key, info);
    var bucket_2 = Caml_array.get(h.data, i);
    var bucket = /* Cons */{
      _0: hkey,
      _1: container,
      _2: bucket_2
    };
    Caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(h);
    }
    
  };
  var remove = function (h, key) {
    var hkey = hash(h.seed, key);
    var remove_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        var hk = param._0;
        if (hkey !== hk) {
          return /* Cons */{
                  _0: hk,
                  _1: param._1,
                  _2: remove_bucket(param._2)
                };
        }
        var next = param._2;
        var c = param._1;
        var match = equal(c, key);
        switch (match) {
          case /* ETrue */0 :
              h.size = h.size - 1 | 0;
              return next;
          case /* EFalse */1 :
              return /* Cons */{
                      _0: hk,
                      _1: c,
                      _2: remove_bucket(next)
                    };
          case /* EDead */2 :
              h.size = h.size - 1 | 0;
              _param = next;
              continue ;
          
        }
      };
    };
    var i = key_index(h, hkey);
    Caml_array.set(h.data, i, remove_bucket(Caml_array.get(h.data, i)));
  };
  var find = function (h, key) {
    var hkey = hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (param) {
        if (hkey === param._0) {
          var rest = param._2;
          var c = param._1;
          var match = equal(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          var d = get_data$1(c);
          if (d !== undefined) {
            return Caml_option.valFromOption(d);
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      }
      throw {
            RE_EXN_ID: Stdlib.Not_found,
            Error: new Error()
          };
    };
  };
  var find_opt = function (h, key) {
    var hkey = hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (!param) {
        return ;
      }
      if (hkey === param._0) {
        var rest = param._2;
        var c = param._1;
        var match = equal(c, key);
        if (match) {
          _param = rest;
          continue ;
        }
        var d = get_data$1(c);
        if (d !== undefined) {
          return d;
        }
        _param = rest;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var find_all = function (h, key) {
    var hkey = hash(h.seed, key);
    var find_in_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* [] */0;
        }
        if (hkey === param._0) {
          var rest = param._2;
          var c = param._1;
          var match = equal(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          var d = get_data$1(c);
          if (d !== undefined) {
            return {
                    hd: Caml_option.valFromOption(d),
                    tl: find_in_bucket(rest)
                  };
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      };
    };
    return find_in_bucket(Caml_array.get(h.data, key_index(h, hkey)));
  };
  var replace = function (h, key, info) {
    var hkey = hash(h.seed, key);
    var i = key_index(h, hkey);
    var l = Caml_array.get(h.data, i);
    try {
      var _param = l;
      while(true) {
        var param = _param;
        if (param) {
          if (hkey === param._0) {
            var c = param._1;
            var match = equal(c, key);
            if (!match) {
              return set_key_data(c, key, info);
            }
            _param = param._2;
            continue ;
          }
          _param = param._2;
          continue ;
        }
        throw {
              RE_EXN_ID: Stdlib.Not_found,
              Error: new Error()
            };
      };
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === Stdlib.Not_found) {
        var container = create(key, info);
        Caml_array.set(h.data, i, /* Cons */{
              _0: hkey,
              _1: container,
              _2: l
            });
        h.size = h.size + 1 | 0;
        if (h.size > (h.data.length << 1)) {
          return resize(h);
        } else {
          return ;
        }
      }
      throw exn;
    }
  };
  var mem = function (h, key) {
    var hkey = hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (!param) {
        return false;
      }
      if (param._0 === hkey) {
        var match = equal(param._1, key);
        if (!match) {
          return true;
        }
        _param = param._2;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var iter = function (f, h) {
    var do_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return ;
        }
        var c = param._1;
        var match = get_key(c);
        var match$1 = get_data$1(c);
        if (match !== undefined && match$1 !== undefined) {
          Curry._2(f, Caml_option.valFromOption(match), Caml_option.valFromOption(match$1));
        }
        _param = param._2;
        continue ;
      };
    };
    var d = h.data;
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      do_bucket(Caml_array.get(d, i));
    }
  };
  var fold = function (f, h, init) {
    var do_bucket = function (_b, _accu) {
      while(true) {
        var accu = _accu;
        var b = _b;
        if (!b) {
          return accu;
        }
        var c = b._1;
        var match = get_key(c);
        var match$1 = get_data$1(c);
        var accu$1 = match !== undefined && match$1 !== undefined ? Curry._3(f, Caml_option.valFromOption(match), Caml_option.valFromOption(match$1), accu) : accu;
        _accu = accu$1;
        _b = b._2;
        continue ;
      };
    };
    var d = h.data;
    var accu = init;
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      accu = do_bucket(Caml_array.get(d, i), accu);
    }
    return accu;
  };
  var filter_map_inplace = function (f, h) {
    var do_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        var rest = param._2;
        var c = param._1;
        var match = get_key(c);
        var match$1 = get_data$1(c);
        if (match !== undefined) {
          if (match$1 !== undefined) {
            var k = Caml_option.valFromOption(match);
            var new_d = Curry._2(f, k, Caml_option.valFromOption(match$1));
            if (new_d !== undefined) {
              set_key_data(c, k, Caml_option.valFromOption(new_d));
              return /* Cons */{
                      _0: param._0,
                      _1: c,
                      _2: do_bucket(rest)
                    };
            }
            _param = rest;
            continue ;
          }
          _param = rest;
          continue ;
        }
        _param = rest;
        continue ;
      };
    };
    var d = h.data;
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  var length = function (h) {
    return h.size;
  };
  var bucket_length = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (!param) {
        return accu;
      }
      _param = param._2;
      _accu = accu + 1 | 0;
      continue ;
    };
  };
  var stats = function (h) {
    var mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length(0, b));
          }), 0, h.data);
    var histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            var l = bucket_length(0, b);
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: h.size,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  var bucket_length_alive = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (!param) {
        return accu;
      }
      if (check_key(param._1)) {
        _param = param._2;
        _accu = accu + 1 | 0;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var stats_alive = function (h) {
    var size = {
      contents: 0
    };
    var mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length_alive(0, b));
          }), 0, h.data);
    var histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            var l = bucket_length_alive(0, b);
            size.contents = size.contents + l | 0;
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: size.contents,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  var to_seq = function (tbl) {
    var tbl_data = tbl.data;
    var aux = function (_i, _buck, _param) {
      while(true) {
        var buck = _buck;
        var i = _i;
        if (buck) {
          var next = buck._2;
          var c = buck._1;
          var match = get_key(c);
          var match$1 = get_data$1(c);
          if (match !== undefined) {
            if (match$1 !== undefined) {
              return /* Cons */{
                      _0: [
                        Caml_option.valFromOption(match),
                        Caml_option.valFromOption(match$1)
                      ],
                      _1: (function(i,next){
                      return function (param) {
                        return aux(i, next, param);
                      }
                      }(i,next))
                    };
            }
            _param = undefined;
            _buck = next;
            continue ;
          }
          _param = undefined;
          _buck = next;
          continue ;
        }
        if (i === tbl_data.length) {
          return /* Nil */0;
        }
        _param = undefined;
        _buck = Caml_array.get(tbl_data, i);
        _i = i + 1 | 0;
        continue ;
      };
    };
    return function (param) {
      return aux(0, /* Empty */0, param);
    };
  };
  var to_seq_keys = function (m) {
    var partial_arg = to_seq(m);
    return function (param) {
      return Stdlib__Seq.map((function (prim) {
                    return prim[0];
                  }), partial_arg, param);
    };
  };
  var to_seq_values = function (m) {
    var partial_arg = to_seq(m);
    return function (param) {
      return Stdlib__Seq.map((function (prim) {
                    return prim[1];
                  }), partial_arg, param);
    };
  };
  var add_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            add(tbl, param[0], param[1]);
          }), i);
  };
  var replace_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            replace(tbl, param[0], param[1]);
          }), i);
  };
  var of_seq = function (i) {
    var tbl = create$1(undefined, 16);
    replace_seq(tbl, i);
    return tbl;
  };
  return {
          create: create$1,
          clear: clear,
          reset: reset,
          copy: copy,
          add: add,
          remove: remove,
          find: find,
          find_opt: find_opt,
          find_all: find_all,
          replace: replace,
          mem: mem,
          iter: iter,
          filter_map_inplace: filter_map_inplace,
          fold: fold,
          length: length,
          stats: stats,
          to_seq: to_seq,
          to_seq_keys: to_seq_keys,
          to_seq_values: to_seq_values,
          add_seq: add_seq,
          replace_seq: replace_seq,
          of_seq: of_seq,
          clean: clean,
          stats_alive: stats_alive
        };
}

function Make$1(H1, H2) {
  var equal = H2.equal;
  var equal$1 = H1.equal;
  var create = function (param, d) {
    var c = Stdlib__Obj.Ephemeron.create(2);
    Stdlib__Obj.Ephemeron.set_data(c, d);
    set_key1(c, param[0]);
    set_key2(c, param[1]);
    return c;
  };
  var hash = function (seed, param) {
    return Curry._1(H1.hash, param[0]) + Math.imul(Curry._1(H2.hash, param[1]), 65599) | 0;
  };
  var equal$2 = function (c, param) {
    var match = Stdlib__Obj.Ephemeron.get_key(c, 0);
    var match$1 = Stdlib__Obj.Ephemeron.get_key(c, 1);
    if (match !== undefined && match$1 !== undefined) {
      if (Curry._2(equal$1, param[0], Caml_option.valFromOption(match)) && Curry._2(equal, param[1], Caml_option.valFromOption(match$1))) {
        return /* ETrue */0;
      } else {
        return /* EFalse */1;
      }
    } else {
      return /* EDead */2;
    }
  };
  var get_key = function (c) {
    var match = Stdlib__Obj.Ephemeron.get_key(c, 0);
    var match$1 = Stdlib__Obj.Ephemeron.get_key(c, 1);
    if (match !== undefined && match$1 !== undefined) {
      return [
              Caml_option.valFromOption(match),
              Caml_option.valFromOption(match$1)
            ];
    }
    
  };
  var set_key_data = function (c, param, d) {
    Stdlib__Obj.Ephemeron.unset_data(c);
    set_key1(c, param[0]);
    set_key2(c, param[1]);
    Stdlib__Obj.Ephemeron.set_data(c, d);
  };
  var check_key = function (c) {
    if (Stdlib__Obj.Ephemeron.check_key(c, 0)) {
      return Stdlib__Obj.Ephemeron.check_key(c, 1);
    } else {
      return false;
    }
  };
  var power_2_above = function (_x, n) {
    while(true) {
      var x = _x;
      if (x >= n) {
        return x;
      }
      if ((x << 1) > Stdlib__Sys.max_array_length) {
        return x;
      }
      _x = (x << 1);
      continue ;
    };
  };
  var prng = {
    LAZY_DONE: false,
    VAL: (function () {
        return Stdlib__Random.State.make_self_init(undefined);
      })
  };
  var create$1 = function (randomOpt, initial_size) {
    var random = randomOpt !== undefined ? randomOpt : Stdlib__Hashtbl.is_randomized(undefined);
    var s = power_2_above(16, initial_size);
    var seed = random ? Stdlib__Random.State.bits(CamlinternalLazy.force(prng)) : 0;
    return {
            size: 0,
            data: Caml_array.make(s, /* Empty */0),
            seed: seed,
            initial_size: s
          };
  };
  var clear = function (h) {
    h.size = 0;
    var len = h.data.length;
    for(var i = 0; i < len; ++i){
      Caml_array.set(h.data, i, /* Empty */0);
    }
  };
  var reset = function (h) {
    var len = h.data.length;
    if (len === h.initial_size) {
      return clear(h);
    } else {
      h.size = 0;
      h.data = Caml_array.make(h.initial_size, /* Empty */0);
      return ;
    }
  };
  var copy = function (h) {
    return {
            size: h.size,
            data: Stdlib__Array.copy(h.data),
            seed: h.seed,
            initial_size: h.initial_size
          };
  };
  var key_index = function (h, hkey) {
    return hkey & (h.data.length - 1 | 0);
  };
  var clean = function (h) {
    var do_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        if (check_key(param._1)) {
          return /* Cons */{
                  _0: param._0,
                  _1: param._1,
                  _2: do_bucket(param._2)
                };
        }
        h.size = h.size - 1 | 0;
        _param = param._2;
        continue ;
      };
    };
    var d = h.data;
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  var resize = function (h) {
    var odata = h.data;
    var osize = odata.length;
    var nsize = (osize << 1);
    clean(h);
    if (!(nsize < Stdlib__Sys.max_array_length && h.size >= (osize >>> 1))) {
      return ;
    }
    var ndata = Caml_array.make(nsize, /* Empty */0);
    h.data = ndata;
    var insert_bucket = function (param) {
      if (!param) {
        return ;
      }
      var hkey = param._0;
      insert_bucket(param._2);
      var nidx = key_index(h, hkey);
      Caml_array.set(ndata, nidx, /* Cons */{
            _0: hkey,
            _1: param._1,
            _2: Caml_array.get(ndata, nidx)
          });
    };
    for(var i = 0; i < osize; ++i){
      insert_bucket(Caml_array.get(odata, i));
    }
  };
  var add = function (h, key, info) {
    var hkey = hash(h.seed, key);
    var i = key_index(h, hkey);
    var container = create(key, info);
    var bucket_2 = Caml_array.get(h.data, i);
    var bucket = /* Cons */{
      _0: hkey,
      _1: container,
      _2: bucket_2
    };
    Caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(h);
    }
    
  };
  var remove = function (h, key) {
    var hkey = hash(h.seed, key);
    var remove_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        var hk = param._0;
        if (hkey !== hk) {
          return /* Cons */{
                  _0: hk,
                  _1: param._1,
                  _2: remove_bucket(param._2)
                };
        }
        var next = param._2;
        var c = param._1;
        var match = equal$2(c, key);
        switch (match) {
          case /* ETrue */0 :
              h.size = h.size - 1 | 0;
              return next;
          case /* EFalse */1 :
              return /* Cons */{
                      _0: hk,
                      _1: c,
                      _2: remove_bucket(next)
                    };
          case /* EDead */2 :
              h.size = h.size - 1 | 0;
              _param = next;
              continue ;
          
        }
      };
    };
    var i = key_index(h, hkey);
    Caml_array.set(h.data, i, remove_bucket(Caml_array.get(h.data, i)));
  };
  var find = function (h, key) {
    var hkey = hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (param) {
        if (hkey === param._0) {
          var rest = param._2;
          var c = param._1;
          var match = equal$2(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          var d = get_data$1(c);
          if (d !== undefined) {
            return Caml_option.valFromOption(d);
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      }
      throw {
            RE_EXN_ID: Stdlib.Not_found,
            Error: new Error()
          };
    };
  };
  var find_opt = function (h, key) {
    var hkey = hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (!param) {
        return ;
      }
      if (hkey === param._0) {
        var rest = param._2;
        var c = param._1;
        var match = equal$2(c, key);
        if (match) {
          _param = rest;
          continue ;
        }
        var d = get_data$1(c);
        if (d !== undefined) {
          return d;
        }
        _param = rest;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var find_all = function (h, key) {
    var hkey = hash(h.seed, key);
    var find_in_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* [] */0;
        }
        if (hkey === param._0) {
          var rest = param._2;
          var c = param._1;
          var match = equal$2(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          var d = get_data$1(c);
          if (d !== undefined) {
            return {
                    hd: Caml_option.valFromOption(d),
                    tl: find_in_bucket(rest)
                  };
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      };
    };
    return find_in_bucket(Caml_array.get(h.data, key_index(h, hkey)));
  };
  var replace = function (h, key, info) {
    var hkey = hash(h.seed, key);
    var i = key_index(h, hkey);
    var l = Caml_array.get(h.data, i);
    try {
      var _param = l;
      while(true) {
        var param = _param;
        if (param) {
          if (hkey === param._0) {
            var c = param._1;
            var match = equal$2(c, key);
            if (!match) {
              return set_key_data(c, key, info);
            }
            _param = param._2;
            continue ;
          }
          _param = param._2;
          continue ;
        }
        throw {
              RE_EXN_ID: Stdlib.Not_found,
              Error: new Error()
            };
      };
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === Stdlib.Not_found) {
        var container = create(key, info);
        Caml_array.set(h.data, i, /* Cons */{
              _0: hkey,
              _1: container,
              _2: l
            });
        h.size = h.size + 1 | 0;
        if (h.size > (h.data.length << 1)) {
          return resize(h);
        } else {
          return ;
        }
      }
      throw exn;
    }
  };
  var mem = function (h, key) {
    var hkey = hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (!param) {
        return false;
      }
      if (param._0 === hkey) {
        var match = equal$2(param._1, key);
        if (!match) {
          return true;
        }
        _param = param._2;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var iter = function (f, h) {
    var do_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return ;
        }
        var c = param._1;
        var match = get_key(c);
        var match$1 = get_data$1(c);
        if (match !== undefined && match$1 !== undefined) {
          Curry._2(f, Caml_option.valFromOption(match), Caml_option.valFromOption(match$1));
        }
        _param = param._2;
        continue ;
      };
    };
    var d = h.data;
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      do_bucket(Caml_array.get(d, i));
    }
  };
  var fold = function (f, h, init) {
    var do_bucket = function (_b, _accu) {
      while(true) {
        var accu = _accu;
        var b = _b;
        if (!b) {
          return accu;
        }
        var c = b._1;
        var match = get_key(c);
        var match$1 = get_data$1(c);
        var accu$1 = match !== undefined && match$1 !== undefined ? Curry._3(f, Caml_option.valFromOption(match), Caml_option.valFromOption(match$1), accu) : accu;
        _accu = accu$1;
        _b = b._2;
        continue ;
      };
    };
    var d = h.data;
    var accu = init;
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      accu = do_bucket(Caml_array.get(d, i), accu);
    }
    return accu;
  };
  var filter_map_inplace = function (f, h) {
    var do_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        var rest = param._2;
        var c = param._1;
        var match = get_key(c);
        var match$1 = get_data$1(c);
        if (match !== undefined) {
          if (match$1 !== undefined) {
            var k = Caml_option.valFromOption(match);
            var new_d = Curry._2(f, k, Caml_option.valFromOption(match$1));
            if (new_d !== undefined) {
              set_key_data(c, k, Caml_option.valFromOption(new_d));
              return /* Cons */{
                      _0: param._0,
                      _1: c,
                      _2: do_bucket(rest)
                    };
            }
            _param = rest;
            continue ;
          }
          _param = rest;
          continue ;
        }
        _param = rest;
        continue ;
      };
    };
    var d = h.data;
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  var length = function (h) {
    return h.size;
  };
  var bucket_length = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (!param) {
        return accu;
      }
      _param = param._2;
      _accu = accu + 1 | 0;
      continue ;
    };
  };
  var stats = function (h) {
    var mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length(0, b));
          }), 0, h.data);
    var histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            var l = bucket_length(0, b);
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: h.size,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  var bucket_length_alive = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (!param) {
        return accu;
      }
      if (check_key(param._1)) {
        _param = param._2;
        _accu = accu + 1 | 0;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var stats_alive = function (h) {
    var size = {
      contents: 0
    };
    var mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length_alive(0, b));
          }), 0, h.data);
    var histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            var l = bucket_length_alive(0, b);
            size.contents = size.contents + l | 0;
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: size.contents,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  var to_seq = function (tbl) {
    var tbl_data = tbl.data;
    var aux = function (_i, _buck, _param) {
      while(true) {
        var buck = _buck;
        var i = _i;
        if (buck) {
          var next = buck._2;
          var c = buck._1;
          var match = get_key(c);
          var match$1 = get_data$1(c);
          if (match !== undefined) {
            if (match$1 !== undefined) {
              return /* Cons */{
                      _0: [
                        Caml_option.valFromOption(match),
                        Caml_option.valFromOption(match$1)
                      ],
                      _1: (function(i,next){
                      return function (param) {
                        return aux(i, next, param);
                      }
                      }(i,next))
                    };
            }
            _param = undefined;
            _buck = next;
            continue ;
          }
          _param = undefined;
          _buck = next;
          continue ;
        }
        if (i === tbl_data.length) {
          return /* Nil */0;
        }
        _param = undefined;
        _buck = Caml_array.get(tbl_data, i);
        _i = i + 1 | 0;
        continue ;
      };
    };
    return function (param) {
      return aux(0, /* Empty */0, param);
    };
  };
  var to_seq_keys = function (m) {
    var partial_arg = to_seq(m);
    return function (param) {
      return Stdlib__Seq.map((function (prim) {
                    return prim[0];
                  }), partial_arg, param);
    };
  };
  var to_seq_values = function (m) {
    var partial_arg = to_seq(m);
    return function (param) {
      return Stdlib__Seq.map((function (prim) {
                    return prim[1];
                  }), partial_arg, param);
    };
  };
  var add_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            add(tbl, param[0], param[1]);
          }), i);
  };
  var replace_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            replace(tbl, param[0], param[1]);
          }), i);
  };
  var create$2 = function (sz) {
    return create$1(false, sz);
  };
  var of_seq = function (i) {
    var tbl = create$1(false, 16);
    replace_seq(tbl, i);
    return tbl;
  };
  return {
          create: create$2,
          clear: clear,
          reset: reset,
          copy: copy,
          add: add,
          remove: remove,
          find: find,
          find_opt: find_opt,
          find_all: find_all,
          replace: replace,
          mem: mem,
          iter: iter,
          filter_map_inplace: filter_map_inplace,
          fold: fold,
          length: length,
          stats: stats,
          to_seq: to_seq,
          to_seq_keys: to_seq_keys,
          to_seq_values: to_seq_values,
          add_seq: add_seq,
          replace_seq: replace_seq,
          of_seq: of_seq,
          clean: clean,
          stats_alive: stats_alive
        };
}

function make$3(param) {
  return {
          contents: /* [] */0
        };
}

function add$1(b, k1, k2, d) {
  b.contents = {
    hd: make$2(k1, k2, d),
    tl: b.contents
  };
}

function test_keys(k1, k2, e) {
  var match = Stdlib__Obj.Ephemeron.get_key(e, 0);
  var match$1 = Stdlib__Obj.Ephemeron.get_key(e, 1);
  if (match !== undefined && match$1 !== undefined && Caml_option.valFromOption(match) === k1) {
    return Caml_option.valFromOption(match$1) === k2;
  } else {
    return false;
  }
}

function remove$1(b, k1, k2) {
  var _l = b.contents;
  var _acc = /* [] */0;
  while(true) {
    var acc = _acc;
    var l = _l;
    if (!l) {
      return ;
    }
    var h = l.hd;
    if (test_keys(k1, k2, h)) {
      b.contents = Stdlib__List.rev_append(acc, l.tl);
      return ;
    }
    _acc = {
      hd: h,
      tl: acc
    };
    _l = l.tl;
    continue ;
  };
}

function find$1(b, k1, k2) {
  var e = Stdlib__List.find_opt((function (param) {
          return test_keys(k1, k2, param);
        }), b.contents);
  if (e !== undefined) {
    return Stdlib__Obj.Ephemeron.get_data(Caml_option.valFromOption(e));
  }
  
}

function length$1(b) {
  return Stdlib__List.length(b.contents);
}

function clear$1(b) {
  b.contents = /* [] */0;
}

function create$2(n) {
  return Stdlib__Obj.Ephemeron.create(n);
}

function get_key$1(t, n) {
  return Stdlib__Obj.Ephemeron.get_key(t, n);
}

function get_key_copy$1(t, n) {
  return Stdlib__Obj.Ephemeron.get_key_copy(t, n);
}

function set_key$1(t, n, k) {
  Stdlib__Obj.Ephemeron.set_key(t, n, k);
}

function unset_key$1(t, n) {
  Stdlib__Obj.Ephemeron.unset_key(t, n);
}

function check_key$1(t, n) {
  return Stdlib__Obj.Ephemeron.check_key(t, n);
}

function blit_key$1(t1, o1, t2, o2, l) {
  Stdlib__Obj.Ephemeron.blit_key(t1, o1, t2, o2, l);
}

function get_data$2(t) {
  return Stdlib__Obj.Ephemeron.get_data(t);
}

function get_data_copy$2(t) {
  return Stdlib__Obj.Ephemeron.get_data_copy(t);
}

function set_data$2(t, d) {
  Stdlib__Obj.Ephemeron.set_data(t, d);
}

function unset_data$2(t) {
  Stdlib__Obj.Ephemeron.unset_data(t);
}

function check_data$2(t) {
  return Stdlib__Obj.Ephemeron.check_data(t);
}

function blit_data$2(t1, t2) {
  Stdlib__Obj.Ephemeron.blit_data(t1, t2);
}

function make$4(keys, data) {
  var l = keys.length;
  var eph = Stdlib__Obj.Ephemeron.create(l);
  Stdlib__Obj.Ephemeron.set_data(eph, data);
  for(var i = 0; i < l; ++i){
    set_key$1(eph, i, Caml_array.get(keys, i));
  }
  return eph;
}

function query$2(eph, keys) {
  var l = Stdlib__Obj.Ephemeron.length(eph);
  try {
    if (l !== keys.length) {
      throw {
            RE_EXN_ID: Stdlib.Exit,
            Error: new Error()
          };
    }
    for(var i = 0; i < l; ++i){
      var k = Stdlib__Obj.Ephemeron.get_key(eph, i);
      if (k !== undefined) {
        if (Caml_option.valFromOption(k) !== Caml_array.get(keys, i)) {
          throw {
                RE_EXN_ID: Stdlib.Exit,
                Error: new Error()
              };
        }
        
      } else {
        throw {
              RE_EXN_ID: Stdlib.Exit,
              Error: new Error()
            };
      }
    }
    return Stdlib__Obj.Ephemeron.get_data(eph);
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Stdlib.Exit) {
      return ;
    }
    throw exn;
  }
}

function MakeSeeded$2(H) {
  var create = function (k, d) {
    var c = Stdlib__Obj.Ephemeron.create(k.length);
    Stdlib__Obj.Ephemeron.set_data(c, d);
    for(var i = 0 ,i_finish = k.length; i < i_finish; ++i){
      set_key$1(c, i, Caml_array.get(k, i));
    }
    return c;
  };
  var hash = function (seed, k) {
    var h = 0;
    for(var i = 0 ,i_finish = k.length; i < i_finish; ++i){
      h = Math.imul(Curry._2(H.hash, seed, Caml_array.get(k, i)), 65599) + h | 0;
    }
    return h;
  };
  var equal = function (c, k) {
    var len = k.length;
    var len$p = Stdlib__Obj.Ephemeron.length(c);
    if (len !== len$p) {
      return /* EFalse */1;
    }
    var _i = len - 1 | 0;
    while(true) {
      var i = _i;
      if (i < 0) {
        return /* ETrue */0;
      }
      var ki = Stdlib__Obj.Ephemeron.get_key(c, i);
      if (ki === undefined) {
        return /* EDead */2;
      }
      if (!Curry._2(H.equal, Caml_array.get(k, i), Caml_option.valFromOption(ki))) {
        return /* EFalse */1;
      }
      _i = i - 1 | 0;
      continue ;
    };
  };
  var get_key = function (c) {
    var len = Stdlib__Obj.Ephemeron.length(c);
    if (len === 0) {
      return [];
    }
    var k0 = Stdlib__Obj.Ephemeron.get_key(c, 0);
    if (k0 === undefined) {
      return ;
    }
    var a = Caml_array.make(len, Caml_option.valFromOption(k0));
    var _i = len - 1 | 0;
    while(true) {
      var i = _i;
      if (i < 1) {
        return a;
      }
      var ki = Stdlib__Obj.Ephemeron.get_key(c, i);
      if (ki === undefined) {
        return ;
      }
      Caml_array.set(a, i, Caml_option.valFromOption(ki));
      _i = i - 1 | 0;
      continue ;
    };
  };
  var set_key_data = function (c, k, d) {
    Stdlib__Obj.Ephemeron.unset_data(c);
    for(var i = 0 ,i_finish = k.length; i < i_finish; ++i){
      set_key$1(c, i, Caml_array.get(k, i));
    }
    Stdlib__Obj.Ephemeron.set_data(c, d);
  };
  var check_key = function (c) {
    var _i = Stdlib__Obj.Ephemeron.length(c) - 1 | 0;
    while(true) {
      var i = _i;
      if (i < 0) {
        return true;
      }
      if (!Stdlib__Obj.Ephemeron.check_key(c, i)) {
        return false;
      }
      _i = i - 1 | 0;
      continue ;
    };
  };
  var power_2_above = function (_x, n) {
    while(true) {
      var x = _x;
      if (x >= n) {
        return x;
      }
      if ((x << 1) > Stdlib__Sys.max_array_length) {
        return x;
      }
      _x = (x << 1);
      continue ;
    };
  };
  var prng = {
    LAZY_DONE: false,
    VAL: (function () {
        return Stdlib__Random.State.make_self_init(undefined);
      })
  };
  var create$1 = function (randomOpt, initial_size) {
    var random = randomOpt !== undefined ? randomOpt : Stdlib__Hashtbl.is_randomized(undefined);
    var s = power_2_above(16, initial_size);
    var seed = random ? Stdlib__Random.State.bits(CamlinternalLazy.force(prng)) : 0;
    return {
            size: 0,
            data: Caml_array.make(s, /* Empty */0),
            seed: seed,
            initial_size: s
          };
  };
  var clear = function (h) {
    h.size = 0;
    var len = h.data.length;
    for(var i = 0; i < len; ++i){
      Caml_array.set(h.data, i, /* Empty */0);
    }
  };
  var reset = function (h) {
    var len = h.data.length;
    if (len === h.initial_size) {
      return clear(h);
    } else {
      h.size = 0;
      h.data = Caml_array.make(h.initial_size, /* Empty */0);
      return ;
    }
  };
  var copy = function (h) {
    return {
            size: h.size,
            data: Stdlib__Array.copy(h.data),
            seed: h.seed,
            initial_size: h.initial_size
          };
  };
  var key_index = function (h, hkey) {
    return hkey & (h.data.length - 1 | 0);
  };
  var clean = function (h) {
    var do_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        if (check_key(param._1)) {
          return /* Cons */{
                  _0: param._0,
                  _1: param._1,
                  _2: do_bucket(param._2)
                };
        }
        h.size = h.size - 1 | 0;
        _param = param._2;
        continue ;
      };
    };
    var d = h.data;
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  var resize = function (h) {
    var odata = h.data;
    var osize = odata.length;
    var nsize = (osize << 1);
    clean(h);
    if (!(nsize < Stdlib__Sys.max_array_length && h.size >= (osize >>> 1))) {
      return ;
    }
    var ndata = Caml_array.make(nsize, /* Empty */0);
    h.data = ndata;
    var insert_bucket = function (param) {
      if (!param) {
        return ;
      }
      var hkey = param._0;
      insert_bucket(param._2);
      var nidx = key_index(h, hkey);
      Caml_array.set(ndata, nidx, /* Cons */{
            _0: hkey,
            _1: param._1,
            _2: Caml_array.get(ndata, nidx)
          });
    };
    for(var i = 0; i < osize; ++i){
      insert_bucket(Caml_array.get(odata, i));
    }
  };
  var add = function (h, key, info) {
    var hkey = hash(h.seed, key);
    var i = key_index(h, hkey);
    var container = create(key, info);
    var bucket_2 = Caml_array.get(h.data, i);
    var bucket = /* Cons */{
      _0: hkey,
      _1: container,
      _2: bucket_2
    };
    Caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(h);
    }
    
  };
  var remove = function (h, key) {
    var hkey = hash(h.seed, key);
    var remove_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        var hk = param._0;
        if (hkey !== hk) {
          return /* Cons */{
                  _0: hk,
                  _1: param._1,
                  _2: remove_bucket(param._2)
                };
        }
        var next = param._2;
        var c = param._1;
        var match = equal(c, key);
        switch (match) {
          case /* ETrue */0 :
              h.size = h.size - 1 | 0;
              return next;
          case /* EFalse */1 :
              return /* Cons */{
                      _0: hk,
                      _1: c,
                      _2: remove_bucket(next)
                    };
          case /* EDead */2 :
              h.size = h.size - 1 | 0;
              _param = next;
              continue ;
          
        }
      };
    };
    var i = key_index(h, hkey);
    Caml_array.set(h.data, i, remove_bucket(Caml_array.get(h.data, i)));
  };
  var find = function (h, key) {
    var hkey = hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (param) {
        if (hkey === param._0) {
          var rest = param._2;
          var c = param._1;
          var match = equal(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          var d = get_data$2(c);
          if (d !== undefined) {
            return Caml_option.valFromOption(d);
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      }
      throw {
            RE_EXN_ID: Stdlib.Not_found,
            Error: new Error()
          };
    };
  };
  var find_opt = function (h, key) {
    var hkey = hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (!param) {
        return ;
      }
      if (hkey === param._0) {
        var rest = param._2;
        var c = param._1;
        var match = equal(c, key);
        if (match) {
          _param = rest;
          continue ;
        }
        var d = get_data$2(c);
        if (d !== undefined) {
          return d;
        }
        _param = rest;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var find_all = function (h, key) {
    var hkey = hash(h.seed, key);
    var find_in_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* [] */0;
        }
        if (hkey === param._0) {
          var rest = param._2;
          var c = param._1;
          var match = equal(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          var d = get_data$2(c);
          if (d !== undefined) {
            return {
                    hd: Caml_option.valFromOption(d),
                    tl: find_in_bucket(rest)
                  };
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      };
    };
    return find_in_bucket(Caml_array.get(h.data, key_index(h, hkey)));
  };
  var replace = function (h, key, info) {
    var hkey = hash(h.seed, key);
    var i = key_index(h, hkey);
    var l = Caml_array.get(h.data, i);
    try {
      var _param = l;
      while(true) {
        var param = _param;
        if (param) {
          if (hkey === param._0) {
            var c = param._1;
            var match = equal(c, key);
            if (!match) {
              return set_key_data(c, key, info);
            }
            _param = param._2;
            continue ;
          }
          _param = param._2;
          continue ;
        }
        throw {
              RE_EXN_ID: Stdlib.Not_found,
              Error: new Error()
            };
      };
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === Stdlib.Not_found) {
        var container = create(key, info);
        Caml_array.set(h.data, i, /* Cons */{
              _0: hkey,
              _1: container,
              _2: l
            });
        h.size = h.size + 1 | 0;
        if (h.size > (h.data.length << 1)) {
          return resize(h);
        } else {
          return ;
        }
      }
      throw exn;
    }
  };
  var mem = function (h, key) {
    var hkey = hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (!param) {
        return false;
      }
      if (param._0 === hkey) {
        var match = equal(param._1, key);
        if (!match) {
          return true;
        }
        _param = param._2;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var iter = function (f, h) {
    var do_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return ;
        }
        var c = param._1;
        var match = get_key(c);
        var match$1 = get_data$2(c);
        if (match !== undefined && match$1 !== undefined) {
          Curry._2(f, Caml_option.valFromOption(match), Caml_option.valFromOption(match$1));
        }
        _param = param._2;
        continue ;
      };
    };
    var d = h.data;
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      do_bucket(Caml_array.get(d, i));
    }
  };
  var fold = function (f, h, init) {
    var do_bucket = function (_b, _accu) {
      while(true) {
        var accu = _accu;
        var b = _b;
        if (!b) {
          return accu;
        }
        var c = b._1;
        var match = get_key(c);
        var match$1 = get_data$2(c);
        var accu$1 = match !== undefined && match$1 !== undefined ? Curry._3(f, Caml_option.valFromOption(match), Caml_option.valFromOption(match$1), accu) : accu;
        _accu = accu$1;
        _b = b._2;
        continue ;
      };
    };
    var d = h.data;
    var accu = init;
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      accu = do_bucket(Caml_array.get(d, i), accu);
    }
    return accu;
  };
  var filter_map_inplace = function (f, h) {
    var do_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        var rest = param._2;
        var c = param._1;
        var match = get_key(c);
        var match$1 = get_data$2(c);
        if (match !== undefined) {
          if (match$1 !== undefined) {
            var k = Caml_option.valFromOption(match);
            var new_d = Curry._2(f, k, Caml_option.valFromOption(match$1));
            if (new_d !== undefined) {
              set_key_data(c, k, Caml_option.valFromOption(new_d));
              return /* Cons */{
                      _0: param._0,
                      _1: c,
                      _2: do_bucket(rest)
                    };
            }
            _param = rest;
            continue ;
          }
          _param = rest;
          continue ;
        }
        _param = rest;
        continue ;
      };
    };
    var d = h.data;
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  var length = function (h) {
    return h.size;
  };
  var bucket_length = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (!param) {
        return accu;
      }
      _param = param._2;
      _accu = accu + 1 | 0;
      continue ;
    };
  };
  var stats = function (h) {
    var mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length(0, b));
          }), 0, h.data);
    var histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            var l = bucket_length(0, b);
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: h.size,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  var bucket_length_alive = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (!param) {
        return accu;
      }
      if (check_key(param._1)) {
        _param = param._2;
        _accu = accu + 1 | 0;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var stats_alive = function (h) {
    var size = {
      contents: 0
    };
    var mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length_alive(0, b));
          }), 0, h.data);
    var histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            var l = bucket_length_alive(0, b);
            size.contents = size.contents + l | 0;
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: size.contents,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  var to_seq = function (tbl) {
    var tbl_data = tbl.data;
    var aux = function (_i, _buck, _param) {
      while(true) {
        var buck = _buck;
        var i = _i;
        if (buck) {
          var next = buck._2;
          var c = buck._1;
          var match = get_key(c);
          var match$1 = get_data$2(c);
          if (match !== undefined) {
            if (match$1 !== undefined) {
              return /* Cons */{
                      _0: [
                        Caml_option.valFromOption(match),
                        Caml_option.valFromOption(match$1)
                      ],
                      _1: (function(i,next){
                      return function (param) {
                        return aux(i, next, param);
                      }
                      }(i,next))
                    };
            }
            _param = undefined;
            _buck = next;
            continue ;
          }
          _param = undefined;
          _buck = next;
          continue ;
        }
        if (i === tbl_data.length) {
          return /* Nil */0;
        }
        _param = undefined;
        _buck = Caml_array.get(tbl_data, i);
        _i = i + 1 | 0;
        continue ;
      };
    };
    return function (param) {
      return aux(0, /* Empty */0, param);
    };
  };
  var to_seq_keys = function (m) {
    var partial_arg = to_seq(m);
    return function (param) {
      return Stdlib__Seq.map((function (prim) {
                    return prim[0];
                  }), partial_arg, param);
    };
  };
  var to_seq_values = function (m) {
    var partial_arg = to_seq(m);
    return function (param) {
      return Stdlib__Seq.map((function (prim) {
                    return prim[1];
                  }), partial_arg, param);
    };
  };
  var add_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            add(tbl, param[0], param[1]);
          }), i);
  };
  var replace_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            replace(tbl, param[0], param[1]);
          }), i);
  };
  var of_seq = function (i) {
    var tbl = create$1(undefined, 16);
    replace_seq(tbl, i);
    return tbl;
  };
  return {
          create: create$1,
          clear: clear,
          reset: reset,
          copy: copy,
          add: add,
          remove: remove,
          find: find,
          find_opt: find_opt,
          find_all: find_all,
          replace: replace,
          mem: mem,
          iter: iter,
          filter_map_inplace: filter_map_inplace,
          fold: fold,
          length: length,
          stats: stats,
          to_seq: to_seq,
          to_seq_keys: to_seq_keys,
          to_seq_values: to_seq_values,
          add_seq: add_seq,
          replace_seq: replace_seq,
          of_seq: of_seq,
          clean: clean,
          stats_alive: stats_alive
        };
}

function Make$2(H) {
  var equal = H.equal;
  var create = function (k, d) {
    var c = Stdlib__Obj.Ephemeron.create(k.length);
    Stdlib__Obj.Ephemeron.set_data(c, d);
    for(var i = 0 ,i_finish = k.length; i < i_finish; ++i){
      set_key$1(c, i, Caml_array.get(k, i));
    }
    return c;
  };
  var hash = function (seed, k) {
    var h = 0;
    for(var i = 0 ,i_finish = k.length; i < i_finish; ++i){
      h = Math.imul(Curry._1(H.hash, Caml_array.get(k, i)), 65599) + h | 0;
    }
    return h;
  };
  var equal$1 = function (c, k) {
    var len = k.length;
    var len$p = Stdlib__Obj.Ephemeron.length(c);
    if (len !== len$p) {
      return /* EFalse */1;
    }
    var _i = len - 1 | 0;
    while(true) {
      var i = _i;
      if (i < 0) {
        return /* ETrue */0;
      }
      var ki = Stdlib__Obj.Ephemeron.get_key(c, i);
      if (ki === undefined) {
        return /* EDead */2;
      }
      if (!Curry._2(equal, Caml_array.get(k, i), Caml_option.valFromOption(ki))) {
        return /* EFalse */1;
      }
      _i = i - 1 | 0;
      continue ;
    };
  };
  var get_key = function (c) {
    var len = Stdlib__Obj.Ephemeron.length(c);
    if (len === 0) {
      return [];
    }
    var k0 = Stdlib__Obj.Ephemeron.get_key(c, 0);
    if (k0 === undefined) {
      return ;
    }
    var a = Caml_array.make(len, Caml_option.valFromOption(k0));
    var _i = len - 1 | 0;
    while(true) {
      var i = _i;
      if (i < 1) {
        return a;
      }
      var ki = Stdlib__Obj.Ephemeron.get_key(c, i);
      if (ki === undefined) {
        return ;
      }
      Caml_array.set(a, i, Caml_option.valFromOption(ki));
      _i = i - 1 | 0;
      continue ;
    };
  };
  var set_key_data = function (c, k, d) {
    Stdlib__Obj.Ephemeron.unset_data(c);
    for(var i = 0 ,i_finish = k.length; i < i_finish; ++i){
      set_key$1(c, i, Caml_array.get(k, i));
    }
    Stdlib__Obj.Ephemeron.set_data(c, d);
  };
  var check_key = function (c) {
    var _i = Stdlib__Obj.Ephemeron.length(c) - 1 | 0;
    while(true) {
      var i = _i;
      if (i < 0) {
        return true;
      }
      if (!Stdlib__Obj.Ephemeron.check_key(c, i)) {
        return false;
      }
      _i = i - 1 | 0;
      continue ;
    };
  };
  var power_2_above = function (_x, n) {
    while(true) {
      var x = _x;
      if (x >= n) {
        return x;
      }
      if ((x << 1) > Stdlib__Sys.max_array_length) {
        return x;
      }
      _x = (x << 1);
      continue ;
    };
  };
  var prng = {
    LAZY_DONE: false,
    VAL: (function () {
        return Stdlib__Random.State.make_self_init(undefined);
      })
  };
  var create$1 = function (randomOpt, initial_size) {
    var random = randomOpt !== undefined ? randomOpt : Stdlib__Hashtbl.is_randomized(undefined);
    var s = power_2_above(16, initial_size);
    var seed = random ? Stdlib__Random.State.bits(CamlinternalLazy.force(prng)) : 0;
    return {
            size: 0,
            data: Caml_array.make(s, /* Empty */0),
            seed: seed,
            initial_size: s
          };
  };
  var clear = function (h) {
    h.size = 0;
    var len = h.data.length;
    for(var i = 0; i < len; ++i){
      Caml_array.set(h.data, i, /* Empty */0);
    }
  };
  var reset = function (h) {
    var len = h.data.length;
    if (len === h.initial_size) {
      return clear(h);
    } else {
      h.size = 0;
      h.data = Caml_array.make(h.initial_size, /* Empty */0);
      return ;
    }
  };
  var copy = function (h) {
    return {
            size: h.size,
            data: Stdlib__Array.copy(h.data),
            seed: h.seed,
            initial_size: h.initial_size
          };
  };
  var key_index = function (h, hkey) {
    return hkey & (h.data.length - 1 | 0);
  };
  var clean = function (h) {
    var do_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        if (check_key(param._1)) {
          return /* Cons */{
                  _0: param._0,
                  _1: param._1,
                  _2: do_bucket(param._2)
                };
        }
        h.size = h.size - 1 | 0;
        _param = param._2;
        continue ;
      };
    };
    var d = h.data;
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  var resize = function (h) {
    var odata = h.data;
    var osize = odata.length;
    var nsize = (osize << 1);
    clean(h);
    if (!(nsize < Stdlib__Sys.max_array_length && h.size >= (osize >>> 1))) {
      return ;
    }
    var ndata = Caml_array.make(nsize, /* Empty */0);
    h.data = ndata;
    var insert_bucket = function (param) {
      if (!param) {
        return ;
      }
      var hkey = param._0;
      insert_bucket(param._2);
      var nidx = key_index(h, hkey);
      Caml_array.set(ndata, nidx, /* Cons */{
            _0: hkey,
            _1: param._1,
            _2: Caml_array.get(ndata, nidx)
          });
    };
    for(var i = 0; i < osize; ++i){
      insert_bucket(Caml_array.get(odata, i));
    }
  };
  var add = function (h, key, info) {
    var hkey = hash(h.seed, key);
    var i = key_index(h, hkey);
    var container = create(key, info);
    var bucket_2 = Caml_array.get(h.data, i);
    var bucket = /* Cons */{
      _0: hkey,
      _1: container,
      _2: bucket_2
    };
    Caml_array.set(h.data, i, bucket);
    h.size = h.size + 1 | 0;
    if (h.size > (h.data.length << 1)) {
      return resize(h);
    }
    
  };
  var remove = function (h, key) {
    var hkey = hash(h.seed, key);
    var remove_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        var hk = param._0;
        if (hkey !== hk) {
          return /* Cons */{
                  _0: hk,
                  _1: param._1,
                  _2: remove_bucket(param._2)
                };
        }
        var next = param._2;
        var c = param._1;
        var match = equal$1(c, key);
        switch (match) {
          case /* ETrue */0 :
              h.size = h.size - 1 | 0;
              return next;
          case /* EFalse */1 :
              return /* Cons */{
                      _0: hk,
                      _1: c,
                      _2: remove_bucket(next)
                    };
          case /* EDead */2 :
              h.size = h.size - 1 | 0;
              _param = next;
              continue ;
          
        }
      };
    };
    var i = key_index(h, hkey);
    Caml_array.set(h.data, i, remove_bucket(Caml_array.get(h.data, i)));
  };
  var find = function (h, key) {
    var hkey = hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (param) {
        if (hkey === param._0) {
          var rest = param._2;
          var c = param._1;
          var match = equal$1(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          var d = get_data$2(c);
          if (d !== undefined) {
            return Caml_option.valFromOption(d);
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      }
      throw {
            RE_EXN_ID: Stdlib.Not_found,
            Error: new Error()
          };
    };
  };
  var find_opt = function (h, key) {
    var hkey = hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (!param) {
        return ;
      }
      if (hkey === param._0) {
        var rest = param._2;
        var c = param._1;
        var match = equal$1(c, key);
        if (match) {
          _param = rest;
          continue ;
        }
        var d = get_data$2(c);
        if (d !== undefined) {
          return d;
        }
        _param = rest;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var find_all = function (h, key) {
    var hkey = hash(h.seed, key);
    var find_in_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* [] */0;
        }
        if (hkey === param._0) {
          var rest = param._2;
          var c = param._1;
          var match = equal$1(c, key);
          if (match) {
            _param = rest;
            continue ;
          }
          var d = get_data$2(c);
          if (d !== undefined) {
            return {
                    hd: Caml_option.valFromOption(d),
                    tl: find_in_bucket(rest)
                  };
          }
          _param = rest;
          continue ;
        }
        _param = param._2;
        continue ;
      };
    };
    return find_in_bucket(Caml_array.get(h.data, key_index(h, hkey)));
  };
  var replace = function (h, key, info) {
    var hkey = hash(h.seed, key);
    var i = key_index(h, hkey);
    var l = Caml_array.get(h.data, i);
    try {
      var _param = l;
      while(true) {
        var param = _param;
        if (param) {
          if (hkey === param._0) {
            var c = param._1;
            var match = equal$1(c, key);
            if (!match) {
              return set_key_data(c, key, info);
            }
            _param = param._2;
            continue ;
          }
          _param = param._2;
          continue ;
        }
        throw {
              RE_EXN_ID: Stdlib.Not_found,
              Error: new Error()
            };
      };
    }
    catch (raw_exn){
      var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
      if (exn.RE_EXN_ID === Stdlib.Not_found) {
        var container = create(key, info);
        Caml_array.set(h.data, i, /* Cons */{
              _0: hkey,
              _1: container,
              _2: l
            });
        h.size = h.size + 1 | 0;
        if (h.size > (h.data.length << 1)) {
          return resize(h);
        } else {
          return ;
        }
      }
      throw exn;
    }
  };
  var mem = function (h, key) {
    var hkey = hash(h.seed, key);
    var _param = Caml_array.get(h.data, key_index(h, hkey));
    while(true) {
      var param = _param;
      if (!param) {
        return false;
      }
      if (param._0 === hkey) {
        var match = equal$1(param._1, key);
        if (!match) {
          return true;
        }
        _param = param._2;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var iter = function (f, h) {
    var do_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return ;
        }
        var c = param._1;
        var match = get_key(c);
        var match$1 = get_data$2(c);
        if (match !== undefined && match$1 !== undefined) {
          Curry._2(f, Caml_option.valFromOption(match), Caml_option.valFromOption(match$1));
        }
        _param = param._2;
        continue ;
      };
    };
    var d = h.data;
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      do_bucket(Caml_array.get(d, i));
    }
  };
  var fold = function (f, h, init) {
    var do_bucket = function (_b, _accu) {
      while(true) {
        var accu = _accu;
        var b = _b;
        if (!b) {
          return accu;
        }
        var c = b._1;
        var match = get_key(c);
        var match$1 = get_data$2(c);
        var accu$1 = match !== undefined && match$1 !== undefined ? Curry._3(f, Caml_option.valFromOption(match), Caml_option.valFromOption(match$1), accu) : accu;
        _accu = accu$1;
        _b = b._2;
        continue ;
      };
    };
    var d = h.data;
    var accu = init;
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      accu = do_bucket(Caml_array.get(d, i), accu);
    }
    return accu;
  };
  var filter_map_inplace = function (f, h) {
    var do_bucket = function (_param) {
      while(true) {
        var param = _param;
        if (!param) {
          return /* Empty */0;
        }
        var rest = param._2;
        var c = param._1;
        var match = get_key(c);
        var match$1 = get_data$2(c);
        if (match !== undefined) {
          if (match$1 !== undefined) {
            var k = Caml_option.valFromOption(match);
            var new_d = Curry._2(f, k, Caml_option.valFromOption(match$1));
            if (new_d !== undefined) {
              set_key_data(c, k, Caml_option.valFromOption(new_d));
              return /* Cons */{
                      _0: param._0,
                      _1: c,
                      _2: do_bucket(rest)
                    };
            }
            _param = rest;
            continue ;
          }
          _param = rest;
          continue ;
        }
        _param = rest;
        continue ;
      };
    };
    var d = h.data;
    for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
      Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
    }
  };
  var length = function (h) {
    return h.size;
  };
  var bucket_length = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (!param) {
        return accu;
      }
      _param = param._2;
      _accu = accu + 1 | 0;
      continue ;
    };
  };
  var stats = function (h) {
    var mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length(0, b));
          }), 0, h.data);
    var histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            var l = bucket_length(0, b);
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: h.size,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  var bucket_length_alive = function (_accu, _param) {
    while(true) {
      var param = _param;
      var accu = _accu;
      if (!param) {
        return accu;
      }
      if (check_key(param._1)) {
        _param = param._2;
        _accu = accu + 1 | 0;
        continue ;
      }
      _param = param._2;
      continue ;
    };
  };
  var stats_alive = function (h) {
    var size = {
      contents: 0
    };
    var mbl = Stdlib__Array.fold_left((function (m, b) {
            return Stdlib__Int.max(m, bucket_length_alive(0, b));
          }), 0, h.data);
    var histo = Caml_array.make(mbl + 1 | 0, 0);
    Stdlib__Array.iter((function (b) {
            var l = bucket_length_alive(0, b);
            size.contents = size.contents + l | 0;
            Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
          }), h.data);
    return {
            num_bindings: size.contents,
            num_buckets: h.data.length,
            max_bucket_length: mbl,
            bucket_histogram: histo
          };
  };
  var to_seq = function (tbl) {
    var tbl_data = tbl.data;
    var aux = function (_i, _buck, _param) {
      while(true) {
        var buck = _buck;
        var i = _i;
        if (buck) {
          var next = buck._2;
          var c = buck._1;
          var match = get_key(c);
          var match$1 = get_data$2(c);
          if (match !== undefined) {
            if (match$1 !== undefined) {
              return /* Cons */{
                      _0: [
                        Caml_option.valFromOption(match),
                        Caml_option.valFromOption(match$1)
                      ],
                      _1: (function(i,next){
                      return function (param) {
                        return aux(i, next, param);
                      }
                      }(i,next))
                    };
            }
            _param = undefined;
            _buck = next;
            continue ;
          }
          _param = undefined;
          _buck = next;
          continue ;
        }
        if (i === tbl_data.length) {
          return /* Nil */0;
        }
        _param = undefined;
        _buck = Caml_array.get(tbl_data, i);
        _i = i + 1 | 0;
        continue ;
      };
    };
    return function (param) {
      return aux(0, /* Empty */0, param);
    };
  };
  var to_seq_keys = function (m) {
    var partial_arg = to_seq(m);
    return function (param) {
      return Stdlib__Seq.map((function (prim) {
                    return prim[0];
                  }), partial_arg, param);
    };
  };
  var to_seq_values = function (m) {
    var partial_arg = to_seq(m);
    return function (param) {
      return Stdlib__Seq.map((function (prim) {
                    return prim[1];
                  }), partial_arg, param);
    };
  };
  var add_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            add(tbl, param[0], param[1]);
          }), i);
  };
  var replace_seq = function (tbl, i) {
    Stdlib__Seq.iter((function (param) {
            replace(tbl, param[0], param[1]);
          }), i);
  };
  var create$2 = function (sz) {
    return create$1(false, sz);
  };
  var of_seq = function (i) {
    var tbl = create$1(false, 16);
    replace_seq(tbl, i);
    return tbl;
  };
  return {
          create: create$2,
          clear: clear,
          reset: reset,
          copy: copy,
          add: add,
          remove: remove,
          find: find,
          find_opt: find_opt,
          find_all: find_all,
          replace: replace,
          mem: mem,
          iter: iter,
          filter_map_inplace: filter_map_inplace,
          fold: fold,
          length: length,
          stats: stats,
          to_seq: to_seq,
          to_seq_keys: to_seq_keys,
          to_seq_values: to_seq_values,
          add_seq: add_seq,
          replace_seq: replace_seq,
          of_seq: of_seq,
          clean: clean,
          stats_alive: stats_alive
        };
}

function make$5(param) {
  return {
          contents: /* [] */0
        };
}

function add$2(b, k, d) {
  b.contents = {
    hd: make$4(k, d),
    tl: b.contents
  };
}

function test_keys$1(k, e) {
  try {
    if (Stdlib__Obj.Ephemeron.length(e) !== k.length) {
      throw {
            RE_EXN_ID: Stdlib.Exit,
            Error: new Error()
          };
    }
    for(var i = 0 ,i_finish = k.length; i < i_finish; ++i){
      var x = Stdlib__Obj.Ephemeron.get_key(e, i);
      if (x !== undefined) {
        if (Caml_option.valFromOption(x) !== Caml_array.get(k, i)) {
          throw {
                RE_EXN_ID: Stdlib.Exit,
                Error: new Error()
              };
        }
        
      } else {
        throw {
              RE_EXN_ID: Stdlib.Exit,
              Error: new Error()
            };
      }
    }
    return true;
  }
  catch (raw_exn){
    var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
    if (exn.RE_EXN_ID === Stdlib.Exit) {
      return false;
    }
    throw exn;
  }
}

function remove$2(b, k) {
  var _l = b.contents;
  var _acc = /* [] */0;
  while(true) {
    var acc = _acc;
    var l = _l;
    if (!l) {
      return ;
    }
    var h = l.hd;
    if (test_keys$1(k, h)) {
      b.contents = Stdlib__List.rev_append(acc, l.tl);
      return ;
    }
    _acc = {
      hd: h,
      tl: acc
    };
    _l = l.tl;
    continue ;
  };
}

function find$2(b, k) {
  var e = Stdlib__List.find_opt((function (param) {
          return test_keys$1(k, param);
        }), b.contents);
  if (e !== undefined) {
    return Stdlib__Obj.Ephemeron.get_data(Caml_option.valFromOption(e));
  }
  
}

function length$2(b) {
  return Stdlib__List.length(b.contents);
}

function clear$2(b) {
  b.contents = /* [] */0;
}

var K1_Bucket = {
  make: make$1,
  add: add,
  remove: remove,
  find: find,
  length: length,
  clear: clear
};

var K1 = {
  create: create,
  get_key: get_key,
  get_key_copy: get_key_copy,
  set_key: set_key,
  unset_key: unset_key,
  check_key: check_key,
  blit_key: blit_key,
  get_data: get_data,
  get_data_copy: get_data_copy,
  set_data: set_data,
  unset_data: unset_data,
  check_data: check_data,
  blit_data: blit_data,
  make: make,
  query: query,
  Make: Make,
  MakeSeeded: MakeSeeded,
  Bucket: K1_Bucket
};

var K2_Bucket = {
  make: make$3,
  add: add$1,
  remove: remove$1,
  find: find$1,
  length: length$1,
  clear: clear$1
};

var K2 = {
  create: create$1,
  get_key1: get_key1,
  get_key1_copy: get_key1_copy,
  set_key1: set_key1,
  unset_key1: unset_key1,
  check_key1: check_key1,
  get_key2: get_key2,
  get_key2_copy: get_key2_copy,
  set_key2: set_key2,
  unset_key2: unset_key2,
  check_key2: check_key2,
  blit_key1: blit_key1,
  blit_key2: blit_key2,
  blit_key12: blit_key12,
  get_data: get_data$1,
  get_data_copy: get_data_copy$1,
  set_data: set_data$1,
  unset_data: unset_data$1,
  check_data: check_data$1,
  blit_data: blit_data$1,
  make: make$2,
  query: query$1,
  Make: Make$1,
  MakeSeeded: MakeSeeded$1,
  Bucket: K2_Bucket
};

var Kn_Bucket = {
  make: make$5,
  add: add$2,
  remove: remove$2,
  find: find$2,
  length: length$2,
  clear: clear$2
};

var Kn = {
  create: create$2,
  get_key: get_key$1,
  get_key_copy: get_key_copy$1,
  set_key: set_key$1,
  unset_key: unset_key$1,
  check_key: check_key$1,
  blit_key: blit_key$1,
  get_data: get_data$2,
  get_data_copy: get_data_copy$2,
  set_data: set_data$2,
  unset_data: unset_data$2,
  check_data: check_data$2,
  blit_data: blit_data$2,
  make: make$4,
  query: query$2,
  Make: Make$2,
  MakeSeeded: MakeSeeded$2,
  Bucket: Kn_Bucket
};

var GenHashTable = {
  MakeSeeded: (function (funarg) {
      var power_2_above = function (_x, n) {
        while(true) {
          var x = _x;
          if (x >= n) {
            return x;
          }
          if ((x << 1) > Stdlib__Sys.max_array_length) {
            return x;
          }
          _x = (x << 1);
          continue ;
        };
      };
      var prng = {
        LAZY_DONE: false,
        VAL: (function () {
            return Stdlib__Random.State.make_self_init(undefined);
          })
      };
      var create = function (randomOpt, initial_size) {
        var random = randomOpt !== undefined ? randomOpt : Stdlib__Hashtbl.is_randomized(undefined);
        var s = power_2_above(16, initial_size);
        var seed = random ? Stdlib__Random.State.bits(CamlinternalLazy.force(prng)) : 0;
        return {
                size: 0,
                data: Caml_array.make(s, /* Empty */0),
                seed: seed,
                initial_size: s
              };
      };
      var clear = function (h) {
        h.size = 0;
        var len = h.data.length;
        for(var i = 0; i < len; ++i){
          Caml_array.set(h.data, i, /* Empty */0);
        }
      };
      var reset = function (h) {
        var len = h.data.length;
        if (len === h.initial_size) {
          return clear(h);
        } else {
          h.size = 0;
          h.data = Caml_array.make(h.initial_size, /* Empty */0);
          return ;
        }
      };
      var copy = function (h) {
        return {
                size: h.size,
                data: Stdlib__Array.copy(h.data),
                seed: h.seed,
                initial_size: h.initial_size
              };
      };
      var key_index = function (h, hkey) {
        return hkey & (h.data.length - 1 | 0);
      };
      var clean = function (h) {
        var do_bucket = function (_param) {
          while(true) {
            var param = _param;
            if (!param) {
              return /* Empty */0;
            }
            if (Curry._1(funarg.check_key, param._1)) {
              return /* Cons */{
                      _0: param._0,
                      _1: param._1,
                      _2: do_bucket(param._2)
                    };
            }
            h.size = h.size - 1 | 0;
            _param = param._2;
            continue ;
          };
        };
        var d = h.data;
        for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
          Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
        }
      };
      var resize = function (h) {
        var odata = h.data;
        var osize = odata.length;
        var nsize = (osize << 1);
        clean(h);
        if (!(nsize < Stdlib__Sys.max_array_length && h.size >= (osize >>> 1))) {
          return ;
        }
        var ndata = Caml_array.make(nsize, /* Empty */0);
        h.data = ndata;
        var insert_bucket = function (param) {
          if (!param) {
            return ;
          }
          var hkey = param._0;
          insert_bucket(param._2);
          var nidx = key_index(h, hkey);
          Caml_array.set(ndata, nidx, /* Cons */{
                _0: hkey,
                _1: param._1,
                _2: Caml_array.get(ndata, nidx)
              });
        };
        for(var i = 0; i < osize; ++i){
          insert_bucket(Caml_array.get(odata, i));
        }
      };
      var add = function (h, key, info) {
        var hkey = Curry._2(funarg.hash, h.seed, key);
        var i = key_index(h, hkey);
        var container = Curry._2(funarg.create, key, info);
        var bucket_2 = Caml_array.get(h.data, i);
        var bucket = /* Cons */{
          _0: hkey,
          _1: container,
          _2: bucket_2
        };
        Caml_array.set(h.data, i, bucket);
        h.size = h.size + 1 | 0;
        if (h.size > (h.data.length << 1)) {
          return resize(h);
        }
        
      };
      var remove = function (h, key) {
        var hkey = Curry._2(funarg.hash, h.seed, key);
        var remove_bucket = function (_param) {
          while(true) {
            var param = _param;
            if (!param) {
              return /* Empty */0;
            }
            var hk = param._0;
            if (hkey !== hk) {
              return /* Cons */{
                      _0: hk,
                      _1: param._1,
                      _2: remove_bucket(param._2)
                    };
            }
            var next = param._2;
            var c = param._1;
            var match = Curry._2(funarg.equal, c, key);
            switch (match) {
              case /* ETrue */0 :
                  h.size = h.size - 1 | 0;
                  return next;
              case /* EFalse */1 :
                  return /* Cons */{
                          _0: hk,
                          _1: c,
                          _2: remove_bucket(next)
                        };
              case /* EDead */2 :
                  h.size = h.size - 1 | 0;
                  _param = next;
                  continue ;
              
            }
          };
        };
        var i = key_index(h, hkey);
        Caml_array.set(h.data, i, remove_bucket(Caml_array.get(h.data, i)));
      };
      var find = function (h, key) {
        var hkey = Curry._2(funarg.hash, h.seed, key);
        var _param = Caml_array.get(h.data, key_index(h, hkey));
        while(true) {
          var param = _param;
          if (param) {
            if (hkey === param._0) {
              var rest = param._2;
              var c = param._1;
              var match = Curry._2(funarg.equal, c, key);
              if (match) {
                _param = rest;
                continue ;
              }
              var d = Curry._1(funarg.get_data, c);
              if (d !== undefined) {
                return Caml_option.valFromOption(d);
              }
              _param = rest;
              continue ;
            }
            _param = param._2;
            continue ;
          }
          throw {
                RE_EXN_ID: Stdlib.Not_found,
                Error: new Error()
              };
        };
      };
      var find_opt = function (h, key) {
        var hkey = Curry._2(funarg.hash, h.seed, key);
        var _param = Caml_array.get(h.data, key_index(h, hkey));
        while(true) {
          var param = _param;
          if (!param) {
            return ;
          }
          if (hkey === param._0) {
            var rest = param._2;
            var c = param._1;
            var match = Curry._2(funarg.equal, c, key);
            if (match) {
              _param = rest;
              continue ;
            }
            var d = Curry._1(funarg.get_data, c);
            if (d !== undefined) {
              return d;
            }
            _param = rest;
            continue ;
          }
          _param = param._2;
          continue ;
        };
      };
      var find_all = function (h, key) {
        var hkey = Curry._2(funarg.hash, h.seed, key);
        var find_in_bucket = function (_param) {
          while(true) {
            var param = _param;
            if (!param) {
              return /* [] */0;
            }
            if (hkey === param._0) {
              var rest = param._2;
              var c = param._1;
              var match = Curry._2(funarg.equal, c, key);
              if (match) {
                _param = rest;
                continue ;
              }
              var d = Curry._1(funarg.get_data, c);
              if (d !== undefined) {
                return {
                        hd: Caml_option.valFromOption(d),
                        tl: find_in_bucket(rest)
                      };
              }
              _param = rest;
              continue ;
            }
            _param = param._2;
            continue ;
          };
        };
        return find_in_bucket(Caml_array.get(h.data, key_index(h, hkey)));
      };
      var replace = function (h, key, info) {
        var hkey = Curry._2(funarg.hash, h.seed, key);
        var i = key_index(h, hkey);
        var l = Caml_array.get(h.data, i);
        try {
          var _param = l;
          while(true) {
            var param = _param;
            if (param) {
              if (hkey === param._0) {
                var c = param._1;
                var match = Curry._2(funarg.equal, c, key);
                if (!match) {
                  return Curry._3(funarg.set_key_data, c, key, info);
                }
                _param = param._2;
                continue ;
              }
              _param = param._2;
              continue ;
            }
            throw {
                  RE_EXN_ID: Stdlib.Not_found,
                  Error: new Error()
                };
          };
        }
        catch (raw_exn){
          var exn = Caml_js_exceptions.internalToOCamlException(raw_exn);
          if (exn.RE_EXN_ID === Stdlib.Not_found) {
            var container = Curry._2(funarg.create, key, info);
            Caml_array.set(h.data, i, /* Cons */{
                  _0: hkey,
                  _1: container,
                  _2: l
                });
            h.size = h.size + 1 | 0;
            if (h.size > (h.data.length << 1)) {
              return resize(h);
            } else {
              return ;
            }
          }
          throw exn;
        }
      };
      var mem = function (h, key) {
        var hkey = Curry._2(funarg.hash, h.seed, key);
        var _param = Caml_array.get(h.data, key_index(h, hkey));
        while(true) {
          var param = _param;
          if (!param) {
            return false;
          }
          if (param._0 === hkey) {
            var match = Curry._2(funarg.equal, param._1, key);
            if (!match) {
              return true;
            }
            _param = param._2;
            continue ;
          }
          _param = param._2;
          continue ;
        };
      };
      var iter = function (f, h) {
        var do_bucket = function (_param) {
          while(true) {
            var param = _param;
            if (!param) {
              return ;
            }
            var c = param._1;
            var match = Curry._1(funarg.get_key, c);
            var match$1 = Curry._1(funarg.get_data, c);
            if (match !== undefined && match$1 !== undefined) {
              Curry._2(f, Caml_option.valFromOption(match), Caml_option.valFromOption(match$1));
            }
            _param = param._2;
            continue ;
          };
        };
        var d = h.data;
        for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
          do_bucket(Caml_array.get(d, i));
        }
      };
      var fold = function (f, h, init) {
        var do_bucket = function (_b, _accu) {
          while(true) {
            var accu = _accu;
            var b = _b;
            if (!b) {
              return accu;
            }
            var c = b._1;
            var match = Curry._1(funarg.get_key, c);
            var match$1 = Curry._1(funarg.get_data, c);
            var accu$1 = match !== undefined && match$1 !== undefined ? Curry._3(f, Caml_option.valFromOption(match), Caml_option.valFromOption(match$1), accu) : accu;
            _accu = accu$1;
            _b = b._2;
            continue ;
          };
        };
        var d = h.data;
        var accu = init;
        for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
          accu = do_bucket(Caml_array.get(d, i), accu);
        }
        return accu;
      };
      var filter_map_inplace = function (f, h) {
        var do_bucket = function (_param) {
          while(true) {
            var param = _param;
            if (!param) {
              return /* Empty */0;
            }
            var rest = param._2;
            var c = param._1;
            var match = Curry._1(funarg.get_key, c);
            var match$1 = Curry._1(funarg.get_data, c);
            if (match !== undefined) {
              if (match$1 !== undefined) {
                var k = Caml_option.valFromOption(match);
                var new_d = Curry._2(f, k, Caml_option.valFromOption(match$1));
                if (new_d !== undefined) {
                  Curry._3(funarg.set_key_data, c, k, Caml_option.valFromOption(new_d));
                  return /* Cons */{
                          _0: param._0,
                          _1: c,
                          _2: do_bucket(rest)
                        };
                }
                _param = rest;
                continue ;
              }
              _param = rest;
              continue ;
            }
            _param = rest;
            continue ;
          };
        };
        var d = h.data;
        for(var i = 0 ,i_finish = d.length; i < i_finish; ++i){
          Caml_array.set(d, i, do_bucket(Caml_array.get(d, i)));
        }
      };
      var length = function (h) {
        return h.size;
      };
      var bucket_length = function (_accu, _param) {
        while(true) {
          var param = _param;
          var accu = _accu;
          if (!param) {
            return accu;
          }
          _param = param._2;
          _accu = accu + 1 | 0;
          continue ;
        };
      };
      var stats = function (h) {
        var mbl = Stdlib__Array.fold_left((function (m, b) {
                return Stdlib__Int.max(m, bucket_length(0, b));
              }), 0, h.data);
        var histo = Caml_array.make(mbl + 1 | 0, 0);
        Stdlib__Array.iter((function (b) {
                var l = bucket_length(0, b);
                Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
              }), h.data);
        return {
                num_bindings: h.size,
                num_buckets: h.data.length,
                max_bucket_length: mbl,
                bucket_histogram: histo
              };
      };
      var bucket_length_alive = function (_accu, _param) {
        while(true) {
          var param = _param;
          var accu = _accu;
          if (!param) {
            return accu;
          }
          if (Curry._1(funarg.check_key, param._1)) {
            _param = param._2;
            _accu = accu + 1 | 0;
            continue ;
          }
          _param = param._2;
          continue ;
        };
      };
      var stats_alive = function (h) {
        var size = {
          contents: 0
        };
        var mbl = Stdlib__Array.fold_left((function (m, b) {
                return Stdlib__Int.max(m, bucket_length_alive(0, b));
              }), 0, h.data);
        var histo = Caml_array.make(mbl + 1 | 0, 0);
        Stdlib__Array.iter((function (b) {
                var l = bucket_length_alive(0, b);
                size.contents = size.contents + l | 0;
                Caml_array.set(histo, l, Caml_array.get(histo, l) + 1 | 0);
              }), h.data);
        return {
                num_bindings: size.contents,
                num_buckets: h.data.length,
                max_bucket_length: mbl,
                bucket_histogram: histo
              };
      };
      var to_seq = function (tbl) {
        var tbl_data = tbl.data;
        var aux = function (_i, _buck, _param) {
          while(true) {
            var buck = _buck;
            var i = _i;
            if (buck) {
              var next = buck._2;
              var c = buck._1;
              var match = Curry._1(funarg.get_key, c);
              var match$1 = Curry._1(funarg.get_data, c);
              if (match !== undefined) {
                if (match$1 !== undefined) {
                  return /* Cons */{
                          _0: [
                            Caml_option.valFromOption(match),
                            Caml_option.valFromOption(match$1)
                          ],
                          _1: (function(i,next){
                          return function (param) {
                            return aux(i, next, param);
                          }
                          }(i,next))
                        };
                }
                _param = undefined;
                _buck = next;
                continue ;
              }
              _param = undefined;
              _buck = next;
              continue ;
            }
            if (i === tbl_data.length) {
              return /* Nil */0;
            }
            _param = undefined;
            _buck = Caml_array.get(tbl_data, i);
            _i = i + 1 | 0;
            continue ;
          };
        };
        return function (param) {
          return aux(0, /* Empty */0, param);
        };
      };
      var to_seq_keys = function (m) {
        var partial_arg = to_seq(m);
        return function (param) {
          return Stdlib__Seq.map((function (prim) {
                        return prim[0];
                      }), partial_arg, param);
        };
      };
      var to_seq_values = function (m) {
        var partial_arg = to_seq(m);
        return function (param) {
          return Stdlib__Seq.map((function (prim) {
                        return prim[1];
                      }), partial_arg, param);
        };
      };
      var add_seq = function (tbl, i) {
        Stdlib__Seq.iter((function (param) {
                add(tbl, param[0], param[1]);
              }), i);
      };
      var replace_seq = function (tbl, i) {
        Stdlib__Seq.iter((function (param) {
                replace(tbl, param[0], param[1]);
              }), i);
      };
      var of_seq = function (i) {
        var tbl = create(undefined, 16);
        replace_seq(tbl, i);
        return tbl;
      };
      return {
              create: create,
              clear: clear,
              reset: reset,
              copy: copy,
              add: add,
              remove: remove,
              find: find,
              find_opt: find_opt,
              find_all: find_all,
              replace: replace,
              mem: mem,
              iter: iter,
              filter_map_inplace: filter_map_inplace,
              fold: fold,
              length: length,
              stats: stats,
              to_seq: to_seq,
              to_seq_keys: to_seq_keys,
              to_seq_values: to_seq_values,
              add_seq: add_seq,
              replace_seq: replace_seq,
              of_seq: of_seq,
              clean: clean,
              stats_alive: stats_alive
            };
    })
};

exports.K1 = K1;
exports.K2 = K2;
exports.Kn = Kn;
exports.GenHashTable = GenHashTable;
/* Stdlib__Random Not a pure module */
