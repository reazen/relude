// Generated by Melange
'use strict';

var Curry = require("melange.runtime/curry.js");
var Stdlib = require("melange/./stdlib.js");
var Caml_array = require("melange.runtime/caml_array.js");
var Stdlib__List = require("melange/./list.js");
var Stdlib__Array = require("melange/./array.js");
var Stdlib__Buffer = require("melange/./buffer.js");
var Stdlib__Format = require("melange/./format.js");
var Stdlib__Printf = require("melange/./printf.js");
var Stdlib__Random = require("melange/./random.js");
var Stdlib__Hashtbl = require("melange/./hashtbl.js");
var CamlinternalLazy = require("melange/./camlinternalLazy.js");

var coverage_file_identifier = "BISECT-COVERAGE-4";

function write_int(formatter, i) {
  Curry._1(Stdlib__Format.fprintf(formatter)(/* Format */{
            _0: {
              TAG: /* Char_literal */12,
              _0: /* ' ' */32,
              _1: {
                TAG: /* Int */4,
                _0: /* Int_i */3,
                _1: /* No_padding */0,
                _2: /* No_precision */0,
                _3: /* End_of_format */0
              }
            },
            _1: " %i"
          }), i);
}

function write_string(formatter, s) {
  Curry._2(Stdlib__Format.fprintf(formatter)(/* Format */{
            _0: {
              TAG: /* Char_literal */12,
              _0: /* ' ' */32,
              _1: {
                TAG: /* Int */4,
                _0: /* Int_i */3,
                _1: /* No_padding */0,
                _2: /* No_precision */0,
                _3: {
                  TAG: /* Char_literal */12,
                  _0: /* ' ' */32,
                  _1: {
                    TAG: /* String */2,
                    _0: /* No_padding */0,
                    _1: /* End_of_format */0
                  }
                }
              }
            },
            _1: " %i %s"
          }), s.length, s);
}

function write_array(write_element, formatter, a) {
  Curry._1(Stdlib__Format.fprintf(formatter)(/* Format */{
            _0: {
              TAG: /* Char_literal */12,
              _0: /* ' ' */32,
              _1: {
                TAG: /* Int */4,
                _0: /* Int_i */3,
                _1: /* No_padding */0,
                _2: /* No_precision */0,
                _3: /* End_of_format */0
              }
            },
            _1: " %i"
          }), a.length);
  Stdlib__Array.iter(Curry._1(write_element, formatter), a);
}

function write_list(write_element, formatter, l) {
  Curry._1(Stdlib__Format.fprintf(formatter)(/* Format */{
            _0: {
              TAG: /* Char_literal */12,
              _0: /* ' ' */32,
              _1: {
                TAG: /* Int */4,
                _0: /* Int_i */3,
                _1: /* No_padding */0,
                _2: /* No_precision */0,
                _3: /* End_of_format */0
              }
            },
            _1: " %i"
          }), Stdlib__List.length(l));
  Stdlib__List.iter(Curry._1(write_element, formatter), l);
}

function write_instrumented_file(formatter, param) {
  write_string(formatter, param.filename);
  write_array(write_int, formatter, param.points);
  write_array(write_int, formatter, param.counts);
}

function write_coverage(formatter, coverage) {
  Curry._1(Stdlib__Format.fprintf(formatter)(/* Format */{
            _0: {
              TAG: /* String */2,
              _0: /* No_padding */0,
              _1: /* End_of_format */0
            },
            _1: "%s"
          }), coverage_file_identifier);
  write_list(write_instrumented_file, formatter, coverage);
  Stdlib__Format.pp_print_flush(formatter, undefined);
}

var coverage = {
  LAZY_DONE: false,
  VAL: (function () {
      return Stdlib__Hashtbl.create(undefined, 17);
    })
};

function register_file(filename, points) {
  var counts = Caml_array.make(points.length, 0);
  var coverage$1 = CamlinternalLazy.force(coverage);
  if (!Stdlib__Hashtbl.mem(coverage$1, filename)) {
    Stdlib__Hashtbl.add(coverage$1, filename, {
          filename: filename,
          points: points,
          counts: counts
        });
  }
  return {
          NAME: "Visit",
          VAL: (function (index) {
              var current_count = Caml_array.get(counts, index);
              if (current_count < Stdlib.max_int) {
                return Caml_array.set(counts, index, current_count + 1 | 0);
              }
              
            })
        };
}

function flatten_coverage(coverage) {
  return Stdlib__Hashtbl.fold((function (param, file, acc) {
                return {
                        hd: file,
                        tl: acc
                      };
              }), coverage, /* [] */0);
}

function reset_counters(param) {
  Stdlib__Hashtbl.iter((function (param, param$1) {
          var counts = param$1.counts;
          var n = counts.length;
          if (n !== 0) {
            return Stdlib__Array.fill(counts, 0, n - 1 | 0, 0);
          }
          
        }), CamlinternalLazy.force(coverage));
}

function runtime_data_to_string(param) {
  var data = flatten_coverage(CamlinternalLazy.force(coverage));
  if (!data) {
    return ;
  }
  var buffer = Stdlib__Buffer.create(4096);
  write_coverage(Stdlib__Format.formatter_of_buffer(buffer), data);
  return Stdlib__Buffer.contents(buffer);
}

function write_runtime_coverage(coverage, channel) {
  write_coverage(Stdlib__Format.formatter_of_out_channel(channel), flatten_coverage(coverage));
}

function write_runtime_data(channel) {
  write_coverage(Stdlib__Format.formatter_of_out_channel(channel), flatten_coverage(CamlinternalLazy.force(coverage)));
}

var prng = Stdlib__Random.State.make_self_init(undefined);

function random_filename(prefix) {
  return Curry._2(Stdlib__Printf.sprintf(/* Format */{
                  _0: {
                    TAG: /* String */2,
                    _0: /* No_padding */0,
                    _1: {
                      TAG: /* Int */4,
                      _0: /* Int_d */0,
                      _1: {
                        TAG: /* Lit_padding */0,
                        _0: /* Zeros */2,
                        _1: 9
                      },
                      _2: /* No_precision */0,
                      _3: {
                        TAG: /* String_literal */11,
                        _0: ".coverage",
                        _1: /* End_of_format */0
                      }
                    }
                  },
                  _1: "%s%09d.coverage"
                }), prefix, Stdlib.abs(Stdlib__Random.State.$$int(prng, 1000000000)));
}

exports.coverage_file_identifier = coverage_file_identifier;
exports.register_file = register_file;
exports.write_runtime_coverage = write_runtime_coverage;
exports.write_runtime_data = write_runtime_data;
exports.runtime_data_to_string = runtime_data_to_string;
exports.reset_counters = reset_counters;
exports.random_filename = random_filename;
/* prng Not a pure module */
