// Generated by Melange
'use strict';

var Curry = require("melange.runtime/curry.js");
var Bastet__Interface = require("./Interface.js");

function Magma(M) {
  return {
          $less$colon$great: M.append
        };
}

function Magma_Any(M) {
  return {
          $less$colon$great: M.append
        };
}

function Functor(F) {
  var $less$at$great = function (f, x) {
    return Curry._2(F.map, x, f);
  };
  return {
          $less$$great: F.map,
          $less$at$great: $less$at$great
        };
}

function Apply(A) {
  var $less$at$great = function (f, x) {
    return Curry._2(A.map, x, f);
  };
  return {
          $less$$great: A.map,
          $less$at$great: $less$at$great,
          $less$star$great: A.apply
        };
}

function Monad(M) {
  var $less$at$great = function (f, x) {
    return Curry._2(M.map, x, f);
  };
  var $great$great$eq = M.flat_map;
  var $eq$less$less = function (ma, f) {
    return Curry._2(M.flat_map, f, ma);
  };
  var $great$eq$great = function (f, g, a) {
    return Curry._2($great$great$eq, Curry._1(f, a), g);
  };
  var $less$eq$less = function (f, g, a) {
    var f$1 = Curry._1(g, a);
    return Curry._2(M.flat_map, f$1, f);
  };
  return {
          $less$$great: M.map,
          $less$at$great: $less$at$great,
          $less$star$great: M.apply,
          $great$great$eq: $great$great$eq,
          $eq$less$less: $eq$less$less,
          $great$eq$great: $great$eq$great,
          $less$eq$less: $less$eq$less
        };
}

function Alt(A) {
  var $less$at$great = function (f, x) {
    return Curry._2(A.map, x, f);
  };
  return {
          $less$$great: A.map,
          $less$at$great: $less$at$great,
          $less$pipe$great: A.alt
        };
}

function Alternative(A) {
  var $less$at$great = function (f, x) {
    return Curry._2(A.map, x, f);
  };
  return {
          $less$pipe$great: A.alt,
          $less$$great: A.map,
          $less$at$great: $less$at$great,
          $less$star$great: A.apply
        };
}

function Semigroupoid(S) {
  var $great$dot = function (g, f) {
    return Curry._2(S.compose, f, g);
  };
  return {
          $less$dot: S.compose,
          $great$dot: $great$dot
        };
}

function Eq(E) {
  return {
          $eq$pipe$eq: E.eq
        };
}

function Ord(O) {
  var Fn = Bastet__Interface.Ordering(O);
  return {
          $less$pipe$pipe: Fn.less_than,
          $pipe$pipe$great: Fn.greater_than,
          $less$pipe$eq: Fn.less_than_or_equal,
          $great$pipe$eq: Fn.greater_than_or_equal
        };
}

function Semiring(S) {
  return {
          $pipe$plus$pipe: S.add,
          $pipe$star$pipe: S.multiply
        };
}

function Ring(R) {
  return {
          $pipe$plus$pipe: R.add,
          $pipe$star$pipe: R.multiply,
          $pipe$neg$pipe: R.subtract
        };
}

function Euclidean_Ring(E) {
  return {
          $pipe$plus$pipe: E.add,
          $pipe$star$pipe: E.multiply,
          $pipe$neg$pipe: E.subtract,
          $pipe$slash$pipe: E.divide,
          $pipe$percent$pipe: E.modulo
        };
}

function Extend(E) {
  var $eq$great$great = function (a, f) {
    return Curry._2(E.extend, f, a);
  };
  return {
          $less$less$eq: E.extend,
          $eq$great$great: $eq$great$great
        };
}

function Bifunctor(B) {
  return {
          $less$less$$great$great: B.bimap
        };
}

function Biapply(B) {
  return {
          $less$less$$great$great: B.bimap,
          $less$less$star$great$great: B.biapply
        };
}

function Join_Semilattice(J) {
  return {
          $less$pipe$pipe$great: J.join
        };
}

function Meet_Semilattice(M) {
  return {
          $less$amp$amp$great: M.meet
        };
}

function Heyting_Algebra(H) {
  return {
          $neg$neg$great: H.implies
        };
}

exports.Magma = Magma;
exports.Magma_Any = Magma_Any;
exports.Functor = Functor;
exports.Apply = Apply;
exports.Monad = Monad;
exports.Alt = Alt;
exports.Alternative = Alternative;
exports.Semigroupoid = Semigroupoid;
exports.Eq = Eq;
exports.Ord = Ord;
exports.Semiring = Semiring;
exports.Ring = Ring;
exports.Euclidean_Ring = Euclidean_Ring;
exports.Extend = Extend;
exports.Bifunctor = Bifunctor;
exports.Biapply = Biapply;
exports.Join_Semilattice = Join_Semilattice;
exports.Meet_Semilattice = Meet_Semilattice;
exports.Heyting_Algebra = Heyting_Algebra;
/* No side effect */
