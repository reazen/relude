// Generated by Melange
'use strict';

var Curry = require("melange.runtime/curry.js");
var Caml_obj = require("melange.runtime/caml_obj.js");
var Bastet__Infix = require("./Infix.js");
var Bastet__Function = require("./Function.js");

function Medial_Magma(M, E) {
  var I = Bastet__Infix.Magma(M);
  var bicommutativity = function (a, b, c, d) {
    return Curry._2(E.eq, Curry._2(I.$less$colon$great, Curry._2(I.$less$colon$great, a, b), Curry._2(I.$less$colon$great, c, d)), Curry._2(I.$less$colon$great, Curry._2(I.$less$colon$great, a, c), Curry._2(I.$less$colon$great, b, d)));
  };
  return {
          I: I,
          bicommutativity: bicommutativity
        };
}

function Semigroup(S, E) {
  var I = Bastet__Infix.Magma(S);
  var associativity = function (a, b, c) {
    return Curry._2(E.eq, Curry._2(I.$less$colon$great, a, Curry._2(I.$less$colon$great, b, c)), Curry._2(I.$less$colon$great, a, Curry._2(I.$less$colon$great, b, c)));
  };
  return {
          I: I,
          associativity: associativity
        };
}

function Semigroup_Any(S, E) {
  var I = Bastet__Infix.Magma_Any(S);
  var associativity = function (a, b, c) {
    return Curry._2(E.eq, Curry._2(I.$less$colon$great, a, Curry._2(I.$less$colon$great, b, c)), Curry._2(I.$less$colon$great, a, Curry._2(I.$less$colon$great, b, c)));
  };
  return {
          I: I,
          associativity: associativity
        };
}

function Monoid(M, E) {
  var I = Bastet__Infix.Magma(M);
  var identity = function (a) {
    if (Curry._2(E.eq, Curry._2(I.$less$colon$great, a, M.empty), a)) {
      return Curry._2(E.eq, Curry._2(I.$less$colon$great, M.empty, a), a);
    } else {
      return false;
    }
  };
  return {
          I: I,
          identity: identity
        };
}

function Monoid_Any(M, E) {
  var I = Bastet__Infix.Magma_Any(M);
  var identity = function (a) {
    if (Curry._2(E.eq, Curry._2(I.$less$colon$great, a, M.empty), a)) {
      return Curry._2(E.eq, Curry._2(I.$less$colon$great, M.empty, a), a);
    } else {
      return false;
    }
  };
  return {
          I: I,
          identity: identity
        };
}

function Quasigroup(Q, E) {
  var I = Bastet__Infix.Magma(Q);
  var cancellative = function (a, b, c) {
    if (!Curry._2(E.eq, Curry._2(I.$less$colon$great, a, b), Curry._2(I.$less$colon$great, a, c)) || Curry._2(E.eq, b, c)) {
      if (Curry._2(E.eq, Curry._2(I.$less$colon$great, b, a), Curry._2(I.$less$colon$great, c, a))) {
        return Curry._2(E.eq, b, c);
      } else {
        return true;
      }
    } else {
      return false;
    }
  };
  return {
          I: I,
          cancellative: cancellative
        };
}

function Quasigroup_Any(Q, E) {
  var I = Bastet__Infix.Magma_Any(Q);
  var cancellative = function (a, b, c) {
    if (!Curry._2(E.eq, Curry._2(I.$less$colon$great, a, b), Curry._2(I.$less$colon$great, a, c)) || Curry._2(E.eq, b, c)) {
      if (Curry._2(E.eq, Curry._2(I.$less$colon$great, b, a), Curry._2(I.$less$colon$great, c, a))) {
        return Curry._2(E.eq, b, c);
      } else {
        return true;
      }
    } else {
      return false;
    }
  };
  return {
          I: I,
          cancellative: cancellative
        };
}

function Medial_Quasigroup(Q, E) {
  var I = Bastet__Infix.Magma(Q);
  var cancellative = function (a, b, c) {
    if (!Curry._2(E.eq, Curry._2(I.$less$colon$great, a, b), Curry._2(I.$less$colon$great, a, c)) || Curry._2(E.eq, b, c)) {
      if (Curry._2(E.eq, Curry._2(I.$less$colon$great, b, a), Curry._2(I.$less$colon$great, c, a))) {
        return Curry._2(E.eq, b, c);
      } else {
        return true;
      }
    } else {
      return false;
    }
  };
  return {
          I: I,
          cancellative: cancellative
        };
}

function Loop(L, E) {
  var I = Bastet__Infix.Magma(L);
  var identity = function (a) {
    if (Curry._2(E.eq, Curry._2(I.$less$colon$great, a, L.empty), a)) {
      return Curry._2(E.eq, Curry._2(I.$less$colon$great, L.empty, a), a);
    } else {
      return false;
    }
  };
  return {
          I: I,
          identity: identity
        };
}

function Loop_Any(L, E) {
  var I = Bastet__Infix.Magma_Any(L);
  var identity = function (a) {
    if (Curry._2(E.eq, Curry._2(I.$less$colon$great, a, L.empty), a)) {
      return Curry._2(E.eq, Curry._2(I.$less$colon$great, L.empty, a), a);
    } else {
      return false;
    }
  };
  return {
          I: I,
          identity: identity
        };
}

function Group(G, E) {
  var I = Bastet__Infix.Magma(G);
  var invertibility = function (a) {
    if (Curry._2(E.eq, Curry._2(I.$less$colon$great, Curry._1(G.inverse, a), a), G.empty)) {
      return Curry._2(E.eq, Curry._2(I.$less$colon$great, a, Curry._1(G.inverse, a)), G.empty);
    } else {
      return false;
    }
  };
  var associativity = function (a, b, c) {
    return Curry._2(E.eq, Curry._2(I.$less$colon$great, a, Curry._2(I.$less$colon$great, b, c)), Curry._2(I.$less$colon$great, a, Curry._2(I.$less$colon$great, b, c)));
  };
  return {
          I: I,
          invertibility: invertibility,
          associativity: associativity
        };
}

function Group_Any(G, E) {
  var I = Bastet__Infix.Magma_Any(G);
  var invertibility = function (a) {
    if (Curry._2(E.eq, Curry._2(I.$less$colon$great, Curry._1(G.inverse, a), a), G.empty)) {
      return Curry._2(E.eq, Curry._2(I.$less$colon$great, a, Curry._1(G.inverse, a)), G.empty);
    } else {
      return false;
    }
  };
  var associativity = function (a, b, c) {
    return Curry._2(E.eq, Curry._2(I.$less$colon$great, a, Curry._2(I.$less$colon$great, b, c)), Curry._2(I.$less$colon$great, a, Curry._2(I.$less$colon$great, b, c)));
  };
  return {
          I: I,
          invertibility: invertibility,
          associativity: associativity
        };
}

function Abelian_Group(A, E) {
  var commutativity = function (a, b) {
    return Curry._2(E.eq, Curry._2(A.append, a, b), Curry._2(A.append, b, a));
  };
  return {
          commutativity: commutativity
        };
}

function Abelian_Group_Any(A, E) {
  var commutativity = function (a, b) {
    return Curry._2(E.eq, Curry._2(A.append, a, b), Curry._2(A.append, b, a));
  };
  return {
          commutativity: commutativity
        };
}

function Functor(F, E) {
  var $less$dot = Bastet__Function.Infix.$less$dot;
  var identity = function (a) {
    return Curry._2(E.eq, Curry._2(F.map, Bastet__Function.Category.id, a), a);
  };
  var composition = function (f, g, a) {
    return Curry._2(E.eq, Curry._2(F.map, Curry._2($less$dot, f, g), a), Curry._3($less$dot, Curry._1(F.map, f), Curry._1(F.map, g), a));
  };
  return {
          $less$dot: $less$dot,
          identity: identity,
          composition: composition
        };
}

function Apply(A, E) {
  var I = Bastet__Infix.Apply(A);
  var associative_composition = function (f, g, h) {
    return Curry._2(E.eq, Curry._2(I.$less$star$great, Curry._2(I.$less$star$great, Curry._2(A.map, Bastet__Function.Semigroupoid.compose, f), g), h), Curry._2(I.$less$star$great, f, Curry._2(I.$less$star$great, g, h)));
  };
  return {
          I: I,
          associative_composition: associative_composition
        };
}

function Applicative(A, E) {
  var I = Bastet__Infix.Apply(A);
  var identity = function (a) {
    return Curry._2(E.eq, Curry._2(I.$less$star$great, Curry._1(A.pure, Bastet__Function.Category.id), a), a);
  };
  var homomorphism = function (f, x) {
    return Curry._2(E.eq, Curry._2(I.$less$star$great, Curry._1(A.pure, f), Curry._1(A.pure, x)), Curry._1(A.pure, Curry._1(f, x)));
  };
  var interchange = function (f, x) {
    return Curry._2(E.eq, Curry._2(I.$less$star$great, f, Curry._1(A.pure, x)), Curry._2(I.$less$star$great, Curry._1(A.pure, (function (f$p) {
                          return Curry._1(f$p, x);
                        })), f));
  };
  return {
          I: I,
          identity: identity,
          homomorphism: homomorphism,
          interchange: interchange
        };
}

function Monad(M, E) {
  var I = Bastet__Infix.Monad(M);
  var associativity = function (f, g, x) {
    return Curry._2(E.eq, Curry._2(I.$great$great$eq, Curry._2(I.$great$great$eq, x, f), g), Curry._2(I.$great$great$eq, x, (function (k) {
                      return Curry._2(I.$great$great$eq, Curry._1(f, k), g);
                    })));
  };
  var identity = function (f, x) {
    if (Curry._2(E.eq, Curry._2(I.$great$great$eq, Curry._1(M.pure, x), f), Curry._1(f, x))) {
      return Curry._2(E.eq, Curry._2(I.$great$great$eq, Curry._1(M.pure, x), M.pure), Curry._1(M.pure, x));
    } else {
      return false;
    }
  };
  return {
          I: I,
          associativity: associativity,
          identity: identity
        };
}

function Alt(A, E) {
  var I = Bastet__Infix.Alt(A);
  var associativity = function (a, b, c) {
    return Curry._2(E.eq, Curry._2(I.$less$pipe$great, a, Curry._2(I.$less$pipe$great, b, c)), Curry._2(I.$less$pipe$great, a, Curry._2(I.$less$pipe$great, b, c)));
  };
  var distributivity = function (f, a, b) {
    return Curry._2(E.eq, Curry._2(A.map, f, Curry._2(I.$less$pipe$great, a, b)), Curry._2(I.$less$pipe$great, Curry._2(A.map, f, a), Curry._2(A.map, f, b)));
  };
  return {
          I: I,
          associativity: associativity,
          distributivity: distributivity
        };
}

function Plus(P, E) {
  var I = Bastet__Infix.Alt(P);
  var annihalation = function (f) {
    return Curry._2(E.eq, Curry._2(P.map, f, P.empty), P.empty);
  };
  var identity = function (a) {
    if (Curry._2(E.eq, Curry._2(I.$less$pipe$great, P.empty, a), a)) {
      return Curry._2(E.eq, Curry._2(I.$less$pipe$great, a, P.empty), a);
    } else {
      return false;
    }
  };
  return {
          I: I,
          annihalation: annihalation,
          identity: identity
        };
}

function Alternative(A, E) {
  var I = Bastet__Infix.Alternative(A);
  var distributivity = function (f, g, x) {
    return Curry._2(E.eq, Curry._2(I.$less$star$great, Curry._2(I.$less$pipe$great, f, g), x), Curry._2(I.$less$pipe$great, Curry._2(I.$less$star$great, f, x), Curry._2(I.$less$star$great, g, x)));
  };
  var annihalation = function (f) {
    return Curry._2(E.eq, Curry._2(I.$less$star$great, A.empty, f), A.empty);
  };
  return {
          I: I,
          distributivity: distributivity,
          annihalation: annihalation
        };
}

function Semigroupoid(S, E) {
  var I = Bastet__Infix.Semigroupoid(S);
  var associativity = function (a, b, c) {
    return Curry._2(E.eq, Curry._2(I.$less$dot, Curry._2(I.$less$dot, a, b), c), Curry._2(I.$less$dot, a, Curry._2(I.$less$dot, b, c)));
  };
  return {
          I: I,
          associativity: associativity
        };
}

function Category(C, E) {
  var I = Bastet__Infix.Semigroupoid(C);
  var identity = function (a) {
    if (Curry._2(E.eq, Curry._2(I.$less$dot, C.id, a), a)) {
      return Curry._2(E.eq, Curry._2(I.$less$dot, a, C.id), a);
    } else {
      return false;
    }
  };
  return {
          I: I,
          identity: identity
        };
}

function Eq(E) {
  var I = Bastet__Infix.Eq(E);
  var reflexivity = function (a) {
    return Curry._2(I.$eq$pipe$eq, a, a);
  };
  var symmetry = function (a, b) {
    return Curry._2(I.$eq$pipe$eq, a, b) === Curry._2(I.$eq$pipe$eq, b, a);
  };
  var transitivity = function (a, b, c) {
    if (Curry._2(I.$eq$pipe$eq, a, b) && Curry._2(I.$eq$pipe$eq, b, c)) {
      return Curry._2(I.$eq$pipe$eq, a, c);
    } else {
      return true;
    }
  };
  return {
          I: I,
          reflexivity: reflexivity,
          symmetry: symmetry,
          transitivity: transitivity
        };
}

function Quasireflexive_Eq(E) {
  var I = Bastet__Infix.Eq(E);
  var quasireflexivity = function (a, b) {
    if (Curry._2(I.$eq$pipe$eq, a, b)) {
      if (Curry._2(I.$eq$pipe$eq, a, a)) {
        return Curry._2(I.$eq$pipe$eq, b, b);
      } else {
        return false;
      }
    } else {
      return true;
    }
  };
  var symmetry = function (a, b) {
    return Curry._2(I.$eq$pipe$eq, a, b) === Curry._2(I.$eq$pipe$eq, b, a);
  };
  var transitivity = function (a, b, c) {
    if (Curry._2(I.$eq$pipe$eq, a, b) && Curry._2(I.$eq$pipe$eq, b, c)) {
      return Curry._2(I.$eq$pipe$eq, a, c);
    } else {
      return true;
    }
  };
  return {
          I: I,
          quasireflexivity: quasireflexivity,
          symmetry: symmetry,
          transitivity: transitivity
        };
}

function Ord(E) {
  var Ordering_Functions = Bastet__Infix.Ord(E);
  var $less$pipe$eq = Ordering_Functions.$less$pipe$eq;
  var reflexivity = function (a) {
    return Curry._2($less$pipe$eq, a, a);
  };
  var antisymmetry = function (a, b) {
    if (Curry._2($less$pipe$eq, a, b) && Curry._2($less$pipe$eq, b, a)) {
      return Caml_obj.caml_equal(a, b);
    } else {
      return true;
    }
  };
  var transitivity = function (a, b, c) {
    if (Curry._2($less$pipe$eq, a, b) && Curry._2($less$pipe$eq, b, c)) {
      return Curry._2($less$pipe$eq, a, c);
    } else {
      return true;
    }
  };
  return {
          Ordering_Functions: Ordering_Functions,
          $less$pipe$eq: $less$pipe$eq,
          $great$pipe$eq: Ordering_Functions.$great$pipe$eq,
          reflexivity: reflexivity,
          antisymmetry: antisymmetry,
          transitivity: transitivity
        };
}

function Bounded(B) {
  var Ordering_Functions = Bastet__Infix.Ord(B);
  var $less$pipe$eq = Ordering_Functions.$less$pipe$eq;
  var bounded = function (a) {
    if (Curry._2($less$pipe$eq, B.bottom, a)) {
      return Curry._2($less$pipe$eq, a, B.top);
    } else {
      return false;
    }
  };
  return {
          Ordering_Functions: Ordering_Functions,
          $less$pipe$eq: $less$pipe$eq,
          bounded: bounded
        };
}

function Join_Semilattice(J, E) {
  var associativity = function (a, b, c) {
    return Curry._2(E.eq, Curry._2(J.join, a, Curry._2(J.join, b, c)), Curry._2(J.join, Curry._2(J.join, a, b), c));
  };
  var commutativity = function (a, b) {
    return Curry._2(E.eq, Curry._2(J.join, a, b), Curry._2(J.join, b, a));
  };
  var idempotency = function (a) {
    return Curry._2(E.eq, Curry._2(J.join, a, a), a);
  };
  return {
          associativity: associativity,
          commutativity: commutativity,
          idempotency: idempotency
        };
}

function Meet_Semilattice(M, E) {
  var associativity = function (a, b, c) {
    return Curry._2(E.eq, Curry._2(M.meet, a, Curry._2(M.meet, b, c)), Curry._2(M.meet, Curry._2(M.meet, a, b), c));
  };
  var commutativity = function (a, b) {
    return Curry._2(E.eq, Curry._2(M.meet, a, b), Curry._2(M.meet, b, a));
  };
  var idempotency = function (a) {
    return Curry._2(E.eq, Curry._2(M.meet, a, a), a);
  };
  return {
          associativity: associativity,
          commutativity: commutativity,
          idempotency: idempotency
        };
}

function Bounded_Join_Semilattice(B, E) {
  var identity = function (a) {
    return Caml_obj.caml_equal(Curry._2(B.join, a, B.bottom), a);
  };
  return {
          identity: identity
        };
}

function Bounded_Meet_Semilattice(B, E) {
  var identity = function (a) {
    return Caml_obj.caml_equal(Curry._2(B.meet, a, B.top), a);
  };
  return {
          identity: identity
        };
}

function Lattice(L, E) {
  var absorption = function (a, b) {
    if (Curry._2(E.eq, Curry._2(L.meet, a, Curry._2(L.join, a, b)), a)) {
      return Curry._2(E.eq, Curry._2(L.join, a, Curry._2(L.meet, a, b)), a);
    } else {
      return false;
    }
  };
  return {
          absorption: absorption
        };
}

function Bounded_Lattice(L, E) {
  var absorption = function (a, b) {
    if (Caml_obj.caml_equal(Curry._2(L.meet, a, Curry._2(L.join, a, b)), a)) {
      return Curry._2(E.eq, Curry._2(L.join, a, Curry._2(L.meet, a, b)), a);
    } else {
      return false;
    }
  };
  return {
          absorption: absorption
        };
}

function Distributive_Lattice(L, E) {
  var distributivity = function (a, b, c) {
    return Curry._2(E.eq, Curry._2(L.meet, a, Curry._2(L.join, b, c)), Curry._2(L.join, Curry._2(L.meet, a, b), Curry._2(L.meet, a, c)));
  };
  return {
          distributivity: distributivity
        };
}

function Bounded_Distributive_Lattice(L, E) {
  var distributivity = function (a, b, c) {
    return Curry._2(E.eq, Curry._2(L.meet, a, Curry._2(L.join, b, c)), Curry._2(L.join, Curry._2(L.meet, a, b), Curry._2(L.meet, a, c)));
  };
  return {
          distributivity: distributivity
        };
}

function Heyting_Algebra(H, E) {
  var O = Bastet__Infix.Ord(H);
  var $less$pipe$eq = O.$less$pipe$eq;
  var pseudocomplement = function (a) {
    return Curry._2(E.eq, Curry._1(H.not, a), Curry._2(H.implies, a, H.bottom));
  };
  var relative_pseudocomplement = function (a, b, c) {
    return Curry._2($less$pipe$eq, Curry._2(H.meet, c, a), b) === Curry._2($less$pipe$eq, c, Curry._2(H.implies, a, b));
  };
  return {
          O: O,
          $less$pipe$eq: $less$pipe$eq,
          pseudocomplement: pseudocomplement,
          relative_pseudocomplement: relative_pseudocomplement
        };
}

function Involutive_Heyting_Algebra(H, E) {
  var involution = function (a) {
    return Curry._2(E.eq, Curry._1(H.not, Curry._1(H.not, a)), a);
  };
  return {
          involution: involution
        };
}

function Boolean_Algebra(B, E) {
  var excluded_middle = function (a) {
    return Curry._2(E.eq, Curry._2(B.join, a, Curry._1(B.not, a)), B.top);
  };
  return {
          excluded_middle: excluded_middle
        };
}

function Semiring(S, E) {
  var I = Bastet__Infix.Semiring(S);
  var additive_associativity = function (a, b, c) {
    return Curry._2(E.eq, Curry._2(I.$pipe$plus$pipe, Curry._2(I.$pipe$plus$pipe, a, b), c), Curry._2(I.$pipe$plus$pipe, a, Curry._2(I.$pipe$plus$pipe, b, c)));
  };
  var additive_identity = function (a) {
    return Curry._2(E.eq, Curry._2(I.$pipe$plus$pipe, S.zero, a), a);
  };
  var commutativity = function (a, b) {
    return Curry._2(E.eq, Curry._2(I.$pipe$plus$pipe, a, b), Curry._2(I.$pipe$plus$pipe, b, a));
  };
  var multiplicative_associativity = function (a, b, c) {
    return Curry._2(E.eq, Curry._2(I.$pipe$star$pipe, Curry._2(I.$pipe$star$pipe, a, b), c), Curry._2(I.$pipe$star$pipe, a, Curry._2(I.$pipe$star$pipe, b, c)));
  };
  var multiplicative_identity = function (a) {
    return Curry._2(E.eq, Curry._2(I.$pipe$star$pipe, S.one, a), a);
  };
  var distributivity = function (a, b, c) {
    if (Curry._2(E.eq, Curry._2(I.$pipe$star$pipe, a, Curry._2(I.$pipe$plus$pipe, b, c)), Curry._2(I.$pipe$plus$pipe, Curry._2(I.$pipe$star$pipe, a, b), Curry._2(I.$pipe$star$pipe, a, c)))) {
      return Curry._2(E.eq, Curry._2(I.$pipe$star$pipe, Curry._2(I.$pipe$plus$pipe, a, b), c), Curry._2(I.$pipe$plus$pipe, Curry._2(I.$pipe$star$pipe, a, c), Curry._2(I.$pipe$star$pipe, b, c)));
    } else {
      return false;
    }
  };
  return {
          I: I,
          additive_associativity: additive_associativity,
          additive_identity: additive_identity,
          commutativity: commutativity,
          multiplicative_associativity: multiplicative_associativity,
          multiplicative_identity: multiplicative_identity,
          distributivity: distributivity
        };
}

function Ring(R, E) {
  var I = Bastet__Infix.Ring(R);
  var additive_inverse = function (a) {
    return Curry._2(E.eq, Curry._2(I.$pipe$plus$pipe, Curry._2(I.$pipe$neg$pipe, R.zero, a), a), R.zero);
  };
  return {
          I: I,
          additive_inverse: additive_inverse
        };
}

function Commutative_Ring(R, E) {
  var I = Bastet__Infix.Ring(R);
  var multiplicative_commutativity = function (a, b) {
    return Curry._2(E.eq, Curry._2(I.$pipe$star$pipe, a, b), Curry._2(I.$pipe$star$pipe, b, a));
  };
  return {
          I: I,
          multiplicative_commutativity: multiplicative_commutativity
        };
}

function Division_Ring(R, E) {
  var I = Bastet__Infix.Ring(R);
  var non_zero_ring = !Curry._2(E.eq, R.zero, R.one);
  var multiplicative_inverse = function (a) {
    return Curry._2(E.eq, Curry._2(I.$pipe$star$pipe, Curry._1(R.reciprocal, a), a), R.one);
  };
  return {
          I: I,
          non_zero_ring: non_zero_ring,
          multiplicative_inverse: multiplicative_inverse
        };
}

function Euclidean_Ring(R, E) {
  var I = Bastet__Infix.Euclidean_Ring(R);
  var non_zero_ring = !Curry._2(E.eq, R.zero, R.one);
  var integral_domain = function (a, b) {
    if (!Curry._2(E.eq, a, R.zero) && Caml_obj.caml_notequal(b, R.zero)) {
      return !Curry._2(E.eq, Curry._2(I.$pipe$star$pipe, a, b), R.zero);
    } else {
      return true;
    }
  };
  var non_negative_degree = function (a) {
    if (Curry._2(E.eq, a, R.zero)) {
      return true;
    } else {
      return Curry._1(R.degree, a) >= 0;
    }
  };
  var remainder = function (a, b) {
    if (!Caml_obj.caml_notequal(b, R.zero)) {
      return true;
    }
    var q = Curry._2(I.$pipe$slash$pipe, a, b);
    var r = Curry._2(I.$pipe$percent$pipe, a, b);
    if (Curry._2(E.eq, a, Curry._2(I.$pipe$plus$pipe, Curry._2(I.$pipe$star$pipe, q, b), r))) {
      if (Curry._2(E.eq, r, R.zero)) {
        return true;
      } else {
        return Curry._1(R.degree, r) < Curry._1(R.degree, b);
      }
    } else {
      return false;
    }
  };
  var submultiplicative = function (a, b) {
    return Curry._1(R.degree, a) <= Curry._1(R.degree, Curry._2(I.$pipe$star$pipe, a, b));
  };
  return {
          I: I,
          non_zero_ring: non_zero_ring,
          integral_domain: integral_domain,
          non_negative_degree: non_negative_degree,
          remainder: remainder,
          submultiplicative: submultiplicative
        };
}

function Field(F, E) {
  var non_zero_multiplicative_inverse = function (a, b) {
    return Curry._2(E.eq, Curry._2(F.modulo, a, b), F.zero);
  };
  return {
          non_zero_multiplicative_inverse: non_zero_multiplicative_inverse
        };
}

function Invariant(I, E) {
  var id = Bastet__Function.Category.id;
  var $less$dot = Bastet__Function.Infix.$less$dot;
  var identity = function (a) {
    return Curry._2(E.eq, Curry._3(I.imap, id, id, a), a);
  };
  var composition = function (f1, f2, g1, g2, a) {
    return Curry._2(E.eq, Curry._3($less$dot, Curry._2(I.imap, g1, g2), Curry._2(I.imap, f1, f2), a), Curry._3(I.imap, Curry._2($less$dot, g1, f1), Curry._2($less$dot, f2, g2), a));
  };
  return {
          id: id,
          $less$dot: $less$dot,
          identity: identity,
          composition: composition
        };
}

function Contravariant(C, E) {
  var id = Bastet__Function.Category.id;
  var $less$dot = Bastet__Function.Infix.$less$dot;
  var identity = function (a) {
    return Curry._2(E.eq, Curry._2(C.cmap, id, a), a);
  };
  var composition = function (f, g, a) {
    return Curry._2(E.eq, Curry._3($less$dot, Curry._1(C.cmap, f), Curry._1(C.cmap, g), a), Curry._2(C.cmap, Curry._2($less$dot, g, f), a));
  };
  return {
          id: id,
          $less$dot: $less$dot,
          identity: identity,
          composition: composition
        };
}

function Profunctor(P, E) {
  var id = Bastet__Function.Category.id;
  var $less$dot = Bastet__Function.Infix.$less$dot;
  var $great$dot = Bastet__Function.Infix.$great$dot;
  var identity = function (a) {
    return Curry._2(E.eq, Curry._3(P.dimap, id, id, a), a);
  };
  var composition = function (f1, g1, f2, g2, a) {
    return Curry._2(E.eq, Curry._3($less$dot, Curry._2(P.dimap, f2, g2), Curry._2(P.dimap, f1, g1), a), Curry._3(P.dimap, Curry._2($great$dot, f2, f1), Curry._2($less$dot, g2, g1), a));
  };
  return {
          id: id,
          $less$dot: $less$dot,
          $great$dot: $great$dot,
          identity: identity,
          composition: composition
        };
}

function Monad_Zero(M, E) {
  var annihalation = function (f) {
    return Curry._2(E.eq, Curry._2(M.flat_map, M.empty, f), M.empty);
  };
  return {
          annihalation: annihalation
        };
}

function Monad_Plus(M, E) {
  var distributivity = function (f, a, b) {
    return Curry._2(E.eq, Curry._2(M.flat_map, Curry._2(M.alt, a, b), f), Curry._2(M.alt, Curry._2(M.flat_map, a, f), Curry._2(M.flat_map, b, f)));
  };
  return {
          distributivity: distributivity
        };
}

function Extend(X, E) {
  var $less$dot = Bastet__Function.Infix.$less$dot;
  var associativity = function (f, g, a) {
    return Curry._2(E.eq, Curry._3($less$dot, Curry._1(X.extend, f), Curry._1(X.extend, g), a), Curry._2(X.extend, Curry._2($less$dot, f, Curry._1(X.extend, g)), a));
  };
  return {
          $less$dot: $less$dot,
          associativity: associativity
        };
}

function Comonad(C, E) {
  var identity = function (f, a) {
    if (Curry._2(E.eq, Curry._2(C.extend, C.extract, a), a)) {
      return Curry._2(E.eq, Curry._1(C.extract, Curry._2(C.extend, f, a)), Curry._1(f, a));
    } else {
      return false;
    }
  };
  return {
          identity: identity
        };
}

function Bifunctor(B, E) {
  var id = Bastet__Function.Category.id;
  var $less$dot = Bastet__Function.Infix.$less$dot;
  var identity = function (a) {
    return Curry._2(E.eq, Curry._3(B.bimap, id, id, a), a);
  };
  var composition = function (f1, g1, f2, g2, a) {
    return Curry._2(E.eq, Curry._3($less$dot, Curry._2(B.bimap, f1, g1), Curry._2(B.bimap, f2, g2), a), Curry._3(B.bimap, Curry._2($less$dot, f1, f2), Curry._2($less$dot, g1, g2), a));
  };
  return {
          id: id,
          $less$dot: $less$dot,
          identity: identity,
          composition: composition
        };
}

function Bicontravariant(B, E) {
  var id = Bastet__Function.Category.id;
  var $less$dot = Bastet__Function.Infix.$less$dot;
  var identity = function (a) {
    return Curry._2(E.eq, Curry._3(B.bicmap, id, id, a), a);
  };
  var composition = function (f1, g1, f2, g2, a) {
    return Curry._2(E.eq, Curry._3($less$dot, Curry._2(B.bicmap, f1, g1), Curry._2(B.bicmap, f2, g2), a), Curry._3(B.bicmap, Curry._2($less$dot, f2, f1), Curry._2($less$dot, g2, g1), a));
  };
  return {
          id: id,
          $less$dot: $less$dot,
          identity: identity,
          composition: composition
        };
}

var Compare = {
  Medial_Magma: Medial_Magma,
  Semigroup: Semigroup,
  Semigroup_Any: Semigroup_Any,
  Monoid: Monoid,
  Monoid_Any: Monoid_Any,
  Quasigroup: Quasigroup,
  Quasigroup_Any: Quasigroup_Any,
  Medial_Quasigroup: Medial_Quasigroup,
  Loop: Loop,
  Loop_Any: Loop_Any,
  Group: Group,
  Group_Any: Group_Any,
  Abelian_Group: Abelian_Group,
  Abelian_Group_Any: Abelian_Group_Any,
  Functor: Functor,
  Apply: Apply,
  Applicative: Applicative,
  Monad: Monad,
  Alt: Alt,
  Plus: Plus,
  Alternative: Alternative,
  Semigroupoid: Semigroupoid,
  Category: Category,
  Eq: Eq,
  Quasireflexive_Eq: Quasireflexive_Eq,
  Ord: Ord,
  Bounded: Bounded,
  Join_Semilattice: Join_Semilattice,
  Meet_Semilattice: Meet_Semilattice,
  Bounded_Join_Semilattice: Bounded_Join_Semilattice,
  Bounded_Meet_Semilattice: Bounded_Meet_Semilattice,
  Lattice: Lattice,
  Bounded_Lattice: Bounded_Lattice,
  Distributive_Lattice: Distributive_Lattice,
  Bounded_Distributive_Lattice: Bounded_Distributive_Lattice,
  Heyting_Algebra: Heyting_Algebra,
  Involutive_Heyting_Algebra: Involutive_Heyting_Algebra,
  Boolean_Algebra: Boolean_Algebra,
  Semiring: Semiring,
  Ring: Ring,
  Commutative_Ring: Commutative_Ring,
  Division_Ring: Division_Ring,
  Euclidean_Ring: Euclidean_Ring,
  Field: Field,
  Invariant: Invariant,
  Contravariant: Contravariant,
  Profunctor: Profunctor,
  Monad_Zero: Monad_Zero,
  Monad_Plus: Monad_Plus,
  Extend: Extend,
  Comonad: Comonad,
  Bifunctor: Bifunctor,
  Bicontravariant: Bicontravariant
};

function Medial_Magma$1(M) {
  var I = Bastet__Infix.Magma(M);
  var bicommutativity = function (a, b, c, d) {
    var prim0 = Curry._2(I.$less$colon$great, Curry._2(I.$less$colon$great, a, b), Curry._2(I.$less$colon$great, c, d));
    var prim1 = Curry._2(I.$less$colon$great, Curry._2(I.$less$colon$great, a, c), Curry._2(I.$less$colon$great, b, d));
    return Caml_obj.caml_equal(prim0, prim1);
  };
  return {
          I: I,
          bicommutativity: bicommutativity
        };
}

function Semigroup$1(S) {
  var I = Bastet__Infix.Magma(S);
  var associativity = function (a, b, c) {
    var prim0 = Curry._2(I.$less$colon$great, a, Curry._2(I.$less$colon$great, b, c));
    var prim1 = Curry._2(I.$less$colon$great, a, Curry._2(I.$less$colon$great, b, c));
    return Caml_obj.caml_equal(prim0, prim1);
  };
  return {
          I: I,
          associativity: associativity
        };
}

function Semigroup_Any$1(S) {
  var I = Bastet__Infix.Magma_Any(S);
  var associativity = function (a, b, c) {
    var prim0 = Curry._2(I.$less$colon$great, a, Curry._2(I.$less$colon$great, b, c));
    var prim1 = Curry._2(I.$less$colon$great, a, Curry._2(I.$less$colon$great, b, c));
    return Caml_obj.caml_equal(prim0, prim1);
  };
  return {
          I: I,
          associativity: associativity
        };
}

function Monoid$1(M) {
  var eq = Caml_obj.caml_equal;
  var I = Bastet__Infix.Magma(M);
  var identity = function (a) {
    if (eq(Curry._2(I.$less$colon$great, a, M.empty), a)) {
      return eq(Curry._2(I.$less$colon$great, M.empty, a), a);
    } else {
      return false;
    }
  };
  return {
          I: I,
          identity: identity
        };
}

function Monoid_Any$1(M) {
  var eq = Caml_obj.caml_equal;
  var I = Bastet__Infix.Magma_Any(M);
  var identity = function (a) {
    if (eq(Curry._2(I.$less$colon$great, a, M.empty), a)) {
      return eq(Curry._2(I.$less$colon$great, M.empty, a), a);
    } else {
      return false;
    }
  };
  return {
          I: I,
          identity: identity
        };
}

function Quasigroup$1(Q) {
  var eq = Caml_obj.caml_equal;
  var I = Bastet__Infix.Magma(Q);
  var cancellative = function (a, b, c) {
    if (!eq(Curry._2(I.$less$colon$great, a, b), Curry._2(I.$less$colon$great, a, c)) || eq(b, c)) {
      if (eq(Curry._2(I.$less$colon$great, b, a), Curry._2(I.$less$colon$great, c, a))) {
        return eq(b, c);
      } else {
        return true;
      }
    } else {
      return false;
    }
  };
  return {
          I: I,
          cancellative: cancellative
        };
}

function Quasigroup_Any$1(Q) {
  var eq = Caml_obj.caml_equal;
  var I = Bastet__Infix.Magma_Any(Q);
  var cancellative = function (a, b, c) {
    if (!eq(Curry._2(I.$less$colon$great, a, b), Curry._2(I.$less$colon$great, a, c)) || eq(b, c)) {
      if (eq(Curry._2(I.$less$colon$great, b, a), Curry._2(I.$less$colon$great, c, a))) {
        return eq(b, c);
      } else {
        return true;
      }
    } else {
      return false;
    }
  };
  return {
          I: I,
          cancellative: cancellative
        };
}

function Medial_Quasigroup$1(Q) {
  var eq = Caml_obj.caml_equal;
  var I = Bastet__Infix.Magma(Q);
  var cancellative = function (a, b, c) {
    if (!eq(Curry._2(I.$less$colon$great, a, b), Curry._2(I.$less$colon$great, a, c)) || eq(b, c)) {
      if (eq(Curry._2(I.$less$colon$great, b, a), Curry._2(I.$less$colon$great, c, a))) {
        return eq(b, c);
      } else {
        return true;
      }
    } else {
      return false;
    }
  };
  return {
          I: I,
          cancellative: cancellative
        };
}

function Loop$1(L) {
  var eq = Caml_obj.caml_equal;
  var I = Bastet__Infix.Magma(L);
  var identity = function (a) {
    if (eq(Curry._2(I.$less$colon$great, a, L.empty), a)) {
      return eq(Curry._2(I.$less$colon$great, L.empty, a), a);
    } else {
      return false;
    }
  };
  return {
          I: I,
          identity: identity
        };
}

function Loop_Any$1(L) {
  var eq = Caml_obj.caml_equal;
  var I = Bastet__Infix.Magma_Any(L);
  var identity = function (a) {
    if (eq(Curry._2(I.$less$colon$great, a, L.empty), a)) {
      return eq(Curry._2(I.$less$colon$great, L.empty, a), a);
    } else {
      return false;
    }
  };
  return {
          I: I,
          identity: identity
        };
}

function Group$1(G) {
  var eq = Caml_obj.caml_equal;
  var I = Bastet__Infix.Magma(G);
  var invertibility = function (a) {
    if (eq(Curry._2(I.$less$colon$great, Curry._1(G.inverse, a), a), G.empty)) {
      return eq(Curry._2(I.$less$colon$great, a, Curry._1(G.inverse, a)), G.empty);
    } else {
      return false;
    }
  };
  var associativity = function (a, b, c) {
    return eq(Curry._2(I.$less$colon$great, a, Curry._2(I.$less$colon$great, b, c)), Curry._2(I.$less$colon$great, a, Curry._2(I.$less$colon$great, b, c)));
  };
  return {
          I: I,
          invertibility: invertibility,
          associativity: associativity
        };
}

function Group_Any$1(G) {
  var eq = Caml_obj.caml_equal;
  var I = Bastet__Infix.Magma_Any(G);
  var invertibility = function (a) {
    if (eq(Curry._2(I.$less$colon$great, Curry._1(G.inverse, a), a), G.empty)) {
      return eq(Curry._2(I.$less$colon$great, a, Curry._1(G.inverse, a)), G.empty);
    } else {
      return false;
    }
  };
  var associativity = function (a, b, c) {
    return eq(Curry._2(I.$less$colon$great, a, Curry._2(I.$less$colon$great, b, c)), Curry._2(I.$less$colon$great, a, Curry._2(I.$less$colon$great, b, c)));
  };
  return {
          I: I,
          invertibility: invertibility,
          associativity: associativity
        };
}

function Abelian_Group$1(A) {
  var commutativity = function (a, b) {
    var prim0 = Curry._2(A.append, a, b);
    var prim1 = Curry._2(A.append, b, a);
    return Caml_obj.caml_equal(prim0, prim1);
  };
  return {
          commutativity: commutativity
        };
}

function Abelian_Group_Any$1(A) {
  var commutativity = function (a, b) {
    var prim0 = Curry._2(A.append, a, b);
    var prim1 = Curry._2(A.append, b, a);
    return Caml_obj.caml_equal(prim0, prim1);
  };
  return {
          commutativity: commutativity
        };
}

function Functor$1(F) {
  var eq = Caml_obj.caml_equal;
  var $less$dot = Bastet__Function.Infix.$less$dot;
  var identity = function (a) {
    return eq(Curry._2(F.map, Bastet__Function.Category.id, a), a);
  };
  var composition = function (f, g, a) {
    return eq(Curry._2(F.map, Curry._2($less$dot, f, g), a), Curry._3($less$dot, Curry._1(F.map, f), Curry._1(F.map, g), a));
  };
  return {
          $less$dot: $less$dot,
          identity: identity,
          composition: composition
        };
}

function Apply$1(A) {
  var I = Bastet__Infix.Apply(A);
  var associative_composition = function (f, g, h) {
    var prim0 = Curry._2(I.$less$star$great, Curry._2(I.$less$star$great, Curry._2(A.map, Bastet__Function.Semigroupoid.compose, f), g), h);
    var prim1 = Curry._2(I.$less$star$great, f, Curry._2(I.$less$star$great, g, h));
    return Caml_obj.caml_equal(prim0, prim1);
  };
  return {
          I: I,
          associative_composition: associative_composition
        };
}

function Applicative$1(A) {
  var eq = Caml_obj.caml_equal;
  var I = Bastet__Infix.Apply(A);
  var identity = function (a) {
    return eq(Curry._2(I.$less$star$great, Curry._1(A.pure, Bastet__Function.Category.id), a), a);
  };
  var homomorphism = function (f, x) {
    return eq(Curry._2(I.$less$star$great, Curry._1(A.pure, f), Curry._1(A.pure, x)), Curry._1(A.pure, Curry._1(f, x)));
  };
  var interchange = function (f, x) {
    return eq(Curry._2(I.$less$star$great, f, Curry._1(A.pure, x)), Curry._2(I.$less$star$great, Curry._1(A.pure, (function (f$p) {
                          return Curry._1(f$p, x);
                        })), f));
  };
  return {
          I: I,
          identity: identity,
          homomorphism: homomorphism,
          interchange: interchange
        };
}

function Monad$1(M) {
  var eq = Caml_obj.caml_equal;
  var I = Bastet__Infix.Monad(M);
  var associativity = function (f, g, x) {
    return eq(Curry._2(I.$great$great$eq, Curry._2(I.$great$great$eq, x, f), g), Curry._2(I.$great$great$eq, x, (function (k) {
                      return Curry._2(I.$great$great$eq, Curry._1(f, k), g);
                    })));
  };
  var identity = function (f, x) {
    if (eq(Curry._2(I.$great$great$eq, Curry._1(M.pure, x), f), Curry._1(f, x))) {
      return eq(Curry._2(I.$great$great$eq, Curry._1(M.pure, x), M.pure), Curry._1(M.pure, x));
    } else {
      return false;
    }
  };
  return {
          I: I,
          associativity: associativity,
          identity: identity
        };
}

function Alt$1(A) {
  var eq = Caml_obj.caml_equal;
  var I = Bastet__Infix.Alt(A);
  var associativity = function (a, b, c) {
    return eq(Curry._2(I.$less$pipe$great, a, Curry._2(I.$less$pipe$great, b, c)), Curry._2(I.$less$pipe$great, a, Curry._2(I.$less$pipe$great, b, c)));
  };
  var distributivity = function (f, a, b) {
    return eq(Curry._2(A.map, f, Curry._2(I.$less$pipe$great, a, b)), Curry._2(I.$less$pipe$great, Curry._2(A.map, f, a), Curry._2(A.map, f, b)));
  };
  return {
          I: I,
          associativity: associativity,
          distributivity: distributivity
        };
}

function Plus$1(P) {
  var eq = Caml_obj.caml_equal;
  var I = Bastet__Infix.Alt(P);
  var annihalation = function (f) {
    return eq(Curry._2(P.map, f, P.empty), P.empty);
  };
  var identity = function (a) {
    if (eq(Curry._2(I.$less$pipe$great, P.empty, a), a)) {
      return eq(Curry._2(I.$less$pipe$great, a, P.empty), a);
    } else {
      return false;
    }
  };
  return {
          I: I,
          annihalation: annihalation,
          identity: identity
        };
}

function Alternative$1(A) {
  var eq = Caml_obj.caml_equal;
  var I = Bastet__Infix.Alternative(A);
  var distributivity = function (f, g, x) {
    return eq(Curry._2(I.$less$star$great, Curry._2(I.$less$pipe$great, f, g), x), Curry._2(I.$less$pipe$great, Curry._2(I.$less$star$great, f, x), Curry._2(I.$less$star$great, g, x)));
  };
  var annihalation = function (f) {
    return eq(Curry._2(I.$less$star$great, A.empty, f), A.empty);
  };
  return {
          I: I,
          distributivity: distributivity,
          annihalation: annihalation
        };
}

function Semigroupoid$1(S) {
  var I = Bastet__Infix.Semigroupoid(S);
  var associativity = function (a, b, c) {
    var prim0 = Curry._2(I.$less$dot, Curry._2(I.$less$dot, a, b), c);
    var prim1 = Curry._2(I.$less$dot, a, Curry._2(I.$less$dot, b, c));
    return Caml_obj.caml_equal(prim0, prim1);
  };
  return {
          I: I,
          associativity: associativity
        };
}

function Category$1(C) {
  var eq = Caml_obj.caml_equal;
  var I = Bastet__Infix.Semigroupoid(C);
  var identity = function (a) {
    if (eq(Curry._2(I.$less$dot, C.id, a), a)) {
      return eq(Curry._2(I.$less$dot, a, C.id), a);
    } else {
      return false;
    }
  };
  return {
          I: I,
          identity: identity
        };
}

function Eq$1(E) {
  var I = Bastet__Infix.Eq(E);
  var reflexivity = function (a) {
    return Curry._2(I.$eq$pipe$eq, a, a);
  };
  var symmetry = function (a, b) {
    return Curry._2(I.$eq$pipe$eq, a, b) === Curry._2(I.$eq$pipe$eq, b, a);
  };
  var transitivity = function (a, b, c) {
    if (Curry._2(I.$eq$pipe$eq, a, b) && Curry._2(I.$eq$pipe$eq, b, c)) {
      return Curry._2(I.$eq$pipe$eq, a, c);
    } else {
      return true;
    }
  };
  return {
          I: I,
          reflexivity: reflexivity,
          symmetry: symmetry,
          transitivity: transitivity
        };
}

function Ord$1(E) {
  var Ordering_Functions = Bastet__Infix.Ord(E);
  var $less$pipe$eq = Ordering_Functions.$less$pipe$eq;
  var reflexivity = function (a) {
    return Curry._2($less$pipe$eq, a, a);
  };
  var antisymmetry = function (a, b) {
    if (Curry._2($less$pipe$eq, a, b) && Curry._2($less$pipe$eq, b, a)) {
      return Caml_obj.caml_equal(a, b);
    } else {
      return true;
    }
  };
  var transitivity = function (a, b, c) {
    if (Curry._2($less$pipe$eq, a, b) && Curry._2($less$pipe$eq, b, c)) {
      return Curry._2($less$pipe$eq, a, c);
    } else {
      return true;
    }
  };
  return {
          Ordering_Functions: Ordering_Functions,
          $less$pipe$eq: $less$pipe$eq,
          $great$pipe$eq: Ordering_Functions.$great$pipe$eq,
          reflexivity: reflexivity,
          antisymmetry: antisymmetry,
          transitivity: transitivity
        };
}

function Bounded$1(B) {
  var Ordering_Functions = Bastet__Infix.Ord(B);
  var $less$pipe$eq = Ordering_Functions.$less$pipe$eq;
  var bounded = function (a) {
    if (Curry._2($less$pipe$eq, B.bottom, a)) {
      return Curry._2($less$pipe$eq, a, B.top);
    } else {
      return false;
    }
  };
  return {
          Ordering_Functions: Ordering_Functions,
          $less$pipe$eq: $less$pipe$eq,
          bounded: bounded
        };
}

function Join_Semilattice$1(J) {
  var eq = Caml_obj.caml_equal;
  var associativity = function (a, b, c) {
    return eq(Curry._2(J.join, a, Curry._2(J.join, b, c)), Curry._2(J.join, Curry._2(J.join, a, b), c));
  };
  var commutativity = function (a, b) {
    return eq(Curry._2(J.join, a, b), Curry._2(J.join, b, a));
  };
  var idempotency = function (a) {
    return eq(Curry._2(J.join, a, a), a);
  };
  return {
          associativity: associativity,
          commutativity: commutativity,
          idempotency: idempotency
        };
}

function Meet_Semilattice$1(M) {
  var eq = Caml_obj.caml_equal;
  var associativity = function (a, b, c) {
    return eq(Curry._2(M.meet, a, Curry._2(M.meet, b, c)), Curry._2(M.meet, Curry._2(M.meet, a, b), c));
  };
  var commutativity = function (a, b) {
    return eq(Curry._2(M.meet, a, b), Curry._2(M.meet, b, a));
  };
  var idempotency = function (a) {
    return eq(Curry._2(M.meet, a, a), a);
  };
  return {
          associativity: associativity,
          commutativity: commutativity,
          idempotency: idempotency
        };
}

function Bounded_Join_Semilattice$1(J) {
  var identity = function (a) {
    return Caml_obj.caml_equal(Curry._2(J.join, a, J.bottom), a);
  };
  return {
          identity: identity
        };
}

function Bounded_Meet_Semilattice$1(M) {
  var identity = function (a) {
    return Caml_obj.caml_equal(Curry._2(M.meet, a, M.top), a);
  };
  return {
          identity: identity
        };
}

function Lattice$1(L) {
  var eq = Caml_obj.caml_equal;
  var absorption = function (a, b) {
    if (eq(Curry._2(L.meet, a, Curry._2(L.join, a, b)), a)) {
      return eq(Curry._2(L.join, a, Curry._2(L.meet, a, b)), a);
    } else {
      return false;
    }
  };
  return {
          absorption: absorption
        };
}

function Bounded_Lattice$1(L) {
  var absorption = function (a, b) {
    if (Caml_obj.caml_equal(Curry._2(L.meet, a, Curry._2(L.join, a, b)), a)) {
      var prim0 = Curry._2(L.join, a, Curry._2(L.meet, a, b));
      return Caml_obj.caml_equal(prim0, a);
    } else {
      return false;
    }
  };
  return {
          absorption: absorption
        };
}

function Distributive_Lattice$1(L) {
  var distributivity = function (a, b, c) {
    var prim0 = Curry._2(L.meet, a, Curry._2(L.join, b, c));
    var prim1 = Curry._2(L.join, Curry._2(L.meet, a, b), Curry._2(L.meet, a, c));
    return Caml_obj.caml_equal(prim0, prim1);
  };
  return {
          distributivity: distributivity
        };
}

function Bounded_Distributive_Lattice$1(L) {
  var distributivity = function (a, b, c) {
    var prim0 = Curry._2(L.meet, a, Curry._2(L.join, b, c));
    var prim1 = Curry._2(L.join, Curry._2(L.meet, a, b), Curry._2(L.meet, a, c));
    return Caml_obj.caml_equal(prim0, prim1);
  };
  return {
          distributivity: distributivity
        };
}

function Heyting_Algebra$1(H) {
  var O = Bastet__Infix.Ord(H);
  var $less$pipe$eq = O.$less$pipe$eq;
  var pseudocomplement = function (a) {
    var prim0 = Curry._1(H.not, a);
    var prim1 = Curry._2(H.implies, a, H.bottom);
    return Caml_obj.caml_equal(prim0, prim1);
  };
  var relative_pseudocomplement = function (a, b, c) {
    return Curry._2($less$pipe$eq, Curry._2(H.meet, c, a), b) === Curry._2($less$pipe$eq, c, Curry._2(H.implies, a, b));
  };
  return {
          O: O,
          $less$pipe$eq: $less$pipe$eq,
          pseudocomplement: pseudocomplement,
          relative_pseudocomplement: relative_pseudocomplement
        };
}

function Involutive_Heyting_Algebra$1(H) {
  var involution = function (a) {
    var prim0 = Curry._1(H.not, Curry._1(H.not, a));
    return Caml_obj.caml_equal(prim0, a);
  };
  return {
          involution: involution
        };
}

function Boolean_Algebra$1(B) {
  var excluded_middle = function (a) {
    var prim0 = Curry._2(B.join, a, Curry._1(B.not, a));
    var prim1 = B.top;
    return Caml_obj.caml_equal(prim0, prim1);
  };
  return {
          excluded_middle: excluded_middle
        };
}

function Semiring$1(S) {
  var eq = Caml_obj.caml_equal;
  var I = Bastet__Infix.Semiring(S);
  var additive_associativity = function (a, b, c) {
    return eq(Curry._2(I.$pipe$plus$pipe, Curry._2(I.$pipe$plus$pipe, a, b), c), Curry._2(I.$pipe$plus$pipe, a, Curry._2(I.$pipe$plus$pipe, b, c)));
  };
  var additive_identity = function (a) {
    return eq(Curry._2(I.$pipe$plus$pipe, S.zero, a), a);
  };
  var commutativity = function (a, b) {
    return eq(Curry._2(I.$pipe$plus$pipe, a, b), Curry._2(I.$pipe$plus$pipe, b, a));
  };
  var multiplicative_associativity = function (a, b, c) {
    return eq(Curry._2(I.$pipe$star$pipe, Curry._2(I.$pipe$star$pipe, a, b), c), Curry._2(I.$pipe$star$pipe, a, Curry._2(I.$pipe$star$pipe, b, c)));
  };
  var multiplicative_identity = function (a) {
    return eq(Curry._2(I.$pipe$star$pipe, S.one, a), a);
  };
  var distributivity = function (a, b, c) {
    if (eq(Curry._2(I.$pipe$star$pipe, a, Curry._2(I.$pipe$plus$pipe, b, c)), Curry._2(I.$pipe$plus$pipe, Curry._2(I.$pipe$star$pipe, a, b), Curry._2(I.$pipe$star$pipe, a, c)))) {
      return eq(Curry._2(I.$pipe$star$pipe, Curry._2(I.$pipe$plus$pipe, a, b), c), Curry._2(I.$pipe$plus$pipe, Curry._2(I.$pipe$star$pipe, a, c), Curry._2(I.$pipe$star$pipe, b, c)));
    } else {
      return false;
    }
  };
  return {
          I: I,
          additive_associativity: additive_associativity,
          additive_identity: additive_identity,
          commutativity: commutativity,
          multiplicative_associativity: multiplicative_associativity,
          multiplicative_identity: multiplicative_identity,
          distributivity: distributivity
        };
}

function Ring$1(R) {
  var I = Bastet__Infix.Ring(R);
  var additive_inverse = function (a) {
    var prim0 = Curry._2(I.$pipe$plus$pipe, Curry._2(I.$pipe$neg$pipe, R.zero, a), a);
    var prim1 = R.zero;
    return Caml_obj.caml_equal(prim0, prim1);
  };
  return {
          I: I,
          additive_inverse: additive_inverse
        };
}

function Commutative_Ring$1(R) {
  var I = Bastet__Infix.Ring(R);
  var multiplicative_commutativity = function (a, b) {
    var prim0 = Curry._2(I.$pipe$star$pipe, a, b);
    var prim1 = Curry._2(I.$pipe$star$pipe, b, a);
    return Caml_obj.caml_equal(prim0, prim1);
  };
  return {
          I: I,
          multiplicative_commutativity: multiplicative_commutativity
        };
}

function Division_Ring$1(R) {
  var eq = Caml_obj.caml_equal;
  var I = Bastet__Infix.Ring(R);
  var non_zero_ring = !eq(R.zero, R.one);
  var multiplicative_inverse = function (a) {
    return eq(Curry._2(I.$pipe$star$pipe, Curry._1(R.reciprocal, a), a), R.one);
  };
  return {
          I: I,
          non_zero_ring: non_zero_ring,
          multiplicative_inverse: multiplicative_inverse
        };
}

function Euclidean_Ring$1(R) {
  var eq = Caml_obj.caml_equal;
  var I = Bastet__Infix.Euclidean_Ring(R);
  var non_zero_ring = !eq(R.zero, R.one);
  var integral_domain = function (a, b) {
    if (!eq(a, R.zero) && Caml_obj.caml_notequal(b, R.zero)) {
      return !eq(Curry._2(I.$pipe$star$pipe, a, b), R.zero);
    } else {
      return true;
    }
  };
  var non_negative_degree = function (a) {
    if (eq(a, R.zero)) {
      return true;
    } else {
      return Curry._1(R.degree, a) >= 0;
    }
  };
  var remainder = function (a, b) {
    if (!Caml_obj.caml_notequal(b, R.zero)) {
      return true;
    }
    var q = Curry._2(I.$pipe$slash$pipe, a, b);
    var r = Curry._2(I.$pipe$percent$pipe, a, b);
    if (eq(a, Curry._2(I.$pipe$plus$pipe, Curry._2(I.$pipe$star$pipe, q, b), r))) {
      if (eq(r, R.zero)) {
        return true;
      } else {
        return Curry._1(R.degree, r) < Curry._1(R.degree, b);
      }
    } else {
      return false;
    }
  };
  var submultiplicative = function (a, b) {
    return Curry._1(R.degree, a) <= Curry._1(R.degree, Curry._2(I.$pipe$star$pipe, a, b));
  };
  return {
          I: I,
          non_zero_ring: non_zero_ring,
          integral_domain: integral_domain,
          non_negative_degree: non_negative_degree,
          remainder: remainder,
          submultiplicative: submultiplicative
        };
}

function Field$1(F) {
  var non_zero_multiplicative_inverse = function (a, b) {
    var prim0 = Curry._2(F.modulo, a, b);
    var prim1 = F.zero;
    return Caml_obj.caml_equal(prim0, prim1);
  };
  return {
          non_zero_multiplicative_inverse: non_zero_multiplicative_inverse
        };
}

function Invariant$1(I) {
  var eq = Caml_obj.caml_equal;
  var id = Bastet__Function.Category.id;
  var $less$dot = Bastet__Function.Infix.$less$dot;
  var identity = function (a) {
    return eq(Curry._3(I.imap, id, id, a), a);
  };
  var composition = function (f1, f2, g1, g2, a) {
    return eq(Curry._3($less$dot, Curry._2(I.imap, g1, g2), Curry._2(I.imap, f1, f2), a), Curry._3(I.imap, Curry._2($less$dot, g1, f1), Curry._2($less$dot, f2, g2), a));
  };
  return {
          id: id,
          $less$dot: $less$dot,
          identity: identity,
          composition: composition
        };
}

function Contravariant$1(C) {
  var eq = Caml_obj.caml_equal;
  var id = Bastet__Function.Category.id;
  var $less$dot = Bastet__Function.Infix.$less$dot;
  var identity = function (a) {
    return eq(Curry._2(C.cmap, id, a), a);
  };
  var composition = function (f, g, a) {
    return eq(Curry._3($less$dot, Curry._1(C.cmap, f), Curry._1(C.cmap, g), a), Curry._2(C.cmap, Curry._2($less$dot, g, f), a));
  };
  return {
          id: id,
          $less$dot: $less$dot,
          identity: identity,
          composition: composition
        };
}

function Profunctor$1(P) {
  var eq = Caml_obj.caml_equal;
  var id = Bastet__Function.Category.id;
  var $less$dot = Bastet__Function.Infix.$less$dot;
  var $great$dot = Bastet__Function.Infix.$great$dot;
  var identity = function (a) {
    return eq(Curry._3(P.dimap, id, id, a), a);
  };
  var composition = function (f1, g1, f2, g2, a) {
    return eq(Curry._3($less$dot, Curry._2(P.dimap, f2, g2), Curry._2(P.dimap, f1, g1), a), Curry._3(P.dimap, Curry._2($great$dot, f2, f1), Curry._2($less$dot, g2, g1), a));
  };
  return {
          id: id,
          $less$dot: $less$dot,
          $great$dot: $great$dot,
          identity: identity,
          composition: composition
        };
}

function Monad_Zero$1(M) {
  var annihalation = function (f) {
    var prim0 = Curry._2(M.flat_map, M.empty, f);
    var prim1 = M.empty;
    return Caml_obj.caml_equal(prim0, prim1);
  };
  return {
          annihalation: annihalation
        };
}

function Monad_Plus$1(M) {
  var distributivity = function (f, a, b) {
    var prim0 = Curry._2(M.flat_map, Curry._2(M.alt, a, b), f);
    var prim1 = Curry._2(M.alt, Curry._2(M.flat_map, a, f), Curry._2(M.flat_map, b, f));
    return Caml_obj.caml_equal(prim0, prim1);
  };
  return {
          distributivity: distributivity
        };
}

function Extend$1(E) {
  var $less$dot = Bastet__Function.Infix.$less$dot;
  var associativity = function (f, g, a) {
    var prim0 = Curry._3($less$dot, Curry._1(E.extend, f), Curry._1(E.extend, g), a);
    var prim1 = Curry._2(E.extend, Curry._2($less$dot, f, Curry._1(E.extend, g)), a);
    return Caml_obj.caml_equal(prim0, prim1);
  };
  return {
          $less$dot: $less$dot,
          associativity: associativity
        };
}

function Comonad$1(C) {
  var eq = Caml_obj.caml_equal;
  var identity = function (f, a) {
    if (eq(Curry._2(C.extend, C.extract, a), a)) {
      return eq(Curry._1(C.extract, Curry._2(C.extend, f, a)), Curry._1(f, a));
    } else {
      return false;
    }
  };
  return {
          identity: identity
        };
}

function Bifunctor$1(B) {
  var eq = Caml_obj.caml_equal;
  var id = Bastet__Function.Category.id;
  var $less$dot = Bastet__Function.Infix.$less$dot;
  var identity = function (a) {
    return eq(Curry._3(B.bimap, id, id, a), a);
  };
  var composition = function (f1, g1, f2, g2, a) {
    return eq(Curry._3($less$dot, Curry._2(B.bimap, f1, g1), Curry._2(B.bimap, f2, g2), a), Curry._3(B.bimap, Curry._2($less$dot, f1, f2), Curry._2($less$dot, g1, g2), a));
  };
  return {
          id: id,
          $less$dot: $less$dot,
          identity: identity,
          composition: composition
        };
}

function Bicontravariant$1(B) {
  var eq = Caml_obj.caml_equal;
  var id = Bastet__Function.Category.id;
  var $less$dot = Bastet__Function.Infix.$less$dot;
  var identity = function (a) {
    return eq(Curry._3(B.bicmap, id, id, a), a);
  };
  var composition = function (f1, g1, f2, g2, a) {
    return eq(Curry._3($less$dot, Curry._2(B.bicmap, f1, g1), Curry._2(B.bicmap, f2, g2), a), Curry._3(B.bicmap, Curry._2($less$dot, f2, f1), Curry._2($less$dot, g2, g1), a));
  };
  return {
          id: id,
          $less$dot: $less$dot,
          identity: identity,
          composition: composition
        };
}

exports.Compare = Compare;
exports.Medial_Magma = Medial_Magma$1;
exports.Semigroup = Semigroup$1;
exports.Semigroup_Any = Semigroup_Any$1;
exports.Monoid = Monoid$1;
exports.Monoid_Any = Monoid_Any$1;
exports.Quasigroup = Quasigroup$1;
exports.Quasigroup_Any = Quasigroup_Any$1;
exports.Medial_Quasigroup = Medial_Quasigroup$1;
exports.Loop = Loop$1;
exports.Loop_Any = Loop_Any$1;
exports.Group = Group$1;
exports.Group_Any = Group_Any$1;
exports.Abelian_Group = Abelian_Group$1;
exports.Abelian_Group_Any = Abelian_Group_Any$1;
exports.Functor = Functor$1;
exports.Apply = Apply$1;
exports.Applicative = Applicative$1;
exports.Monad = Monad$1;
exports.Alt = Alt$1;
exports.Plus = Plus$1;
exports.Alternative = Alternative$1;
exports.Semigroupoid = Semigroupoid$1;
exports.Category = Category$1;
exports.Eq = Eq$1;
exports.Ord = Ord$1;
exports.Bounded = Bounded$1;
exports.Join_Semilattice = Join_Semilattice$1;
exports.Meet_Semilattice = Meet_Semilattice$1;
exports.Bounded_Join_Semilattice = Bounded_Join_Semilattice$1;
exports.Bounded_Meet_Semilattice = Bounded_Meet_Semilattice$1;
exports.Lattice = Lattice$1;
exports.Bounded_Lattice = Bounded_Lattice$1;
exports.Distributive_Lattice = Distributive_Lattice$1;
exports.Bounded_Distributive_Lattice = Bounded_Distributive_Lattice$1;
exports.Heyting_Algebra = Heyting_Algebra$1;
exports.Involutive_Heyting_Algebra = Involutive_Heyting_Algebra$1;
exports.Boolean_Algebra = Boolean_Algebra$1;
exports.Semiring = Semiring$1;
exports.Ring = Ring$1;
exports.Commutative_Ring = Commutative_Ring$1;
exports.Division_Ring = Division_Ring$1;
exports.Euclidean_Ring = Euclidean_Ring$1;
exports.Field = Field$1;
exports.Invariant = Invariant$1;
exports.Contravariant = Contravariant$1;
exports.Profunctor = Profunctor$1;
exports.Monad_Zero = Monad_Zero$1;
exports.Monad_Plus = Monad_Plus$1;
exports.Extend = Extend$1;
exports.Comonad = Comonad$1;
exports.Bifunctor = Bifunctor$1;
exports.Bicontravariant = Bicontravariant$1;
/* Bastet__Function Not a pure module */
