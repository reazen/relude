// Generated by Melange
'use strict';

var Curry = require("melange.runtime/curry.js");
var Caml_option = require("melange.runtime/caml_option.js");
var Bastet__Infix = require("./Infix.js");
var Bastet__Function = require("./Function.js");

var $less$dot = Bastet__Function.Infix.$less$dot;

function maybe(f, $$default, opt) {
  if (opt !== undefined) {
    return Curry._1(f, Caml_option.valFromOption(opt));
  } else {
    return $$default;
  }
}

function getWithDefault(a, x) {
  if (x !== undefined) {
    return Caml_option.valFromOption(x);
  } else {
    return a;
  }
}

function map(f, a) {
  if (a !== undefined) {
    return Caml_option.some(Curry._1(f, Caml_option.valFromOption(a)));
  }
  
}

var Functor = {
  map: map
};

function apply(fn_opt, a) {
  if (fn_opt !== undefined) {
    return map(fn_opt, a);
  }
  
}

var Apply = {
  map: map,
  apply: apply
};

function pure(a) {
  return Caml_option.some(a);
}

var Applicative = {
  map: map,
  apply: apply,
  pure: pure
};

function flat_map(x, f) {
  if (x !== undefined) {
    return Curry._1(f, Caml_option.valFromOption(x));
  }
  
}

var Monad = {
  map: map,
  apply: apply,
  pure: pure,
  flat_map: flat_map
};

function Magma(M) {
  var append = function (a, b) {
    if (a === undefined) {
      if (b !== undefined) {
        return Caml_option.some(Caml_option.valFromOption(b));
      } else {
        return ;
      }
    }
    var a$1 = Caml_option.valFromOption(a);
    if (b !== undefined) {
      return Caml_option.some(Curry._2(M.append, a$1, Caml_option.valFromOption(b)));
    } else {
      return Caml_option.some(a$1);
    }
  };
  return {
          append: append
        };
}

function Semigroup(S) {
  var append = function (a, b) {
    if (a === undefined) {
      if (b !== undefined) {
        return Caml_option.some(Caml_option.valFromOption(b));
      } else {
        return ;
      }
    }
    var a$1 = Caml_option.valFromOption(a);
    if (b !== undefined) {
      return Caml_option.some(Curry._2(S.append, a$1, Caml_option.valFromOption(b)));
    } else {
      return Caml_option.some(a$1);
    }
  };
  return {
          append: append
        };
}

function Monoid(S) {
  var append = function (a, b) {
    if (a === undefined) {
      if (b !== undefined) {
        return Caml_option.some(Caml_option.valFromOption(b));
      } else {
        return ;
      }
    }
    var a$1 = Caml_option.valFromOption(a);
    if (b !== undefined) {
      return Caml_option.some(Curry._2(S.append, a$1, Caml_option.valFromOption(b)));
    } else {
      return Caml_option.some(a$1);
    }
  };
  return {
          append: append,
          empty: undefined
        };
}

function Quasigroup(Q) {
  var append = function (a, b) {
    if (a === undefined) {
      if (b !== undefined) {
        return Caml_option.some(Caml_option.valFromOption(b));
      } else {
        return ;
      }
    }
    var a$1 = Caml_option.valFromOption(a);
    if (b !== undefined) {
      return Caml_option.some(Curry._2(Q.append, a$1, Caml_option.valFromOption(b)));
    } else {
      return Caml_option.some(a$1);
    }
  };
  return {
          append: append
        };
}

function Loop(L) {
  var append = function (a, b) {
    if (a === undefined) {
      if (b !== undefined) {
        return Caml_option.some(Caml_option.valFromOption(b));
      } else {
        return ;
      }
    }
    var a$1 = Caml_option.valFromOption(a);
    if (b !== undefined) {
      return Caml_option.some(Curry._2(L.append, a$1, Caml_option.valFromOption(b)));
    } else {
      return Caml_option.some(a$1);
    }
  };
  return {
          append: append,
          empty: undefined
        };
}

function alt(a, b) {
  if (a !== undefined) {
    return Caml_option.some(Caml_option.valFromOption(a));
  } else {
    return b;
  }
}

var Alt = {
  map: map,
  alt: alt
};

var Plus = {
  map: map,
  alt: alt,
  empty: undefined
};

var Alternative = {
  apply: apply,
  pure: pure,
  map: map,
  alt: alt,
  empty: undefined
};

function fold_left(f, init, x) {
  return maybe(Curry._1(f, init), init, x);
}

function fold_right(f, init, x) {
  return maybe((function (x$p) {
                return Curry._2(f, x$p, init);
              }), init, x);
}

function Fold_Map(M) {
  var fold_map = function (f, x) {
    return maybe(f, M.empty, x);
  };
  return {
          fold_map: fold_map
        };
}

function Fold_Map_Any(M) {
  var fold_map = function (f, x) {
    return maybe(f, M.empty, x);
  };
  return {
          fold_map: fold_map
        };
}

function Fold_Map_Plus(P) {
  var fold_map = function (f, x) {
    return maybe(f, P.empty, x);
  };
  return {
          fold_map: fold_map
        };
}

var Foldable = {
  fold_left: fold_left,
  fold_right: fold_right,
  Fold_Map: Fold_Map,
  Fold_Map_Any: Fold_Map_Any,
  Fold_Map_Plus: Fold_Map_Plus
};

function Traversable(A) {
  var traverse = function (f, x) {
    return maybe(Curry._2($less$dot, Curry._1(A.map, (function (a) {
                          return Caml_option.some(a);
                        })), f), Curry._1(A.pure, undefined), x);
  };
  var sequence = function (x) {
    return maybe(Curry._1(A.map, (function (a) {
                      return Caml_option.some(a);
                    })), Curry._1(A.pure, undefined), x);
  };
  return {
          map: map,
          fold_left: fold_left,
          fold_right: fold_right,
          Fold_Map: Fold_Map,
          Fold_Map_Any: Fold_Map_Any,
          Fold_Map_Plus: Fold_Map_Plus,
          traverse: traverse,
          sequence: sequence
        };
}

function Eq(E) {
  var eq = function (xs, ys) {
    if (xs !== undefined) {
      if (ys !== undefined) {
        return Curry._2(E.eq, Caml_option.valFromOption(xs), Caml_option.valFromOption(ys));
      } else {
        return false;
      }
    } else {
      return ys === undefined;
    }
  };
  return {
          eq: eq
        };
}

function Ord(O) {
  var eq = function (xs, ys) {
    if (xs !== undefined) {
      if (ys !== undefined) {
        return Curry._2(O.eq, Caml_option.valFromOption(xs), Caml_option.valFromOption(ys));
      } else {
        return false;
      }
    } else {
      return ys === undefined;
    }
  };
  var compare = function (a, b) {
    if (a !== undefined) {
      if (b !== undefined) {
        return Curry._2(O.compare, Caml_option.valFromOption(a), Caml_option.valFromOption(b));
      } else {
        return "greater_than";
      }
    } else if (b !== undefined) {
      return "less_than";
    } else {
      return "equal_to";
    }
  };
  return {
          eq: eq,
          compare: compare
        };
}

function Show(S) {
  var show = function (a) {
    if (a !== undefined) {
      return "Some(" + (Curry._1(S.show, Caml_option.valFromOption(a)) + ")");
    } else {
      return "None";
    }
  };
  return {
          show: show
        };
}

var include = Bastet__Infix.Monad(Monad);

var include$1 = Bastet__Infix.Alternative(Alternative);

var Infix_$great$great$eq = include.$great$great$eq;

var Infix_$eq$less$less = include.$eq$less$less;

var Infix_$great$eq$great = include.$great$eq$great;

var Infix_$less$eq$less = include.$less$eq$less;

var Infix_$less$pipe$great = include$1.$less$pipe$great;

var Infix_$less$$great = include$1.$less$$great;

var Infix_$less$at$great = include$1.$less$at$great;

var Infix_$less$star$great = include$1.$less$star$great;

var Infix = {
  $great$great$eq: Infix_$great$great$eq,
  $eq$less$less: Infix_$eq$less$less,
  $great$eq$great: Infix_$great$eq$great,
  $less$eq$less: Infix_$less$eq$less,
  $less$pipe$great: Infix_$less$pipe$great,
  $less$$great: Infix_$less$$great,
  $less$at$great: Infix_$less$at$great,
  $less$star$great: Infix_$less$star$great,
  $pipe$question: getWithDefault
};

exports.$less$dot = $less$dot;
exports.maybe = maybe;
exports.getWithDefault = getWithDefault;
exports.Functor = Functor;
exports.Apply = Apply;
exports.Applicative = Applicative;
exports.Monad = Monad;
exports.Magma = Magma;
exports.Semigroup = Semigroup;
exports.Monoid = Monoid;
exports.Quasigroup = Quasigroup;
exports.Loop = Loop;
exports.Alt = Alt;
exports.Plus = Plus;
exports.Alternative = Alternative;
exports.Foldable = Foldable;
exports.Traversable = Traversable;
exports.Eq = Eq;
exports.Ord = Ord;
exports.Show = Show;
exports.Infix = Infix;
/* include Not a pure module */
