// Generated by Melange
'use strict';

var Curry = require("melange.runtime/curry.js");
var Stdlib = require("melange/./stdlib.js");
var Caml_obj = require("melange.runtime/caml_obj.js");
var Bastet__Infix = require("./Infix.js");
var Bastet__Option = require("./Option.js");
var Bastet__Function = require("./Function.js");

function result(f, g, a) {
  if (a.TAG === /* Ok */0) {
    return Curry._1(f, a._0);
  } else {
    return Curry._1(g, a._0);
  }
}

function Magma(T, M) {
  var append = function (a, b) {
    if (a.TAG === /* Ok */0) {
      if (b.TAG === /* Ok */0) {
        return {
                TAG: /* Ok */0,
                _0: Curry._2(M.append, a._0, b._0)
              };
      }
      
    } else if (b.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: b._0
            };
    }
    if (a.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: a._0
            };
    } else {
      return {
              TAG: /* Error */1,
              _0: a._0
            };
    }
  };
  return {
          append: append
        };
}

function Medial_Magma(T, M) {
  var append = function (a, b) {
    if (a.TAG === /* Ok */0) {
      if (b.TAG === /* Ok */0) {
        return {
                TAG: /* Ok */0,
                _0: Curry._2(M.append, a._0, b._0)
              };
      }
      
    } else if (b.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: b._0
            };
    }
    if (a.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: a._0
            };
    } else {
      return {
              TAG: /* Error */1,
              _0: a._0
            };
    }
  };
  return {
          append: append
        };
}

function Semigroup(T, S) {
  var append = function (a, b) {
    if (a.TAG === /* Ok */0) {
      if (b.TAG === /* Ok */0) {
        return {
                TAG: /* Ok */0,
                _0: Curry._2(S.append, a._0, b._0)
              };
      }
      
    } else if (b.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: b._0
            };
    }
    if (a.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: a._0
            };
    } else {
      return {
              TAG: /* Error */1,
              _0: a._0
            };
    }
  };
  return {
          append: append
        };
}

function Functor(T) {
  var map = function (f, a) {
    if (a.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: Curry._1(f, a._0)
            };
    } else {
      return {
              TAG: /* Error */1,
              _0: a._0
            };
    }
  };
  return {
          map: map
        };
}

function bimap(f, g, a) {
  if (a.TAG === /* Ok */0) {
    return {
            TAG: /* Ok */0,
            _0: Curry._1(f, a._0)
          };
  } else {
    return {
            TAG: /* Error */1,
            _0: Curry._1(g, a._0)
          };
  }
}

var Bifunctor = {
  bimap: bimap
};

function Apply(T) {
  var map = function (f, a) {
    if (a.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: Curry._1(f, a._0)
            };
    } else {
      return {
              TAG: /* Error */1,
              _0: a._0
            };
    }
  };
  var apply = function (f, a) {
    if (f.TAG === /* Ok */0) {
      return map(f._0, a);
    } else {
      return {
              TAG: /* Error */1,
              _0: f._0
            };
    }
  };
  return {
          map: map,
          apply: apply
        };
}

function Applicative(T) {
  var map = function (f, a) {
    if (a.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: Curry._1(f, a._0)
            };
    } else {
      return {
              TAG: /* Error */1,
              _0: a._0
            };
    }
  };
  var apply = function (f, a) {
    if (f.TAG === /* Ok */0) {
      return map(f._0, a);
    } else {
      return {
              TAG: /* Error */1,
              _0: f._0
            };
    }
  };
  var pure = function (a) {
    return {
            TAG: /* Ok */0,
            _0: a
          };
  };
  return {
          map: map,
          apply: apply,
          pure: pure
        };
}

function Monad(T) {
  var map = function (f, a) {
    if (a.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: Curry._1(f, a._0)
            };
    } else {
      return {
              TAG: /* Error */1,
              _0: a._0
            };
    }
  };
  var apply = function (f, a) {
    if (f.TAG === /* Ok */0) {
      return map(f._0, a);
    } else {
      return {
              TAG: /* Error */1,
              _0: f._0
            };
    }
  };
  var pure = function (a) {
    return {
            TAG: /* Ok */0,
            _0: a
          };
  };
  var flat_map = function (a, f) {
    if (a.TAG === /* Ok */0) {
      return Curry._1(f, a._0);
    } else {
      return {
              TAG: /* Error */1,
              _0: a._0
            };
    }
  };
  return {
          map: map,
          apply: apply,
          pure: pure,
          flat_map: flat_map
        };
}

function Alt(T) {
  var map = function (f, a) {
    if (a.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: Curry._1(f, a._0)
            };
    } else {
      return {
              TAG: /* Error */1,
              _0: a._0
            };
    }
  };
  var alt = function (a, b) {
    if (a.TAG === /* Ok */0) {
      return a;
    } else {
      return b;
    }
  };
  return {
          map: map,
          alt: alt
        };
}

function Extend(T) {
  var map = function (f, a) {
    if (a.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: Curry._1(f, a._0)
            };
    } else {
      return {
              TAG: /* Error */1,
              _0: a._0
            };
    }
  };
  var extend = function (f, a) {
    if (a.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: Curry._1(f, a)
            };
    } else {
      return {
              TAG: /* Error */1,
              _0: a._0
            };
    }
  };
  return {
          map: map,
          extend: extend
        };
}

function Show(Ok, $$Error) {
  var show = function (param) {
    return result(Ok.show, $$Error.show, param);
  };
  return {
          show: show
        };
}

function Eq(Ok, $$Error) {
  var eq = function (a, b) {
    if (a.TAG === /* Ok */0) {
      if (b.TAG === /* Ok */0) {
        return Curry._2(Ok.eq, a._0, b._0);
      } else {
        return false;
      }
    } else if (b.TAG === /* Ok */0) {
      return false;
    } else {
      return Curry._2($$Error.eq, a._0, b._0);
    }
  };
  return {
          eq: eq
        };
}

function Ord(Ok, $$Error) {
  var eq = function (a, b) {
    if (a.TAG === /* Ok */0) {
      if (b.TAG === /* Ok */0) {
        return Curry._2(Ok.eq, a._0, b._0);
      } else {
        return false;
      }
    } else if (b.TAG === /* Ok */0) {
      return false;
    } else {
      return Curry._2($$Error.eq, a._0, b._0);
    }
  };
  var compare = function (a, b) {
    if (a.TAG === /* Ok */0) {
      if (b.TAG === /* Ok */0) {
        return Curry._2(Ok.compare, a._0, b._0);
      } else {
        return "greater_than";
      }
    } else if (b.TAG === /* Ok */0) {
      return "less_than";
    } else {
      return Curry._2($$Error.compare, a._0, b._0);
    }
  };
  return {
          eq: eq,
          compare: compare
        };
}

function Bounded(Ok, $$Error) {
  var eq = function (a, b) {
    if (a.TAG === /* Ok */0) {
      if (b.TAG === /* Ok */0) {
        return Curry._2(Ok.eq, a._0, b._0);
      } else {
        return false;
      }
    } else if (b.TAG === /* Ok */0) {
      return false;
    } else {
      return Curry._2($$Error.eq, a._0, b._0);
    }
  };
  var compare = function (a, b) {
    if (a.TAG === /* Ok */0) {
      if (b.TAG === /* Ok */0) {
        return Curry._2(Ok.compare, a._0, b._0);
      } else {
        return "greater_than";
      }
    } else if (b.TAG === /* Ok */0) {
      return "less_than";
    } else {
      return Curry._2($$Error.compare, a._0, b._0);
    }
  };
  var top = {
    TAG: /* Ok */0,
    _0: Ok.top
  };
  var bottom = {
    TAG: /* Error */1,
    _0: $$Error.bottom
  };
  return {
          eq: eq,
          compare: compare,
          top: top,
          bottom: bottom
        };
}

function Quasireflexive_Eq(Ok, $$Error) {
  var eq = function (a, b) {
    if (a.TAG === /* Ok */0) {
      if (b.TAG === /* Ok */0) {
        return true;
      } else {
        return false;
      }
    } else if (b.TAG === /* Ok */0) {
      return false;
    } else {
      return true;
    }
  };
  return {
          eq: eq
        };
}

function Quasireflexive_Ord(Ok, $$Error) {
  var eq = function (a, b) {
    if (a.TAG === /* Ok */0) {
      if (b.TAG === /* Ok */0) {
        return true;
      } else {
        return false;
      }
    } else if (b.TAG === /* Ok */0) {
      return false;
    } else {
      return true;
    }
  };
  var compare = function (a, b) {
    if (a.TAG === /* Ok */0) {
      if (b.TAG === /* Ok */0) {
        return "equal_to";
      } else {
        return "greater_than";
      }
    } else if (b.TAG === /* Ok */0) {
      return "less_than";
    } else {
      return "equal_to";
    }
  };
  return {
          eq: eq,
          compare: compare
        };
}

function Join_Semilattice(Ok, $$Error) {
  var join = function (a, b) {
    if (a.TAG !== /* Ok */0) {
      if (b.TAG === /* Ok */0) {
        return {
                TAG: /* Ok */0,
                _0: b._0
              };
      } else {
        return {
                TAG: /* Error */1,
                _0: Curry._2($$Error.join, a._0, b._0)
              };
      }
    }
    var a$p = a._0;
    if (b.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: Curry._2(Ok.join, a$p, b._0)
            };
    } else {
      return {
              TAG: /* Ok */0,
              _0: a$p
            };
    }
  };
  return {
          join: join
        };
}

function Meet_Semilattice(Ok, $$Error) {
  var meet = function (a, b) {
    if (a.TAG === /* Ok */0) {
      if (b.TAG === /* Ok */0) {
        return {
                TAG: /* Ok */0,
                _0: Curry._2(Ok.meet, a._0, b._0)
              };
      } else {
        return {
                TAG: /* Error */1,
                _0: b._0
              };
      }
    }
    var a$p = a._0;
    if (b.TAG === /* Ok */0) {
      return {
              TAG: /* Error */1,
              _0: a$p
            };
    } else {
      return {
              TAG: /* Error */1,
              _0: Curry._2($$Error.meet, a$p, b._0)
            };
    }
  };
  return {
          meet: meet
        };
}

function Bounded_Join_Semilattice(Ok, $$Error) {
  var join = function (a, b) {
    if (a.TAG !== /* Ok */0) {
      if (b.TAG === /* Ok */0) {
        return {
                TAG: /* Ok */0,
                _0: b._0
              };
      } else {
        return {
                TAG: /* Error */1,
                _0: Curry._2($$Error.join, a._0, b._0)
              };
      }
    }
    var a$p = a._0;
    if (b.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: Curry._2(Ok.join, a$p, b._0)
            };
    } else {
      return {
              TAG: /* Ok */0,
              _0: a$p
            };
    }
  };
  var bottom = {
    TAG: /* Error */1,
    _0: $$Error.bottom
  };
  return {
          join: join,
          bottom: bottom
        };
}

function Bounded_Meet_Semilattice(Ok, $$Error) {
  var meet = function (a, b) {
    if (a.TAG === /* Ok */0) {
      if (b.TAG === /* Ok */0) {
        return {
                TAG: /* Ok */0,
                _0: Curry._2(Ok.meet, a._0, b._0)
              };
      } else {
        return {
                TAG: /* Error */1,
                _0: b._0
              };
      }
    }
    var a$p = a._0;
    if (b.TAG === /* Ok */0) {
      return {
              TAG: /* Error */1,
              _0: a$p
            };
    } else {
      return {
              TAG: /* Error */1,
              _0: Curry._2($$Error.meet, a$p, b._0)
            };
    }
  };
  var top = {
    TAG: /* Ok */0,
    _0: Ok.top
  };
  return {
          meet: meet,
          top: top
        };
}

function Lattice(Ok, $$Error) {
  var join = function (a, b) {
    if (a.TAG !== /* Ok */0) {
      if (b.TAG === /* Ok */0) {
        return {
                TAG: /* Ok */0,
                _0: b._0
              };
      } else {
        return {
                TAG: /* Error */1,
                _0: Curry._2($$Error.join, a._0, b._0)
              };
      }
    }
    var a$p = a._0;
    if (b.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: Curry._2(Ok.join, a$p, b._0)
            };
    } else {
      return {
              TAG: /* Ok */0,
              _0: a$p
            };
    }
  };
  var meet = function (a, b) {
    if (a.TAG === /* Ok */0) {
      if (b.TAG === /* Ok */0) {
        return {
                TAG: /* Ok */0,
                _0: Curry._2(Ok.meet, a._0, b._0)
              };
      } else {
        return {
                TAG: /* Error */1,
                _0: b._0
              };
      }
    }
    var a$p = a._0;
    if (b.TAG === /* Ok */0) {
      return {
              TAG: /* Error */1,
              _0: a$p
            };
    } else {
      return {
              TAG: /* Error */1,
              _0: Curry._2($$Error.meet, a$p, b._0)
            };
    }
  };
  return {
          join: join,
          meet: meet
        };
}

function Bounded_Lattice(Ok, $$Error) {
  var join = function (a, b) {
    if (a.TAG !== /* Ok */0) {
      if (b.TAG === /* Ok */0) {
        return {
                TAG: /* Ok */0,
                _0: b._0
              };
      } else {
        return {
                TAG: /* Error */1,
                _0: Curry._2($$Error.join, a._0, b._0)
              };
      }
    }
    var a$p = a._0;
    if (b.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: Curry._2(Ok.join, a$p, b._0)
            };
    } else {
      return {
              TAG: /* Ok */0,
              _0: a$p
            };
    }
  };
  var bottom = {
    TAG: /* Error */1,
    _0: $$Error.bottom
  };
  var meet = function (a, b) {
    if (a.TAG === /* Ok */0) {
      if (b.TAG === /* Ok */0) {
        return {
                TAG: /* Ok */0,
                _0: Curry._2(Ok.meet, a._0, b._0)
              };
      } else {
        return {
                TAG: /* Error */1,
                _0: b._0
              };
      }
    }
    var a$p = a._0;
    if (b.TAG === /* Ok */0) {
      return {
              TAG: /* Error */1,
              _0: a$p
            };
    } else {
      return {
              TAG: /* Error */1,
              _0: Curry._2($$Error.meet, a$p, b._0)
            };
    }
  };
  var top = {
    TAG: /* Ok */0,
    _0: Ok.top
  };
  return {
          join: join,
          bottom: bottom,
          meet: meet,
          top: top
        };
}

function Distributive_Lattice(Ok, $$Error) {
  var join = function (a, b) {
    if (a.TAG !== /* Ok */0) {
      if (b.TAG === /* Ok */0) {
        return {
                TAG: /* Ok */0,
                _0: b._0
              };
      } else {
        return {
                TAG: /* Error */1,
                _0: Curry._2($$Error.join, a._0, b._0)
              };
      }
    }
    var a$p = a._0;
    if (b.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: Curry._2(Ok.join, a$p, b._0)
            };
    } else {
      return {
              TAG: /* Ok */0,
              _0: a$p
            };
    }
  };
  var meet = function (a, b) {
    if (a.TAG === /* Ok */0) {
      if (b.TAG === /* Ok */0) {
        return {
                TAG: /* Ok */0,
                _0: Curry._2(Ok.meet, a._0, b._0)
              };
      } else {
        return {
                TAG: /* Error */1,
                _0: b._0
              };
      }
    }
    var a$p = a._0;
    if (b.TAG === /* Ok */0) {
      return {
              TAG: /* Error */1,
              _0: a$p
            };
    } else {
      return {
              TAG: /* Error */1,
              _0: Curry._2($$Error.meet, a$p, b._0)
            };
    }
  };
  return {
          join: join,
          meet: meet
        };
}

function Bounded_Distributive_Lattice(Ok, $$Error) {
  var join = function (a, b) {
    if (a.TAG !== /* Ok */0) {
      if (b.TAG === /* Ok */0) {
        return {
                TAG: /* Ok */0,
                _0: b._0
              };
      } else {
        return {
                TAG: /* Error */1,
                _0: Curry._2($$Error.join, a._0, b._0)
              };
      }
    }
    var a$p = a._0;
    if (b.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: Curry._2(Ok.join, a$p, b._0)
            };
    } else {
      return {
              TAG: /* Ok */0,
              _0: a$p
            };
    }
  };
  var bottom = {
    TAG: /* Error */1,
    _0: $$Error.bottom
  };
  var meet = function (a, b) {
    if (a.TAG === /* Ok */0) {
      if (b.TAG === /* Ok */0) {
        return {
                TAG: /* Ok */0,
                _0: Curry._2(Ok.meet, a._0, b._0)
              };
      } else {
        return {
                TAG: /* Error */1,
                _0: b._0
              };
      }
    }
    var a$p = a._0;
    if (b.TAG === /* Ok */0) {
      return {
              TAG: /* Error */1,
              _0: a$p
            };
    } else {
      return {
              TAG: /* Error */1,
              _0: Curry._2($$Error.meet, a$p, b._0)
            };
    }
  };
  var top = {
    TAG: /* Ok */0,
    _0: Ok.top
  };
  return {
          join: join,
          bottom: bottom,
          meet: meet,
          top: top
        };
}

function Heyting_Algebra(Ok, $$Error) {
  var eq = function (a, b) {
    if (a.TAG === /* Ok */0) {
      if (b.TAG === /* Ok */0) {
        return true;
      } else {
        return false;
      }
    } else if (b.TAG === /* Ok */0) {
      return false;
    } else {
      return true;
    }
  };
  var compare = function (a, b) {
    if (a.TAG === /* Ok */0) {
      if (b.TAG === /* Ok */0) {
        return "equal_to";
      } else {
        return "greater_than";
      }
    } else if (b.TAG === /* Ok */0) {
      return "less_than";
    } else {
      return "equal_to";
    }
  };
  var join = function (a, b) {
    if (a.TAG !== /* Ok */0) {
      if (b.TAG === /* Ok */0) {
        return {
                TAG: /* Ok */0,
                _0: b._0
              };
      } else {
        return {
                TAG: /* Error */1,
                _0: Curry._2($$Error.join, a._0, b._0)
              };
      }
    }
    var a$p = a._0;
    if (b.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: Curry._2(Ok.join, a$p, b._0)
            };
    } else {
      return {
              TAG: /* Ok */0,
              _0: a$p
            };
    }
  };
  var bottom = {
    TAG: /* Error */1,
    _0: $$Error.bottom
  };
  var meet = function (a, b) {
    if (a.TAG === /* Ok */0) {
      if (b.TAG === /* Ok */0) {
        return {
                TAG: /* Ok */0,
                _0: Curry._2(Ok.meet, a._0, b._0)
              };
      } else {
        return {
                TAG: /* Error */1,
                _0: b._0
              };
      }
    }
    var a$p = a._0;
    if (b.TAG === /* Ok */0) {
      return {
              TAG: /* Error */1,
              _0: a$p
            };
    } else {
      return {
              TAG: /* Error */1,
              _0: Curry._2($$Error.meet, a$p, b._0)
            };
    }
  };
  var top = {
    TAG: /* Ok */0,
    _0: Ok.top
  };
  var not = function (a) {
    if (a.TAG === /* Ok */0) {
      var a$p = a._0;
      if (Caml_obj.caml_equal(a$p, Ok.top)) {
        return {
                TAG: /* Error */1,
                _0: $$Error.bottom
              };
      } else if (Caml_obj.caml_equal(a$p, Ok.bottom)) {
        return {
                TAG: /* Error */1,
                _0: $$Error.top
              };
      } else {
        return a;
      }
    }
    var a$p$1 = a._0;
    if (Caml_obj.caml_equal(a$p$1, $$Error.top)) {
      return {
              TAG: /* Ok */0,
              _0: Ok.bottom
            };
    } else if (Caml_obj.caml_equal(a$p$1, $$Error.bottom)) {
      return {
              TAG: /* Ok */0,
              _0: Ok.top
            };
    } else {
      return a;
    }
  };
  var implies = function (a, b) {
    return join(not(a), b);
  };
  return {
          eq: eq,
          compare: compare,
          join: join,
          bottom: bottom,
          meet: meet,
          top: top,
          not: not,
          implies: implies
        };
}

function Involutive_Heyting_Algebra(Ok, $$Error) {
  var eq = function (a, b) {
    if (a.TAG === /* Ok */0) {
      if (b.TAG === /* Ok */0) {
        return true;
      } else {
        return false;
      }
    } else if (b.TAG === /* Ok */0) {
      return false;
    } else {
      return true;
    }
  };
  var compare = function (a, b) {
    if (a.TAG === /* Ok */0) {
      if (b.TAG === /* Ok */0) {
        return "equal_to";
      } else {
        return "greater_than";
      }
    } else if (b.TAG === /* Ok */0) {
      return "less_than";
    } else {
      return "equal_to";
    }
  };
  var join = function (a, b) {
    if (a.TAG !== /* Ok */0) {
      if (b.TAG === /* Ok */0) {
        return {
                TAG: /* Ok */0,
                _0: b._0
              };
      } else {
        return {
                TAG: /* Error */1,
                _0: Curry._2($$Error.join, a._0, b._0)
              };
      }
    }
    var a$p = a._0;
    if (b.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: Curry._2(Ok.join, a$p, b._0)
            };
    } else {
      return {
              TAG: /* Ok */0,
              _0: a$p
            };
    }
  };
  var bottom = {
    TAG: /* Error */1,
    _0: $$Error.bottom
  };
  var meet = function (a, b) {
    if (a.TAG === /* Ok */0) {
      if (b.TAG === /* Ok */0) {
        return {
                TAG: /* Ok */0,
                _0: Curry._2(Ok.meet, a._0, b._0)
              };
      } else {
        return {
                TAG: /* Error */1,
                _0: b._0
              };
      }
    }
    var a$p = a._0;
    if (b.TAG === /* Ok */0) {
      return {
              TAG: /* Error */1,
              _0: a$p
            };
    } else {
      return {
              TAG: /* Error */1,
              _0: Curry._2($$Error.meet, a$p, b._0)
            };
    }
  };
  var top = {
    TAG: /* Ok */0,
    _0: Ok.top
  };
  var not = function (a) {
    if (a.TAG === /* Ok */0) {
      var a$p = a._0;
      if (Caml_obj.caml_equal(a$p, Ok.top)) {
        return {
                TAG: /* Error */1,
                _0: $$Error.bottom
              };
      } else if (Caml_obj.caml_equal(a$p, Ok.bottom)) {
        return {
                TAG: /* Error */1,
                _0: $$Error.top
              };
      } else {
        return a;
      }
    }
    var a$p$1 = a._0;
    if (Caml_obj.caml_equal(a$p$1, $$Error.top)) {
      return {
              TAG: /* Ok */0,
              _0: Ok.bottom
            };
    } else if (Caml_obj.caml_equal(a$p$1, $$Error.bottom)) {
      return {
              TAG: /* Ok */0,
              _0: Ok.top
            };
    } else {
      return a;
    }
  };
  var implies = function (a, b) {
    return join(not(a), b);
  };
  return {
          eq: eq,
          compare: compare,
          join: join,
          bottom: bottom,
          meet: meet,
          top: top,
          not: not,
          implies: implies
        };
}

function Boolean_Algebra(Ok, $$Error) {
  var eq = function (a, b) {
    if (a.TAG === /* Ok */0) {
      if (b.TAG === /* Ok */0) {
        return true;
      } else {
        return false;
      }
    } else if (b.TAG === /* Ok */0) {
      return false;
    } else {
      return true;
    }
  };
  var compare = function (a, b) {
    if (a.TAG === /* Ok */0) {
      if (b.TAG === /* Ok */0) {
        return "equal_to";
      } else {
        return "greater_than";
      }
    } else if (b.TAG === /* Ok */0) {
      return "less_than";
    } else {
      return "equal_to";
    }
  };
  var join = function (a, b) {
    if (a.TAG !== /* Ok */0) {
      if (b.TAG === /* Ok */0) {
        return {
                TAG: /* Ok */0,
                _0: b._0
              };
      } else {
        return {
                TAG: /* Error */1,
                _0: Curry._2($$Error.join, a._0, b._0)
              };
      }
    }
    var a$p = a._0;
    if (b.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: Curry._2(Ok.join, a$p, b._0)
            };
    } else {
      return {
              TAG: /* Ok */0,
              _0: a$p
            };
    }
  };
  var bottom = {
    TAG: /* Error */1,
    _0: $$Error.bottom
  };
  var meet = function (a, b) {
    if (a.TAG === /* Ok */0) {
      if (b.TAG === /* Ok */0) {
        return {
                TAG: /* Ok */0,
                _0: Curry._2(Ok.meet, a._0, b._0)
              };
      } else {
        return {
                TAG: /* Error */1,
                _0: b._0
              };
      }
    }
    var a$p = a._0;
    if (b.TAG === /* Ok */0) {
      return {
              TAG: /* Error */1,
              _0: a$p
            };
    } else {
      return {
              TAG: /* Error */1,
              _0: Curry._2($$Error.meet, a$p, b._0)
            };
    }
  };
  var top = {
    TAG: /* Ok */0,
    _0: Ok.top
  };
  var not = function (a) {
    if (a.TAG === /* Ok */0) {
      var a$p = a._0;
      if (Caml_obj.caml_equal(a$p, Ok.top)) {
        return {
                TAG: /* Error */1,
                _0: $$Error.bottom
              };
      } else if (Caml_obj.caml_equal(a$p, Ok.bottom)) {
        return {
                TAG: /* Error */1,
                _0: $$Error.top
              };
      } else {
        return a;
      }
    }
    var a$p$1 = a._0;
    if (Caml_obj.caml_equal(a$p$1, $$Error.top)) {
      return {
              TAG: /* Ok */0,
              _0: Ok.bottom
            };
    } else if (Caml_obj.caml_equal(a$p$1, $$Error.bottom)) {
      return {
              TAG: /* Ok */0,
              _0: Ok.top
            };
    } else {
      return a;
    }
  };
  var implies = function (a, b) {
    return join(not(a), b);
  };
  return {
          eq: eq,
          compare: compare,
          join: join,
          bottom: bottom,
          meet: meet,
          top: top,
          not: not,
          implies: implies
        };
}

var Many_Valued_Logic = {
  Quasireflexive_Eq: Quasireflexive_Eq,
  Quasireflexive_Ord: Quasireflexive_Ord,
  Join_Semilattice: Join_Semilattice,
  Meet_Semilattice: Meet_Semilattice,
  Bounded_Join_Semilattice: Bounded_Join_Semilattice,
  Bounded_Meet_Semilattice: Bounded_Meet_Semilattice,
  Lattice: Lattice,
  Bounded_Lattice: Bounded_Lattice,
  Distributive_Lattice: Distributive_Lattice,
  Bounded_Distributive_Lattice: Bounded_Distributive_Lattice,
  Heyting_Algebra: Heyting_Algebra,
  Involutive_Heyting_Algebra: Involutive_Heyting_Algebra,
  Boolean_Algebra: Boolean_Algebra
};

function Foldable(T) {
  var fold_left = function (f, initial, a) {
    if (a.TAG === /* Ok */0) {
      return Curry._2(f, initial, a._0);
    } else {
      return initial;
    }
  };
  var fold_right = function (f, initial, a) {
    if (a.TAG === /* Ok */0) {
      return Curry._2(f, a._0, initial);
    } else {
      return initial;
    }
  };
  var Fold_Map = function (M) {
    var fold_map = function (f, a) {
      if (a.TAG === /* Ok */0) {
        return Curry._1(f, a._0);
      } else {
        return M.empty;
      }
    };
    return {
            fold_map: fold_map
          };
  };
  var Fold_Map_Plus = function (P) {
    var fold_map = function (f, a) {
      if (a.TAG === /* Ok */0) {
        return Curry._1(f, a._0);
      } else {
        return P.empty;
      }
    };
    return {
            fold_map: fold_map
          };
  };
  var Fold_Map_Any = function (M) {
    var fold_map = function (f, a) {
      if (a.TAG === /* Ok */0) {
        return Curry._1(f, a._0);
      } else {
        return M.empty;
      }
    };
    return {
            fold_map: fold_map
          };
  };
  return {
          fold_left: fold_left,
          fold_right: fold_right,
          Fold_Map: Fold_Map,
          Fold_Map_Any: Fold_Map_Any,
          Fold_Map_Plus: Fold_Map_Plus
        };
}

function bifold_left(f, g, initial, a) {
  if (a.TAG === /* Ok */0) {
    return Curry._2(f, initial, a._0);
  } else {
    return Curry._2(g, initial, a._0);
  }
}

function bifold_right(f, g, initial, a) {
  if (a.TAG === /* Ok */0) {
    return Curry._2(f, a._0, initial);
  } else {
    return Curry._2(g, a._0, initial);
  }
}

function Fold_Map(M) {
  return {
          fold_map: result
        };
}

function Fold_Map_Any(M) {
  return {
          fold_map: result
        };
}

function Fold_Map_Plus(P) {
  return {
          fold_map: result
        };
}

var Bifoldable = {
  bifold_left: bifold_left,
  bifold_right: bifold_right,
  Fold_Map: Fold_Map,
  Fold_Map_Any: Fold_Map_Any,
  Fold_Map_Plus: Fold_Map_Plus
};

function Traversable(T, A) {
  var pure = function (a) {
    return {
            TAG: /* Ok */0,
            _0: a
          };
  };
  var map = function (f, a) {
    if (a.TAG === /* Ok */0) {
      return {
              TAG: /* Ok */0,
              _0: Curry._1(f, a._0)
            };
    } else {
      return {
              TAG: /* Error */1,
              _0: a._0
            };
    }
  };
  var fold_left = function (f, initial, a) {
    if (a.TAG === /* Ok */0) {
      return Curry._2(f, initial, a._0);
    } else {
      return initial;
    }
  };
  var fold_right = function (f, initial, a) {
    if (a.TAG === /* Ok */0) {
      return Curry._2(f, a._0, initial);
    } else {
      return initial;
    }
  };
  var Fold_Map = function (M) {
    var fold_map = function (f, a) {
      if (a.TAG === /* Ok */0) {
        return Curry._1(f, a._0);
      } else {
        return M.empty;
      }
    };
    return {
            fold_map: fold_map
          };
  };
  var Fold_Map_Plus = function (P) {
    var fold_map = function (f, a) {
      if (a.TAG === /* Ok */0) {
        return Curry._1(f, a._0);
      } else {
        return P.empty;
      }
    };
    return {
            fold_map: fold_map
          };
  };
  var Fold_Map_Any = function (M) {
    var fold_map = function (f, a) {
      if (a.TAG === /* Ok */0) {
        return Curry._1(f, a._0);
      } else {
        return M.empty;
      }
    };
    return {
            fold_map: fold_map
          };
  };
  var traverse = function (f, a) {
    if (a.TAG === /* Ok */0) {
      return Curry._2(A.map, pure, Curry._1(f, a._0));
    } else {
      return Curry._1(A.pure, {
                  TAG: /* Error */1,
                  _0: a._0
                });
    }
  };
  var sequence = function (a) {
    if (a.TAG === /* Ok */0) {
      return Curry._2(A.map, pure, a._0);
    } else {
      return Curry._1(A.pure, {
                  TAG: /* Error */1,
                  _0: a._0
                });
    }
  };
  return {
          map: map,
          fold_left: fold_left,
          fold_right: fold_right,
          Fold_Map: Fold_Map,
          Fold_Map_Any: Fold_Map_Any,
          Fold_Map_Plus: Fold_Map_Plus,
          traverse: traverse,
          sequence: sequence
        };
}

function Bitraversable(A) {
  var bitraverse = function (f, g, a) {
    if (a.TAG === /* Ok */0) {
      return Curry._2(A.map, (function (x) {
                    return {
                            TAG: /* Ok */0,
                            _0: x
                          };
                  }), Curry._1(f, a._0));
    } else {
      return Curry._2(A.map, (function (x) {
                    return {
                            TAG: /* Error */1,
                            _0: x
                          };
                  }), Curry._1(g, a._0));
    }
  };
  var bisequence = function (a) {
    if (a.TAG === /* Ok */0) {
      return Curry._2(A.map, (function (x) {
                    return {
                            TAG: /* Ok */0,
                            _0: x
                          };
                  }), a._0);
    } else {
      return Curry._2(A.map, (function (x) {
                    return {
                            TAG: /* Error */1,
                            _0: x
                          };
                  }), a._0);
    }
  };
  return {
          bimap: bimap,
          bifold_left: bifold_left,
          bifold_right: bifold_right,
          Fold_Map: Fold_Map,
          Fold_Map_Any: Fold_Map_Any,
          Fold_Map_Plus: Fold_Map_Plus,
          bitraverse: bitraverse,
          bisequence: bisequence
        };
}

var include = Bastet__Infix.Bifunctor(Bifunctor);

var Infix = include;

function Choose(A) {
  var choose = function (a, b) {
    return Curry._2(A.alt, Curry._2(A.map, (function (x) {
                      return {
                              TAG: /* Ok */0,
                              _0: x
                            };
                    }), a), Curry._2(A.map, (function (x) {
                      return {
                              TAG: /* Error */1,
                              _0: x
                            };
                    }), b));
  };
  return {
          choose: choose
        };
}

function from_ok(a) {
  if (a.TAG === /* Ok */0) {
    return a._0;
  }
  throw {
        RE_EXN_ID: Stdlib.Invalid_argument,
        _1: "You passed in an `Error` value to `from_ok`",
        Error: new Error()
      };
}

function from_error(a) {
  if (a.TAG !== /* Ok */0) {
    return a._0;
  }
  throw {
        RE_EXN_ID: Stdlib.Invalid_argument,
        _1: "You passed in an `Ok` value to `from_error`",
        Error: new Error()
      };
}

var Unsafe = {
  from_ok: from_ok,
  from_error: from_error
};

function is_ok(a) {
  return result((function (param) {
                return Bastet__Function.$$const(true, param);
              }), (function (param) {
                return Bastet__Function.$$const(false, param);
              }), a);
}

function is_error(a) {
  return result((function (param) {
                return Bastet__Function.$$const(false, param);
              }), (function (param) {
                return Bastet__Function.$$const(true, param);
              }), a);
}

function note($$default) {
  var partial_arg = {
    TAG: /* Error */1,
    _0: $$default
  };
  return function (param) {
    return Bastet__Option.maybe((function (x) {
                  return {
                          TAG: /* Ok */0,
                          _0: x
                        };
                }), partial_arg, param);
  };
}

function hush(e) {
  return result(Bastet__Option.Applicative.pure, (function (param) {
                return Bastet__Function.$$const(undefined, param);
              }), e);
}

var flip = Bastet__Function.flip;

var $$const = Bastet__Function.$$const;

exports.flip = flip;
exports.$$const = $$const;
exports.result = result;
exports.Magma = Magma;
exports.Medial_Magma = Medial_Magma;
exports.Semigroup = Semigroup;
exports.Functor = Functor;
exports.Bifunctor = Bifunctor;
exports.Apply = Apply;
exports.Applicative = Applicative;
exports.Monad = Monad;
exports.Alt = Alt;
exports.Extend = Extend;
exports.Show = Show;
exports.Eq = Eq;
exports.Ord = Ord;
exports.Bounded = Bounded;
exports.Many_Valued_Logic = Many_Valued_Logic;
exports.Foldable = Foldable;
exports.Bifoldable = Bifoldable;
exports.Traversable = Traversable;
exports.Bitraversable = Bitraversable;
exports.Infix = Infix;
exports.Choose = Choose;
exports.Unsafe = Unsafe;
exports.is_ok = is_ok;
exports.is_error = is_error;
exports.note = note;
exports.hush = hush;
/* include Not a pure module */
