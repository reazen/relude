// Generated by Melange
'use strict';

var Curry = require("melange.runtime/curry.js");
var Stdlib = require("melange/./stdlib.js");
var Bastet__Int = require("./Int.js");
var Bastet__Bool = require("./Bool.js");
var Bastet__List = require("./List.js");
var Bastet__Float = require("./Float.js");
var Bastet__Infix = require("./Infix.js");
var Bastet__Option = require("./Option.js");
var Bastet__String = require("./String.js");
var Bastet__Verify = require("./Verify.js");
var Bastet__Default = require("./Default.js");
var Bastet__Function = require("./Function.js");
var Bastet__Functors = require("./Functors.js");
var Stdlib__ListLabels = require("melange/./listLabels.js");

function Make(T, Q) {
  var $less$dot = Bastet__Function.Infix.$less$dot;
  var Medial_Magma = function (M, E, A) {
    var V = Bastet__Verify.Compare.Medial_Magma(M, E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Medial_Magma", {
                  hd: Curry._7(Q.property4, undefined, "should satisfy bicommutativity", A.make, A.make, A.make, A.make, V.bicommutativity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Quasigroup = function (QG, E, A) {
    var V = Bastet__Verify.Compare.Quasigroup(QG, E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Quasigroup", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.cancellative),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Semiring = function (S, E, A) {
    var V = Bastet__Verify.Compare.Semiring(S, E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Semiring", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy additive associativity", A.make, A.make, A.make, V.additive_associativity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy additive identity", A.make, V.additive_identity),
                    tl: {
                      hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V.commutativity),
                      tl: {
                        hd: Curry._6(Q.property3, undefined, "should satisfy multiplicative associativity", A.make, A.make, A.make, V.multiplicative_associativity),
                        tl: {
                          hd: Curry._4(Q.property, undefined, "should satisfy multiplicative identity", A.make, V.multiplicative_identity),
                          tl: {
                            hd: Curry._6(Q.property3, undefined, "should satisfy distributivity", A.make, A.make, A.make, V.distributivity),
                            tl: /* [] */0
                          }
                        }
                      }
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Division_Ring = function (D, E, A) {
    var V = Bastet__Verify.Compare.Division_Ring(D, E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Division_Ring", {
                  hd: Curry._2(T.test, "should be a non-zero ring (zero is not one)", (function (param) {
                          Curry._4(T.check, T.bool, undefined, V.non_zero_ring, true);
                        })),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy multiplicative inverse", A.make, V.multiplicative_inverse),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Euclidean_Ring = function (E, EQ, A) {
    var V = Bastet__Verify.Compare.Euclidean_Ring(E, EQ);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Euclidean_Ring", {
                  hd: Curry._2(T.test, "should be a non-zero ring (zero is not one)", (function (param) {
                          Curry._4(T.check, T.bool, undefined, V.non_zero_ring, true);
                        })),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy integral domain", A.make, A.make, V.integral_domain),
                    tl: {
                      hd: Curry._4(Q.property, undefined, "should satisfy non negative degree", A.make, V.non_negative_degree),
                      tl: {
                        hd: Curry._5(Q.property2, undefined, "should satisfy the properties for remainder", A.make, A.make, V.remainder),
                        tl: {
                          hd: Curry._5(Q.property2, undefined, "should satisfy submultiplicative", A.make, A.make, V.submultiplicative),
                          tl: /* [] */0
                        }
                      }
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Compare = {
    Medial_Magma: Medial_Magma,
    Quasigroup: Quasigroup,
    Semiring: Semiring,
    Division_Ring: Division_Ring,
    Euclidean_Ring: Euclidean_Ring
  };
  var Medial_Magma$1 = function (M, A) {
    var V = Bastet__Verify.Medial_Magma(M);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Medial_Magma", {
                  hd: Curry._7(Q.property4, undefined, "should satisfy bicommutativity", A.make, A.make, A.make, A.make, V.bicommutativity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Semigroup = function (S, A) {
    var V = Bastet__Verify.Semigroup(S);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Semigroup", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.associativity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Quasigroup$1 = function (QG, A) {
    var V = Bastet__Verify.Quasigroup(QG);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Quasigroup", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.cancellative),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Loop = function (L, A) {
    var V = Bastet__Verify.Loop(L);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Loop", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V.identity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Group = function (G, A) {
    var V = Bastet__Verify.Group(G);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Group", {
                  hd: Curry._4(Q.property, undefined, "should satisfy invertibility", A.make, V.invertibility),
                  tl: {
                    hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.associativity),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Abelian_Group = function (G, A) {
    var V = Bastet__Verify.Abelian_Group(G);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Abelian_Group", {
                  hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V.commutativity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Monoid = function (M, A) {
    var V = Bastet__Verify.Monoid(M);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Monoid", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V.identity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Functor = function (F, AA) {
    var V = Bastet__Verify.Functor(F);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Functor", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", Curry._1(AA.make, Q.arbitrary_int), V.identity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy composition", Curry._1(AA.make, Q.arbitrary_int), (function (a) {
                            return Curry._3(V.composition, (function (param) {
                                          return "!" + param;
                                        }), (function (prim) {
                                          return String(prim);
                                        }), a);
                          })),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Apply = function (A, AA) {
    var V = Bastet__Verify.Apply(A);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Apply", {
                  hd: Curry._4(Q.property, undefined, "should satisfy associative composition", Curry._1(AA.make, Q.arbitrary_int), (function (n) {
                          return Curry._3(V.associative_composition, Curry._1(A.pure, (function (param) {
                                            return "!" + param;
                                          })), Curry._1(A.pure, (function (prim) {
                                            return String(prim);
                                          })), n);
                        })),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Applicative = function (A, AA) {
    var V = Bastet__Verify.Applicative(A);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Applicative", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", Curry._1(AA.make, Q.arbitrary_int), V.identity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy homomorphism", Curry._1(AA.make, Q.arbitrary_int), Curry._1(V.homomorphism, Curry._1(A.map, (function (prim) {
                                    return String(prim);
                                  })))),
                    tl: {
                      hd: Curry._4(Q.property, undefined, "should satisfy interchange", Q.arbitrary_int, Curry._1(V.interchange, Curry._1(A.pure, (function (prim) {
                                      return String(prim);
                                    })))),
                      tl: /* [] */0
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Monad = function (M, AA) {
    var V = Bastet__Verify.Monad(M);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Monad", {
                  hd: Curry._4(Q.property, undefined, "should satisfy associativity", Curry._1(AA.make_bound, Q.arbitrary_int), Curry._2(V.associativity, Curry._2($less$dot, M.pure, (function (prim) {
                                  return String(prim);
                                })), Curry._2($less$dot, M.pure, (function (param) {
                                  return "!" + param;
                                })))),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy identity", Q.arbitrary_int, Curry._1(V.identity, Curry._2($less$dot, M.pure, (function (prim) {
                                    return String(prim);
                                  })))),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Alt = function (A, AA) {
    var V = Bastet__Verify.Alt(A);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Alt", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", Curry._1(AA.make, Q.arbitrary_int), Curry._1(AA.make, Q.arbitrary_int), Curry._1(AA.make, Q.arbitrary_int), V.associativity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy distributivity", Curry._1(AA.make, Q.arbitrary_int), Curry._1(AA.make, Q.arbitrary_int), Curry._1(V.distributivity, (function (prim) {
                                return String(prim);
                              }))),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Alternative = function (A, AA) {
    var V = Bastet__Verify.Alternative(A);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Alternative", {
                  hd: Curry._4(Q.property, undefined, "should satisfy distributivity", Curry._1(AA.make, Q.arbitrary_int), Curry._2(V.distributivity, Curry._1(A.pure, (function (param) {
                                  return (param << 1);
                                })), Curry._1(A.pure, (function (param) {
                                  return 3 + param | 0;
                                })))),
                  tl: {
                    hd: Curry._2(T.test, "should satisfy annihalation", (function (param) {
                            Curry._4(T.check, T.bool, undefined, Curry._1(V.annihalation, Curry._1(A.pure, (function (prim) {
                                            return String(prim);
                                          }))), true);
                          })),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Plus = function (P, AA) {
    var V = Bastet__Verify.Plus(P);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Plus", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", Curry._1(AA.make, Q.arbitrary_int), V.identity),
                  tl: {
                    hd: Curry._2(T.test, "should satisfy annihalation", (function (param) {
                            Curry._4(T.check, T.bool, undefined, Curry._1(V.annihalation, (function (prim) {
                                        return String(prim);
                                      })), true);
                          })),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Eq = function (E, A) {
    var V = Bastet__Verify.Eq(E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Eq", {
                  hd: Curry._4(Q.property, undefined, "should satisfy reflexivity", A.make, V.reflexivity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy symmetry", A.make, A.make, V.symmetry),
                    tl: {
                      hd: Curry._6(Q.property3, undefined, "should satisfy transitivity", A.make, A.make, A.make, V.transitivity),
                      tl: /* [] */0
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Ord = function (O, A) {
    var V = Bastet__Verify.Ord(O);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Ord", {
                  hd: Curry._4(Q.property, undefined, "should satisfy reflexivity", A.make, V.reflexivity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy antisymmetry", A.make, A.make, V.antisymmetry),
                    tl: {
                      hd: Curry._6(Q.property3, undefined, "should satisfy transitivity", A.make, A.make, A.make, V.transitivity),
                      tl: /* [] */0
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Join_Semilattice = function (JS, A) {
    var V = Bastet__Verify.Join_Semilattice(JS);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Join_Semilattice", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.associativity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V.commutativity),
                    tl: {
                      hd: Curry._4(Q.property, undefined, "should satisfy idempotency", A.make, V.idempotency),
                      tl: /* [] */0
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Meet_Semilattice = function (MS, A) {
    var V = Bastet__Verify.Meet_Semilattice(MS);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Meet_Semilattice", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.associativity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V.commutativity),
                    tl: {
                      hd: Curry._4(Q.property, undefined, "should satisfy idempotency", A.make, V.idempotency),
                      tl: /* [] */0
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Bounded_Join_Semilattice = function (BJS, A) {
    var V = Bastet__Verify.Bounded_Join_Semilattice(BJS);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Bounded_Join_Semilattice", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V.identity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Bounded_Meet_Semilattice = function (BMS, A) {
    var V = Bastet__Verify.Bounded_Meet_Semilattice(BMS);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Bounded_Meet_Semilattice", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V.identity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Lattice = function (L, A) {
    var V = Bastet__Verify.Lattice(L);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Lattice", {
                  hd: Curry._5(Q.property2, undefined, "should satisfy absorption", A.make, A.make, V.absorption),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Bounded_Lattice = function (BL, A) {
    var V = Bastet__Verify.Bounded_Lattice(BL);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Bounded_Lattice", {
                  hd: Curry._5(Q.property2, undefined, "should satisfy absorption", A.make, A.make, V.absorption),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Distributive_Lattice = function (DL, A) {
    var V = Bastet__Verify.Distributive_Lattice(DL);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Distributive_Lattice", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy distributivity", A.make, A.make, A.make, V.distributivity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Bounded_Distributive_Lattice = function (BDL, A) {
    var V = Bastet__Verify.Bounded_Distributive_Lattice(BDL);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Bounded_Distributive_Lattice", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy distributivity", A.make, A.make, A.make, V.distributivity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Heyting_Algebra = function (HA, A) {
    var V = Bastet__Verify.Heyting_Algebra(HA);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Heyting_Algebra", {
                  hd: Curry._4(Q.property, undefined, "should satisfy pseudocomplement", A.make, V.pseudocomplement),
                  tl: {
                    hd: Curry._6(Q.property3, undefined, "should satisfy relative pseudocomplement", A.make, A.make, A.make, V.relative_pseudocomplement),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Involutive_Heyting_Algebra = function (IHA, A) {
    var V = Bastet__Verify.Involutive_Heyting_Algebra(IHA);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Involutive_Heyting_Algebra", {
                  hd: Curry._4(Q.property, undefined, "should satisfy involution", A.make, V.involution),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Boolean_Algebra = function (BA, A) {
    var V = Bastet__Verify.Boolean_Algebra(BA);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Boolean_Algebra", {
                  hd: Curry._4(Q.property, undefined, "should satisfy the law of excluded middle", A.make, V.excluded_middle),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Bounded = function (B, A) {
    var V = Bastet__Verify.Bounded(B);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Bounded", {
                  hd: Curry._4(Q.property, undefined, "should satisfy bounded", A.make, V.bounded),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Semiring$1 = function (S, A) {
    var V = Bastet__Verify.Semiring(S);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Semiring", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy additive associativity", A.make, A.make, A.make, V.additive_associativity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy additive identity", A.make, V.additive_identity),
                    tl: {
                      hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V.commutativity),
                      tl: {
                        hd: Curry._6(Q.property3, undefined, "should satisfy multiplicative associativity", A.make, A.make, A.make, V.multiplicative_associativity),
                        tl: {
                          hd: Curry._4(Q.property, undefined, "should satisfy multiplicative identity", A.make, V.multiplicative_identity),
                          tl: {
                            hd: Curry._6(Q.property3, undefined, "should satisfy distributivity", A.make, A.make, A.make, V.distributivity),
                            tl: /* [] */0
                          }
                        }
                      }
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Ring = function (R, A) {
    var V = Bastet__Verify.Ring(R);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Ring", {
                  hd: Curry._4(Q.property, undefined, "should satisfy additive inverse", A.make, V.additive_inverse),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Commutative_Ring = function (C, A) {
    var V = Bastet__Verify.Commutative_Ring(C);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Commutative_Ring", {
                  hd: Curry._5(Q.property2, undefined, "should satisfy multiplicative commutativity", A.make, A.make, V.multiplicative_commutativity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Division_Ring$1 = function (D, A) {
    var V = Bastet__Verify.Division_Ring(D);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Division_Ring", {
                  hd: Curry._2(T.test, "should be a non-zero ring (zero is not one)", (function (param) {
                          Curry._4(T.check, T.bool, undefined, V.non_zero_ring, true);
                        })),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy multiplicative inverse", A.make, V.multiplicative_inverse),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Euclidean_Ring$1 = function (E, A) {
    var V = Bastet__Verify.Euclidean_Ring(E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Euclidean_Ring", {
                  hd: Curry._2(T.test, "should be a non-zero ring (zero is not one)", (function (param) {
                          Curry._4(T.check, T.bool, undefined, V.non_zero_ring, true);
                        })),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy integral domain", A.make, A.make, V.integral_domain),
                    tl: {
                      hd: Curry._4(Q.property, undefined, "should satisfy non negative degree", A.make, V.non_negative_degree),
                      tl: {
                        hd: Curry._5(Q.property2, undefined, "should satisfy the properties for remainder", A.make, A.make, V.remainder),
                        tl: {
                          hd: Curry._5(Q.property2, undefined, "should satisfy submultiplicative", A.make, A.make, V.submultiplicative),
                          tl: /* [] */0
                        }
                      }
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Field = function (F, A) {
    var V = Bastet__Verify.Field(F);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Field", {
                  hd: Curry._5(Q.property2, undefined, "should satisfy non zero multiplicative inverse", A.make, A.make, V.non_zero_multiplicative_inverse),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Invariant = function (I, AA) {
    var V = Bastet__Verify.Invariant(I);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Invariant", {
                  hd: Curry._4(Q.property, undefined, "should satisfy reflexivity", Curry._1(AA.make, Q.arbitrary_int), V.identity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy composition", Curry._1(AA.make, Q.arbitrary_int), Curry._4(V.composition, (function (prim) {
                                return prim;
                              }), (function (prim) {
                                return prim | 0;
                              }), Curry._2($less$dot, (function (param) {
                                    return Math.imul(3, param);
                                  }), (function (prim) {
                                    return prim | 0;
                                  })), Curry._2($less$dot, (function (param) {
                                    return 4.0 * param;
                                  }), (function (prim) {
                                    return prim;
                                  })))),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  return {
          $less$dot: $less$dot,
          Compare: Compare,
          Medial_Magma: Medial_Magma$1,
          Semigroup: Semigroup,
          Quasigroup: Quasigroup$1,
          Loop: Loop,
          Group: Group,
          Abelian_Group: Abelian_Group,
          Monoid: Monoid,
          Functor: Functor,
          Apply: Apply,
          Applicative: Applicative,
          Monad: Monad,
          Alt: Alt,
          Alternative: Alternative,
          Plus: Plus,
          Eq: Eq,
          Ord: Ord,
          Join_Semilattice: Join_Semilattice,
          Meet_Semilattice: Meet_Semilattice,
          Bounded_Join_Semilattice: Bounded_Join_Semilattice,
          Bounded_Meet_Semilattice: Bounded_Meet_Semilattice,
          Lattice: Lattice,
          Bounded_Lattice: Bounded_Lattice,
          Distributive_Lattice: Distributive_Lattice,
          Bounded_Distributive_Lattice: Bounded_Distributive_Lattice,
          Heyting_Algebra: Heyting_Algebra,
          Involutive_Heyting_Algebra: Involutive_Heyting_Algebra,
          Boolean_Algebra: Boolean_Algebra,
          Bounded: Bounded,
          Semiring: Semiring$1,
          Ring: Ring,
          Commutative_Ring: Commutative_Ring,
          Division_Ring: Division_Ring$1,
          Euclidean_Ring: Euclidean_Ring$1,
          Field: Field,
          Invariant: Invariant
        };
}

function $$Array(Arr, T, Q, A, AA) {
  var $less$dot = Bastet__Function.Infix.$less$dot;
  var Medial_Magma = function (M, E, A) {
    var V = Bastet__Verify.Compare.Medial_Magma(M, E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Medial_Magma", {
                  hd: Curry._7(Q.property4, undefined, "should satisfy bicommutativity", A.make, A.make, A.make, A.make, V.bicommutativity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Quasigroup = function (QG, E, A) {
    var V = Bastet__Verify.Compare.Quasigroup(QG, E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Quasigroup", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.cancellative),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Semiring = function (S, E, A) {
    var V = Bastet__Verify.Compare.Semiring(S, E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Semiring", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy additive associativity", A.make, A.make, A.make, V.additive_associativity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy additive identity", A.make, V.additive_identity),
                    tl: {
                      hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V.commutativity),
                      tl: {
                        hd: Curry._6(Q.property3, undefined, "should satisfy multiplicative associativity", A.make, A.make, A.make, V.multiplicative_associativity),
                        tl: {
                          hd: Curry._4(Q.property, undefined, "should satisfy multiplicative identity", A.make, V.multiplicative_identity),
                          tl: {
                            hd: Curry._6(Q.property3, undefined, "should satisfy distributivity", A.make, A.make, A.make, V.distributivity),
                            tl: /* [] */0
                          }
                        }
                      }
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Division_Ring = function (D, E, A) {
    var V = Bastet__Verify.Compare.Division_Ring(D, E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Division_Ring", {
                  hd: Curry._2(T.test, "should be a non-zero ring (zero is not one)", (function (param) {
                          Curry._4(T.check, T.bool, undefined, V.non_zero_ring, true);
                        })),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy multiplicative inverse", A.make, V.multiplicative_inverse),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Euclidean_Ring = function (E, EQ, A) {
    var V = Bastet__Verify.Compare.Euclidean_Ring(E, EQ);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Euclidean_Ring", {
                  hd: Curry._2(T.test, "should be a non-zero ring (zero is not one)", (function (param) {
                          Curry._4(T.check, T.bool, undefined, V.non_zero_ring, true);
                        })),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy integral domain", A.make, A.make, V.integral_domain),
                    tl: {
                      hd: Curry._4(Q.property, undefined, "should satisfy non negative degree", A.make, V.non_negative_degree),
                      tl: {
                        hd: Curry._5(Q.property2, undefined, "should satisfy the properties for remainder", A.make, A.make, V.remainder),
                        tl: {
                          hd: Curry._5(Q.property2, undefined, "should satisfy submultiplicative", A.make, A.make, V.submultiplicative),
                          tl: /* [] */0
                        }
                      }
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Compare = {
    Medial_Magma: Medial_Magma,
    Quasigroup: Quasigroup,
    Semiring: Semiring,
    Division_Ring: Division_Ring,
    Euclidean_Ring: Euclidean_Ring
  };
  var Medial_Magma$1 = function (M, A) {
    var V = Bastet__Verify.Medial_Magma(M);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Medial_Magma", {
                  hd: Curry._7(Q.property4, undefined, "should satisfy bicommutativity", A.make, A.make, A.make, A.make, V.bicommutativity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Semigroup = function (S, A) {
    var V = Bastet__Verify.Semigroup(S);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Semigroup", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.associativity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Quasigroup$1 = function (QG, A) {
    var V = Bastet__Verify.Quasigroup(QG);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Quasigroup", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.cancellative),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Loop = function (L, A) {
    var V = Bastet__Verify.Loop(L);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Loop", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V.identity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Group = function (G, A) {
    var V = Bastet__Verify.Group(G);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Group", {
                  hd: Curry._4(Q.property, undefined, "should satisfy invertibility", A.make, V.invertibility),
                  tl: {
                    hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.associativity),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Abelian_Group = function (G, A) {
    var V = Bastet__Verify.Abelian_Group(G);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Abelian_Group", {
                  hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V.commutativity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Monoid = function (M, A) {
    var V = Bastet__Verify.Monoid(M);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Monoid", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V.identity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Functor = function (F, AA) {
    var V = Bastet__Verify.Functor(F);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Functor", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", Curry._1(AA.make, Q.arbitrary_int), V.identity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy composition", Curry._1(AA.make, Q.arbitrary_int), (function (a) {
                            return Curry._3(V.composition, (function (param) {
                                          return "!" + param;
                                        }), (function (prim) {
                                          return String(prim);
                                        }), a);
                          })),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Apply = function (A, AA) {
    var V = Bastet__Verify.Apply(A);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Apply", {
                  hd: Curry._4(Q.property, undefined, "should satisfy associative composition", Curry._1(AA.make, Q.arbitrary_int), (function (n) {
                          return Curry._3(V.associative_composition, Curry._1(A.pure, (function (param) {
                                            return "!" + param;
                                          })), Curry._1(A.pure, (function (prim) {
                                            return String(prim);
                                          })), n);
                        })),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Applicative = function (A, AA) {
    var V = Bastet__Verify.Applicative(A);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Applicative", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", Curry._1(AA.make, Q.arbitrary_int), V.identity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy homomorphism", Curry._1(AA.make, Q.arbitrary_int), Curry._1(V.homomorphism, Curry._1(A.map, (function (prim) {
                                    return String(prim);
                                  })))),
                    tl: {
                      hd: Curry._4(Q.property, undefined, "should satisfy interchange", Q.arbitrary_int, Curry._1(V.interchange, Curry._1(A.pure, (function (prim) {
                                      return String(prim);
                                    })))),
                      tl: /* [] */0
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Monad = function (M, AA) {
    var V = Bastet__Verify.Monad(M);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Monad", {
                  hd: Curry._4(Q.property, undefined, "should satisfy associativity", Curry._1(AA.make_bound, Q.arbitrary_int), Curry._2(V.associativity, Curry._2($less$dot, M.pure, (function (prim) {
                                  return String(prim);
                                })), Curry._2($less$dot, M.pure, (function (param) {
                                  return "!" + param;
                                })))),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy identity", Q.arbitrary_int, Curry._1(V.identity, Curry._2($less$dot, M.pure, (function (prim) {
                                    return String(prim);
                                  })))),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Alt = function (A, AA) {
    var V = Bastet__Verify.Alt(A);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Alt", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", Curry._1(AA.make, Q.arbitrary_int), Curry._1(AA.make, Q.arbitrary_int), Curry._1(AA.make, Q.arbitrary_int), V.associativity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy distributivity", Curry._1(AA.make, Q.arbitrary_int), Curry._1(AA.make, Q.arbitrary_int), Curry._1(V.distributivity, (function (prim) {
                                return String(prim);
                              }))),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Alternative = function (A, AA) {
    var V = Bastet__Verify.Alternative(A);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Alternative", {
                  hd: Curry._4(Q.property, undefined, "should satisfy distributivity", Curry._1(AA.make, Q.arbitrary_int), Curry._2(V.distributivity, Curry._1(A.pure, (function (param) {
                                  return (param << 1);
                                })), Curry._1(A.pure, (function (param) {
                                  return 3 + param | 0;
                                })))),
                  tl: {
                    hd: Curry._2(T.test, "should satisfy annihalation", (function (param) {
                            Curry._4(T.check, T.bool, undefined, Curry._1(V.annihalation, Curry._1(A.pure, (function (prim) {
                                            return String(prim);
                                          }))), true);
                          })),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Plus = function (P, AA) {
    var V = Bastet__Verify.Plus(P);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Plus", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", Curry._1(AA.make, Q.arbitrary_int), V.identity),
                  tl: {
                    hd: Curry._2(T.test, "should satisfy annihalation", (function (param) {
                            Curry._4(T.check, T.bool, undefined, Curry._1(V.annihalation, (function (prim) {
                                        return String(prim);
                                      })), true);
                          })),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Eq = function (E, A) {
    var V = Bastet__Verify.Eq(E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Eq", {
                  hd: Curry._4(Q.property, undefined, "should satisfy reflexivity", A.make, V.reflexivity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy symmetry", A.make, A.make, V.symmetry),
                    tl: {
                      hd: Curry._6(Q.property3, undefined, "should satisfy transitivity", A.make, A.make, A.make, V.transitivity),
                      tl: /* [] */0
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Ord = function (O, A) {
    var V = Bastet__Verify.Ord(O);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Ord", {
                  hd: Curry._4(Q.property, undefined, "should satisfy reflexivity", A.make, V.reflexivity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy antisymmetry", A.make, A.make, V.antisymmetry),
                    tl: {
                      hd: Curry._6(Q.property3, undefined, "should satisfy transitivity", A.make, A.make, A.make, V.transitivity),
                      tl: /* [] */0
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Join_Semilattice = function (JS, A) {
    var V = Bastet__Verify.Join_Semilattice(JS);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Join_Semilattice", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.associativity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V.commutativity),
                    tl: {
                      hd: Curry._4(Q.property, undefined, "should satisfy idempotency", A.make, V.idempotency),
                      tl: /* [] */0
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Meet_Semilattice = function (MS, A) {
    var V = Bastet__Verify.Meet_Semilattice(MS);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Meet_Semilattice", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.associativity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V.commutativity),
                    tl: {
                      hd: Curry._4(Q.property, undefined, "should satisfy idempotency", A.make, V.idempotency),
                      tl: /* [] */0
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Bounded_Join_Semilattice = function (BJS, A) {
    var V = Bastet__Verify.Bounded_Join_Semilattice(BJS);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Bounded_Join_Semilattice", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V.identity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Bounded_Meet_Semilattice = function (BMS, A) {
    var V = Bastet__Verify.Bounded_Meet_Semilattice(BMS);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Bounded_Meet_Semilattice", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V.identity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Lattice = function (L, A) {
    var V = Bastet__Verify.Lattice(L);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Lattice", {
                  hd: Curry._5(Q.property2, undefined, "should satisfy absorption", A.make, A.make, V.absorption),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Bounded_Lattice = function (BL, A) {
    var V = Bastet__Verify.Bounded_Lattice(BL);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Bounded_Lattice", {
                  hd: Curry._5(Q.property2, undefined, "should satisfy absorption", A.make, A.make, V.absorption),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Distributive_Lattice = function (DL, A) {
    var V = Bastet__Verify.Distributive_Lattice(DL);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Distributive_Lattice", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy distributivity", A.make, A.make, A.make, V.distributivity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Bounded_Distributive_Lattice = function (BDL, A) {
    var V = Bastet__Verify.Bounded_Distributive_Lattice(BDL);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Bounded_Distributive_Lattice", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy distributivity", A.make, A.make, A.make, V.distributivity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Heyting_Algebra = function (HA, A) {
    var V = Bastet__Verify.Heyting_Algebra(HA);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Heyting_Algebra", {
                  hd: Curry._4(Q.property, undefined, "should satisfy pseudocomplement", A.make, V.pseudocomplement),
                  tl: {
                    hd: Curry._6(Q.property3, undefined, "should satisfy relative pseudocomplement", A.make, A.make, A.make, V.relative_pseudocomplement),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Involutive_Heyting_Algebra = function (IHA, A) {
    var V = Bastet__Verify.Involutive_Heyting_Algebra(IHA);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Involutive_Heyting_Algebra", {
                  hd: Curry._4(Q.property, undefined, "should satisfy involution", A.make, V.involution),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Boolean_Algebra = function (BA, A) {
    var V = Bastet__Verify.Boolean_Algebra(BA);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Boolean_Algebra", {
                  hd: Curry._4(Q.property, undefined, "should satisfy the law of excluded middle", A.make, V.excluded_middle),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Bounded = function (B, A) {
    var V = Bastet__Verify.Bounded(B);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Bounded", {
                  hd: Curry._4(Q.property, undefined, "should satisfy bounded", A.make, V.bounded),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Semiring$1 = function (S, A) {
    var V = Bastet__Verify.Semiring(S);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Semiring", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy additive associativity", A.make, A.make, A.make, V.additive_associativity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy additive identity", A.make, V.additive_identity),
                    tl: {
                      hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V.commutativity),
                      tl: {
                        hd: Curry._6(Q.property3, undefined, "should satisfy multiplicative associativity", A.make, A.make, A.make, V.multiplicative_associativity),
                        tl: {
                          hd: Curry._4(Q.property, undefined, "should satisfy multiplicative identity", A.make, V.multiplicative_identity),
                          tl: {
                            hd: Curry._6(Q.property3, undefined, "should satisfy distributivity", A.make, A.make, A.make, V.distributivity),
                            tl: /* [] */0
                          }
                        }
                      }
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Ring = function (R, A) {
    var V = Bastet__Verify.Ring(R);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Ring", {
                  hd: Curry._4(Q.property, undefined, "should satisfy additive inverse", A.make, V.additive_inverse),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Commutative_Ring = function (C, A) {
    var V = Bastet__Verify.Commutative_Ring(C);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Commutative_Ring", {
                  hd: Curry._5(Q.property2, undefined, "should satisfy multiplicative commutativity", A.make, A.make, V.multiplicative_commutativity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Division_Ring$1 = function (D, A) {
    var V = Bastet__Verify.Division_Ring(D);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Division_Ring", {
                  hd: Curry._2(T.test, "should be a non-zero ring (zero is not one)", (function (param) {
                          Curry._4(T.check, T.bool, undefined, V.non_zero_ring, true);
                        })),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy multiplicative inverse", A.make, V.multiplicative_inverse),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Euclidean_Ring$1 = function (E, A) {
    var V = Bastet__Verify.Euclidean_Ring(E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Euclidean_Ring", {
                  hd: Curry._2(T.test, "should be a non-zero ring (zero is not one)", (function (param) {
                          Curry._4(T.check, T.bool, undefined, V.non_zero_ring, true);
                        })),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy integral domain", A.make, A.make, V.integral_domain),
                    tl: {
                      hd: Curry._4(Q.property, undefined, "should satisfy non negative degree", A.make, V.non_negative_degree),
                      tl: {
                        hd: Curry._5(Q.property2, undefined, "should satisfy the properties for remainder", A.make, A.make, V.remainder),
                        tl: {
                          hd: Curry._5(Q.property2, undefined, "should satisfy submultiplicative", A.make, A.make, V.submultiplicative),
                          tl: /* [] */0
                        }
                      }
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Field = function (F, A) {
    var V = Bastet__Verify.Field(F);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Field", {
                  hd: Curry._5(Q.property2, undefined, "should satisfy non zero multiplicative inverse", A.make, A.make, V.non_zero_multiplicative_inverse),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Invariant = function (I, AA) {
    var V = Bastet__Verify.Invariant(I);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Invariant", {
                  hd: Curry._4(Q.property, undefined, "should satisfy reflexivity", Curry._1(AA.make, Q.arbitrary_int), V.identity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy composition", Curry._1(AA.make, Q.arbitrary_int), Curry._4(V.composition, (function (prim) {
                                return prim;
                              }), (function (prim) {
                                return prim | 0;
                              }), Curry._2($less$dot, (function (param) {
                                    return Math.imul(3, param);
                                  }), (function (prim) {
                                    return prim | 0;
                                  })), Curry._2($less$dot, (function (param) {
                                    return 4.0 * param;
                                  }), (function (prim) {
                                    return prim;
                                  })))),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var M = {
    $less$dot: $less$dot,
    Compare: Compare,
    Medial_Magma: Medial_Magma$1,
    Semigroup: Semigroup,
    Quasigroup: Quasigroup$1,
    Loop: Loop,
    Group: Group,
    Abelian_Group: Abelian_Group,
    Monoid: Monoid,
    Functor: Functor,
    Apply: Apply,
    Applicative: Applicative,
    Monad: Monad,
    Alt: Alt,
    Alternative: Alternative,
    Plus: Plus,
    Eq: Eq,
    Ord: Ord,
    Join_Semilattice: Join_Semilattice,
    Meet_Semilattice: Meet_Semilattice,
    Bounded_Join_Semilattice: Bounded_Join_Semilattice,
    Bounded_Meet_Semilattice: Bounded_Meet_Semilattice,
    Lattice: Lattice,
    Bounded_Lattice: Bounded_Lattice,
    Distributive_Lattice: Distributive_Lattice,
    Bounded_Distributive_Lattice: Bounded_Distributive_Lattice,
    Heyting_Algebra: Heyting_Algebra,
    Involutive_Heyting_Algebra: Involutive_Heyting_Algebra,
    Boolean_Algebra: Boolean_Algebra,
    Bounded: Bounded,
    Semiring: Semiring$1,
    Ring: Ring,
    Commutative_Ring: Commutative_Ring,
    Division_Ring: Division_Ring$1,
    Euclidean_Ring: Euclidean_Ring$1,
    Field: Field,
    Invariant: Invariant
  };
  var V = Bastet__Verify.Functor(Arr.Functor);
  var suite = function (name) {
    return Curry._2(T.suite, name + ".Functor", {
                hd: Curry._4(Q.property, undefined, "should satisfy identity", Curry._1(AA.make, Q.arbitrary_int), V.identity),
                tl: {
                  hd: Curry._4(Q.property, undefined, "should satisfy composition", Curry._1(AA.make, Q.arbitrary_int), (function (a) {
                          return Curry._3(V.composition, (function (param) {
                                        return "!" + param;
                                      }), (function (prim) {
                                        return String(prim);
                                      }), a);
                        })),
                  tl: /* [] */0
                }
              });
  };
  var Functor$1 = {
    V: V,
    suite: suite
  };
  var A$1 = Arr.Applicative;
  var V$1 = Bastet__Verify.Apply(A$1);
  var suite$1 = function (name) {
    return Curry._2(T.suite, name + ".Apply", {
                hd: Curry._4(Q.property, undefined, "should satisfy associative composition", Curry._1(AA.make, Q.arbitrary_int), (function (n) {
                        return Curry._3(V$1.associative_composition, Curry._1(A$1.pure, (function (param) {
                                          return "!" + param;
                                        })), Curry._1(A$1.pure, (function (prim) {
                                          return String(prim);
                                        })), n);
                      })),
                tl: /* [] */0
              });
  };
  var Apply$1 = {
    V: V$1,
    suite: suite$1
  };
  var A$2 = Arr.Applicative;
  var V$2 = Bastet__Verify.Applicative(A$2);
  var suite$2 = function (name) {
    return Curry._2(T.suite, name + ".Applicative", {
                hd: Curry._4(Q.property, undefined, "should satisfy identity", Curry._1(AA.make, Q.arbitrary_int), V$2.identity),
                tl: {
                  hd: Curry._4(Q.property, undefined, "should satisfy homomorphism", Curry._1(AA.make, Q.arbitrary_int), Curry._1(V$2.homomorphism, Curry._1(A$2.map, (function (prim) {
                                  return String(prim);
                                })))),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy interchange", Q.arbitrary_int, Curry._1(V$2.interchange, Curry._1(A$2.pure, (function (prim) {
                                    return String(prim);
                                  })))),
                    tl: /* [] */0
                  }
                }
              });
  };
  var Applicative$1 = {
    V: V$2,
    suite: suite$2
  };
  var M$1 = Arr.Monad;
  var V$3 = Bastet__Verify.Monad(M$1);
  var suite$3 = function (name) {
    return Curry._2(T.suite, name + ".Monad", {
                hd: Curry._4(Q.property, undefined, "should satisfy associativity", Curry._1(AA.make_bound, Q.arbitrary_int), Curry._2(V$3.associativity, Curry._2($less$dot, M$1.pure, (function (prim) {
                                return String(prim);
                              })), Curry._2($less$dot, M$1.pure, (function (param) {
                                return "!" + param;
                              })))),
                tl: {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", Q.arbitrary_int, Curry._1(V$3.identity, Curry._2($less$dot, M$1.pure, (function (prim) {
                                  return String(prim);
                                })))),
                  tl: /* [] */0
                }
              });
  };
  var Monad$1 = {
    V: V$3,
    suite: suite$3
  };
  var V$4 = Bastet__Verify.Alt(Arr.Alt);
  var suite$4 = function (name) {
    return Curry._2(T.suite, name + ".Alt", {
                hd: Curry._6(Q.property3, undefined, "should satisfy associativity", Curry._1(AA.make, Q.arbitrary_int), Curry._1(AA.make, Q.arbitrary_int), Curry._1(AA.make, Q.arbitrary_int), V$4.associativity),
                tl: {
                  hd: Curry._5(Q.property2, undefined, "should satisfy distributivity", Curry._1(AA.make, Q.arbitrary_int), Curry._1(AA.make, Q.arbitrary_int), Curry._1(V$4.distributivity, (function (prim) {
                              return String(prim);
                            }))),
                  tl: /* [] */0
                }
              });
  };
  var Alt$1 = {
    V: V$4,
    suite: suite$4
  };
  var E = Bastet__Functors.ArrayF.Int.Eq;
  var V$5 = Bastet__Verify.Eq(E);
  var suite$5 = function (name) {
    return Curry._2(T.suite, name + ".Eq", {
                hd: Curry._4(Q.property, undefined, "should satisfy reflexivity", A.make, V$5.reflexivity),
                tl: {
                  hd: Curry._5(Q.property2, undefined, "should satisfy symmetry", A.make, A.make, V$5.symmetry),
                  tl: {
                    hd: Curry._6(Q.property3, undefined, "should satisfy transitivity", A.make, A.make, A.make, V$5.transitivity),
                    tl: /* [] */0
                  }
                }
              });
  };
  var Eq$1 = {
    V: V$5,
    suite: suite$5
  };
  var O = Bastet__Functors.ArrayF.Int.Ord;
  var V$6 = Bastet__Verify.Ord(O);
  var suite$6 = function (name) {
    return Curry._2(T.suite, name + ".Ord", {
                hd: Curry._4(Q.property, undefined, "should satisfy reflexivity", A.make, V$6.reflexivity),
                tl: {
                  hd: Curry._5(Q.property2, undefined, "should satisfy antisymmetry", A.make, A.make, V$6.antisymmetry),
                  tl: {
                    hd: Curry._6(Q.property3, undefined, "should satisfy transitivity", A.make, A.make, A.make, V$6.transitivity),
                    tl: /* [] */0
                  }
                }
              });
  };
  var Ord$1 = {
    V: V$6,
    suite: suite$6
  };
  var V$7 = Bastet__Verify.Invariant(Arr.Invariant);
  var suite$7 = function (name) {
    return Curry._2(T.suite, name + ".Invariant", {
                hd: Curry._4(Q.property, undefined, "should satisfy reflexivity", Curry._1(AA.make, Q.arbitrary_int), V$7.identity),
                tl: {
                  hd: Curry._4(Q.property, undefined, "should satisfy composition", Curry._1(AA.make, Q.arbitrary_int), Curry._4(V$7.composition, (function (prim) {
                              return prim;
                            }), (function (prim) {
                              return prim | 0;
                            }), Curry._2($less$dot, (function (param) {
                                  return Math.imul(3, param);
                                }), (function (prim) {
                                  return prim | 0;
                                })), Curry._2($less$dot, (function (param) {
                                  return 4.0 * param;
                                }), (function (prim) {
                                  return prim;
                                })))),
                  tl: /* [] */0
                }
              });
  };
  var Invariant$1 = {
    V: V$7,
    suite: suite$7
  };
  var zip_with = Curry._2(T.suite, "Array.zip_with", {
        hd: Curry._2(T.test, "should zip_with two arrays", (function (param) {
                Curry._4(T.check, Curry._1(T.array, T.$$int), undefined, Curry._3(Arr.zip_with, (function (prim0, prim1) {
                            return Math.imul(prim0, prim1);
                          }), [
                          1,
                          2,
                          3
                        ], [
                          4,
                          5,
                          6
                        ]), [
                      4,
                      10,
                      18
                    ]);
              })),
        tl: /* [] */0
      });
  var zip = Curry._2(T.suite, "Array.zip", {
        hd: Curry._2(T.test, "should zip two arrays", (function (param) {
                Curry._4(T.check, Curry._1(T.array, Curry._2(T.tuple, T.$$int, T.string)), undefined, Curry._2(Arr.zip, [
                          1,
                          2,
                          3
                        ], [
                          "a",
                          "b",
                          "c"
                        ]), [
                      [
                        1,
                        "a"
                      ],
                      [
                        2,
                        "b"
                      ],
                      [
                        3,
                        "c"
                      ]
                    ]);
              })),
        tl: /* [] */0
      });
  var foldable = Curry._2(T.suite, "Array.Foldable", {
        hd: Curry._2(T.test, "should do a left fold", (function (param) {
                Curry._4(T.check, T.$$int, undefined, Curry._3(Arr.Foldable.fold_left, (function (prim0, prim1) {
                            return prim0 + prim1 | 0;
                          }), 0, [
                          1,
                          2,
                          3,
                          4,
                          5
                        ]), 15);
                Curry._4(T.check, T.$$int, undefined, Curry._3(Arr.Foldable.fold_left, (function (prim0, prim1) {
                            return prim0 - prim1 | 0;
                          }), 10, [
                          3,
                          2,
                          1
                        ]), 4);
              })),
        tl: {
          hd: Curry._2(T.test, "should do a right fold", (function (param) {
                  Curry._4(T.check, T.$$int, undefined, Curry._3(Arr.Foldable.fold_right, (function (prim0, prim1) {
                              return prim0 - prim1 | 0;
                            }), 10, [
                            3,
                            2,
                            1
                          ]), -8);
                })),
          tl: {
            hd: Curry._2(T.test, "should do a map fold (int)", (function (param) {
                    var fold_map = Bastet__Functors.ArrayF.Int.Additive.Fold_Map.fold_map;
                    Curry._4(T.check, T.$$int, undefined, Curry._2(fold_map, Bastet__Function.Category.id, [
                              1,
                              2,
                              3
                            ]), 6);
                  })),
            tl: {
              hd: Curry._2(T.test, "should do a map fold (list)", (function (param) {
                      var fold_map = Bastet__Functors.ArrayF.List.Fold_Map_Plus.fold_map;
                      Curry._4(T.check, Curry._1(T.list, Curry._1(T.list, T.$$int)), undefined, Curry._2(fold_map, Bastet__List.Applicative.pure, [
                                {
                                  hd: 1,
                                  tl: {
                                    hd: 2,
                                    tl: {
                                      hd: 3,
                                      tl: /* [] */0
                                    }
                                  }
                                },
                                {
                                  hd: 4,
                                  tl: {
                                    hd: 5,
                                    tl: /* [] */0
                                  }
                                }
                              ]), {
                            hd: {
                              hd: 1,
                              tl: {
                                hd: 2,
                                tl: {
                                  hd: 3,
                                  tl: /* [] */0
                                }
                              }
                            },
                            tl: {
                              hd: {
                                hd: 4,
                                tl: {
                                  hd: 5,
                                  tl: /* [] */0
                                }
                              },
                              tl: /* [] */0
                            }
                          });
                    })),
              tl: /* [] */0
            }
          }
        }
      });
  var unfoldable = Curry._2(T.suite, "Array.Unfoldable", {
        hd: Curry._2(T.test, "should do an unfold", (function (param) {
                Curry._4(T.check, Curry._1(T.array, T.$$int), undefined, Curry._2(Arr.Unfoldable.unfold, (function (x) {
                            if (x > 5) {
                              return ;
                            } else {
                              return [
                                      x,
                                      x + 1 | 0
                                    ];
                            }
                          }), 0), [
                      0,
                      1,
                      2,
                      3,
                      4,
                      5
                    ]);
              })),
        tl: {
          hd: Curry._2(T.test, "should do an unfold", (function (param) {
                  Curry._4(T.check, Curry._1(T.array, T.$$int), undefined, Curry._2(Arr.Unfoldable.unfold, (function (x) {
                              if (x > 20) {
                                return ;
                              } else {
                                return [
                                        x,
                                        x + 5 | 0
                                      ];
                              }
                            }), 0), [
                        0,
                        5,
                        10,
                        15,
                        20
                      ]);
                })),
          tl: /* [] */0
        }
      });
  var traverse = Bastet__Functors.ArrayF.$$Option.Traversable.traverse;
  var sequence = Bastet__Functors.ArrayF.$$Option.Traversable.sequence;
  var traversable = Curry._2(T.suite, "Array.Traversable", {
        hd: Curry._2(T.test, "should traverse the array", (function (param) {
                var positive_int = function (x) {
                  if (x >= 0) {
                    return x;
                  }
                  
                };
                Curry._4(T.check, Curry._1(T.option, Curry._1(T.array, T.$$int)), undefined, Curry._2(traverse, positive_int, [
                          1,
                          2,
                          3
                        ]), [
                      1,
                      2,
                      3
                    ]);
                Curry._4(T.check, Curry._1(T.option, Curry._1(T.array, T.$$int)), undefined, Curry._2(traverse, positive_int, [
                          1,
                          2,
                          -3
                        ]), undefined);
              })),
        tl: {
          hd: Curry._2(T.test, "should sequence the array", (function (param) {
                  Curry._4(T.check, Curry._1(T.option, Curry._1(T.array, T.$$int)), undefined, Curry._1(sequence, [
                            3,
                            4,
                            5
                          ]), [
                        3,
                        4,
                        5
                      ]);
                  Curry._4(T.check, Curry._1(T.option, Curry._1(T.array, T.$$int)), undefined, Curry._1(sequence, [
                            3,
                            4,
                            undefined
                          ]), undefined);
                })),
          tl: /* [] */0
        }
      });
  var S = Curry._1(Arr.Show, Bastet__Int.Show);
  var show = Curry._2(T.suite, "Array.Show", {
        hd: Curry._2(T.test, "should show the array", (function (param) {
                Curry._4(T.check, T.string, undefined, Curry._1(S.show, [
                          1,
                          1,
                          2,
                          3,
                          5,
                          8,
                          13
                        ]), "[1, 1, 2, 3, 5, 8, 13]");
              })),
        tl: /* [] */0
      });
  var V$8 = Bastet__Verify.Extend(Arr.Extend);
  var id = Bastet__Function.Category.id;
  var $less$dot$1 = Bastet__Function.Infix.$less$dot;
  var fold = Curry._1(Bastet__Functors.ArrayF.Int.Additive.Fold_Map.fold_map, id);
  var fold$p = Curry._1(Bastet__Functors.ArrayF.Float.Additive.Fold_Map.fold_map, id);
  var extend = Curry._2(T.suite, "Array.Extend", {
        hd: Curry._4(Q.property, undefined, "should satisfy associativity", Curry._1(AA.make_bound, Q.arbitrary_int), Curry._2(V$8.associativity, Curry._2($less$dot$1, Stdlib.string_of_float, fold$p), Curry._2($less$dot$1, (function (prim) {
                        return prim;
                      }), fold))),
        tl: /* [] */0
      });
  var alt_order = Curry._2(T.suite, "Array.Alt.alt", {
        hd: Curry._2(T.test, "should order the arrays correctly", (function (param) {
                Curry._4(T.check, Curry._1(T.array, T.$$int), undefined, Curry._2(Arr.Alt.alt, [
                          1,
                          2,
                          3
                        ], [
                          4,
                          5
                        ]), [
                      1,
                      2,
                      3,
                      4,
                      5
                    ]);
              })),
        tl: /* [] */0
      });
  var suites = Stdlib__ListLabels.append({
        hd: zip_with,
        tl: {
          hd: zip,
          tl: {
            hd: foldable,
            tl: {
              hd: unfoldable,
              tl: {
                hd: traversable,
                tl: {
                  hd: show,
                  tl: {
                    hd: extend,
                    tl: {
                      hd: alt_order,
                      tl: /* [] */0
                    }
                  }
                }
              }
            }
          }
        }
      }, Stdlib__ListLabels.map((function (suite) {
              return Curry._1(suite, "Array");
            }), {
            hd: suite,
            tl: {
              hd: suite$1,
              tl: {
                hd: suite$2,
                tl: {
                  hd: suite$3,
                  tl: {
                    hd: suite$4,
                    tl: {
                      hd: suite$5,
                      tl: {
                        hd: suite$6,
                        tl: {
                          hd: suite$7,
                          tl: /* [] */0
                        }
                      }
                    }
                  }
                }
              }
            }
          }));
  return {
          M: M,
          Functor: Functor$1,
          Apply: Apply$1,
          Applicative: Applicative$1,
          Monad: Monad$1,
          Alt: Alt$1,
          Eq: Eq$1,
          Ord: Ord$1,
          Invariant: Invariant$1,
          zip_with: zip_with,
          zip: zip,
          foldable: foldable,
          unfoldable: unfoldable,
          traversable: traversable,
          show: show,
          extend: extend,
          alt_order: alt_order,
          suites: suites
        };
}

function Bool(T, Q, A) {
  var $less$dot = Bastet__Function.Infix.$less$dot;
  var Medial_Magma = function (M, E, A) {
    var V = Bastet__Verify.Compare.Medial_Magma(M, E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Medial_Magma", {
                  hd: Curry._7(Q.property4, undefined, "should satisfy bicommutativity", A.make, A.make, A.make, A.make, V.bicommutativity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Quasigroup = function (QG, E, A) {
    var V = Bastet__Verify.Compare.Quasigroup(QG, E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Quasigroup", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.cancellative),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Semiring = function (S, E, A) {
    var V = Bastet__Verify.Compare.Semiring(S, E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Semiring", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy additive associativity", A.make, A.make, A.make, V.additive_associativity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy additive identity", A.make, V.additive_identity),
                    tl: {
                      hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V.commutativity),
                      tl: {
                        hd: Curry._6(Q.property3, undefined, "should satisfy multiplicative associativity", A.make, A.make, A.make, V.multiplicative_associativity),
                        tl: {
                          hd: Curry._4(Q.property, undefined, "should satisfy multiplicative identity", A.make, V.multiplicative_identity),
                          tl: {
                            hd: Curry._6(Q.property3, undefined, "should satisfy distributivity", A.make, A.make, A.make, V.distributivity),
                            tl: /* [] */0
                          }
                        }
                      }
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Division_Ring = function (D, E, A) {
    var V = Bastet__Verify.Compare.Division_Ring(D, E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Division_Ring", {
                  hd: Curry._2(T.test, "should be a non-zero ring (zero is not one)", (function (param) {
                          Curry._4(T.check, T.bool, undefined, V.non_zero_ring, true);
                        })),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy multiplicative inverse", A.make, V.multiplicative_inverse),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Euclidean_Ring = function (E, EQ, A) {
    var V = Bastet__Verify.Compare.Euclidean_Ring(E, EQ);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Euclidean_Ring", {
                  hd: Curry._2(T.test, "should be a non-zero ring (zero is not one)", (function (param) {
                          Curry._4(T.check, T.bool, undefined, V.non_zero_ring, true);
                        })),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy integral domain", A.make, A.make, V.integral_domain),
                    tl: {
                      hd: Curry._4(Q.property, undefined, "should satisfy non negative degree", A.make, V.non_negative_degree),
                      tl: {
                        hd: Curry._5(Q.property2, undefined, "should satisfy the properties for remainder", A.make, A.make, V.remainder),
                        tl: {
                          hd: Curry._5(Q.property2, undefined, "should satisfy submultiplicative", A.make, A.make, V.submultiplicative),
                          tl: /* [] */0
                        }
                      }
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Compare = {
    Medial_Magma: Medial_Magma,
    Quasigroup: Quasigroup,
    Semiring: Semiring,
    Division_Ring: Division_Ring,
    Euclidean_Ring: Euclidean_Ring
  };
  var Medial_Magma$1 = function (M, A) {
    var V = Bastet__Verify.Medial_Magma(M);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Medial_Magma", {
                  hd: Curry._7(Q.property4, undefined, "should satisfy bicommutativity", A.make, A.make, A.make, A.make, V.bicommutativity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Semigroup = function (S, A) {
    var V = Bastet__Verify.Semigroup(S);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Semigroup", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.associativity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Quasigroup$1 = function (QG, A) {
    var V = Bastet__Verify.Quasigroup(QG);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Quasigroup", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.cancellative),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Loop = function (L, A) {
    var V = Bastet__Verify.Loop(L);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Loop", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V.identity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Group = function (G, A) {
    var V = Bastet__Verify.Group(G);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Group", {
                  hd: Curry._4(Q.property, undefined, "should satisfy invertibility", A.make, V.invertibility),
                  tl: {
                    hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.associativity),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Abelian_Group = function (G, A) {
    var V = Bastet__Verify.Abelian_Group(G);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Abelian_Group", {
                  hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V.commutativity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Monoid = function (M, A) {
    var V = Bastet__Verify.Monoid(M);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Monoid", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V.identity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Functor = function (F, AA) {
    var V = Bastet__Verify.Functor(F);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Functor", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", Curry._1(AA.make, Q.arbitrary_int), V.identity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy composition", Curry._1(AA.make, Q.arbitrary_int), (function (a) {
                            return Curry._3(V.composition, (function (param) {
                                          return "!" + param;
                                        }), (function (prim) {
                                          return String(prim);
                                        }), a);
                          })),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Apply = function (A, AA) {
    var V = Bastet__Verify.Apply(A);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Apply", {
                  hd: Curry._4(Q.property, undefined, "should satisfy associative composition", Curry._1(AA.make, Q.arbitrary_int), (function (n) {
                          return Curry._3(V.associative_composition, Curry._1(A.pure, (function (param) {
                                            return "!" + param;
                                          })), Curry._1(A.pure, (function (prim) {
                                            return String(prim);
                                          })), n);
                        })),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Applicative = function (A, AA) {
    var V = Bastet__Verify.Applicative(A);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Applicative", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", Curry._1(AA.make, Q.arbitrary_int), V.identity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy homomorphism", Curry._1(AA.make, Q.arbitrary_int), Curry._1(V.homomorphism, Curry._1(A.map, (function (prim) {
                                    return String(prim);
                                  })))),
                    tl: {
                      hd: Curry._4(Q.property, undefined, "should satisfy interchange", Q.arbitrary_int, Curry._1(V.interchange, Curry._1(A.pure, (function (prim) {
                                      return String(prim);
                                    })))),
                      tl: /* [] */0
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Monad = function (M, AA) {
    var V = Bastet__Verify.Monad(M);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Monad", {
                  hd: Curry._4(Q.property, undefined, "should satisfy associativity", Curry._1(AA.make_bound, Q.arbitrary_int), Curry._2(V.associativity, Curry._2($less$dot, M.pure, (function (prim) {
                                  return String(prim);
                                })), Curry._2($less$dot, M.pure, (function (param) {
                                  return "!" + param;
                                })))),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy identity", Q.arbitrary_int, Curry._1(V.identity, Curry._2($less$dot, M.pure, (function (prim) {
                                    return String(prim);
                                  })))),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Alt = function (A, AA) {
    var V = Bastet__Verify.Alt(A);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Alt", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", Curry._1(AA.make, Q.arbitrary_int), Curry._1(AA.make, Q.arbitrary_int), Curry._1(AA.make, Q.arbitrary_int), V.associativity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy distributivity", Curry._1(AA.make, Q.arbitrary_int), Curry._1(AA.make, Q.arbitrary_int), Curry._1(V.distributivity, (function (prim) {
                                return String(prim);
                              }))),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Alternative = function (A, AA) {
    var V = Bastet__Verify.Alternative(A);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Alternative", {
                  hd: Curry._4(Q.property, undefined, "should satisfy distributivity", Curry._1(AA.make, Q.arbitrary_int), Curry._2(V.distributivity, Curry._1(A.pure, (function (param) {
                                  return (param << 1);
                                })), Curry._1(A.pure, (function (param) {
                                  return 3 + param | 0;
                                })))),
                  tl: {
                    hd: Curry._2(T.test, "should satisfy annihalation", (function (param) {
                            Curry._4(T.check, T.bool, undefined, Curry._1(V.annihalation, Curry._1(A.pure, (function (prim) {
                                            return String(prim);
                                          }))), true);
                          })),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Plus = function (P, AA) {
    var V = Bastet__Verify.Plus(P);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Plus", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", Curry._1(AA.make, Q.arbitrary_int), V.identity),
                  tl: {
                    hd: Curry._2(T.test, "should satisfy annihalation", (function (param) {
                            Curry._4(T.check, T.bool, undefined, Curry._1(V.annihalation, (function (prim) {
                                        return String(prim);
                                      })), true);
                          })),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Eq = function (E, A) {
    var V = Bastet__Verify.Eq(E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Eq", {
                  hd: Curry._4(Q.property, undefined, "should satisfy reflexivity", A.make, V.reflexivity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy symmetry", A.make, A.make, V.symmetry),
                    tl: {
                      hd: Curry._6(Q.property3, undefined, "should satisfy transitivity", A.make, A.make, A.make, V.transitivity),
                      tl: /* [] */0
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Ord = function (O, A) {
    var V = Bastet__Verify.Ord(O);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Ord", {
                  hd: Curry._4(Q.property, undefined, "should satisfy reflexivity", A.make, V.reflexivity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy antisymmetry", A.make, A.make, V.antisymmetry),
                    tl: {
                      hd: Curry._6(Q.property3, undefined, "should satisfy transitivity", A.make, A.make, A.make, V.transitivity),
                      tl: /* [] */0
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Join_Semilattice = function (JS, A) {
    var V = Bastet__Verify.Join_Semilattice(JS);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Join_Semilattice", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.associativity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V.commutativity),
                    tl: {
                      hd: Curry._4(Q.property, undefined, "should satisfy idempotency", A.make, V.idempotency),
                      tl: /* [] */0
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Meet_Semilattice = function (MS, A) {
    var V = Bastet__Verify.Meet_Semilattice(MS);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Meet_Semilattice", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.associativity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V.commutativity),
                    tl: {
                      hd: Curry._4(Q.property, undefined, "should satisfy idempotency", A.make, V.idempotency),
                      tl: /* [] */0
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Bounded_Join_Semilattice = function (BJS, A) {
    var V = Bastet__Verify.Bounded_Join_Semilattice(BJS);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Bounded_Join_Semilattice", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V.identity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Bounded_Meet_Semilattice = function (BMS, A) {
    var V = Bastet__Verify.Bounded_Meet_Semilattice(BMS);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Bounded_Meet_Semilattice", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V.identity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Lattice = function (L, A) {
    var V = Bastet__Verify.Lattice(L);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Lattice", {
                  hd: Curry._5(Q.property2, undefined, "should satisfy absorption", A.make, A.make, V.absorption),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Bounded_Lattice = function (BL, A) {
    var V = Bastet__Verify.Bounded_Lattice(BL);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Bounded_Lattice", {
                  hd: Curry._5(Q.property2, undefined, "should satisfy absorption", A.make, A.make, V.absorption),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Distributive_Lattice = function (DL, A) {
    var V = Bastet__Verify.Distributive_Lattice(DL);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Distributive_Lattice", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy distributivity", A.make, A.make, A.make, V.distributivity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Bounded_Distributive_Lattice = function (BDL, A) {
    var V = Bastet__Verify.Bounded_Distributive_Lattice(BDL);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Bounded_Distributive_Lattice", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy distributivity", A.make, A.make, A.make, V.distributivity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Heyting_Algebra = function (HA, A) {
    var V = Bastet__Verify.Heyting_Algebra(HA);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Heyting_Algebra", {
                  hd: Curry._4(Q.property, undefined, "should satisfy pseudocomplement", A.make, V.pseudocomplement),
                  tl: {
                    hd: Curry._6(Q.property3, undefined, "should satisfy relative pseudocomplement", A.make, A.make, A.make, V.relative_pseudocomplement),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Involutive_Heyting_Algebra = function (IHA, A) {
    var V = Bastet__Verify.Involutive_Heyting_Algebra(IHA);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Involutive_Heyting_Algebra", {
                  hd: Curry._4(Q.property, undefined, "should satisfy involution", A.make, V.involution),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Boolean_Algebra = function (BA, A) {
    var V = Bastet__Verify.Boolean_Algebra(BA);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Boolean_Algebra", {
                  hd: Curry._4(Q.property, undefined, "should satisfy the law of excluded middle", A.make, V.excluded_middle),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Bounded = function (B, A) {
    var V = Bastet__Verify.Bounded(B);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Bounded", {
                  hd: Curry._4(Q.property, undefined, "should satisfy bounded", A.make, V.bounded),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Semiring$1 = function (S, A) {
    var V = Bastet__Verify.Semiring(S);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Semiring", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy additive associativity", A.make, A.make, A.make, V.additive_associativity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy additive identity", A.make, V.additive_identity),
                    tl: {
                      hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V.commutativity),
                      tl: {
                        hd: Curry._6(Q.property3, undefined, "should satisfy multiplicative associativity", A.make, A.make, A.make, V.multiplicative_associativity),
                        tl: {
                          hd: Curry._4(Q.property, undefined, "should satisfy multiplicative identity", A.make, V.multiplicative_identity),
                          tl: {
                            hd: Curry._6(Q.property3, undefined, "should satisfy distributivity", A.make, A.make, A.make, V.distributivity),
                            tl: /* [] */0
                          }
                        }
                      }
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Ring = function (R, A) {
    var V = Bastet__Verify.Ring(R);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Ring", {
                  hd: Curry._4(Q.property, undefined, "should satisfy additive inverse", A.make, V.additive_inverse),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Commutative_Ring = function (C, A) {
    var V = Bastet__Verify.Commutative_Ring(C);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Commutative_Ring", {
                  hd: Curry._5(Q.property2, undefined, "should satisfy multiplicative commutativity", A.make, A.make, V.multiplicative_commutativity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Division_Ring$1 = function (D, A) {
    var V = Bastet__Verify.Division_Ring(D);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Division_Ring", {
                  hd: Curry._2(T.test, "should be a non-zero ring (zero is not one)", (function (param) {
                          Curry._4(T.check, T.bool, undefined, V.non_zero_ring, true);
                        })),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy multiplicative inverse", A.make, V.multiplicative_inverse),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Euclidean_Ring$1 = function (E, A) {
    var V = Bastet__Verify.Euclidean_Ring(E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Euclidean_Ring", {
                  hd: Curry._2(T.test, "should be a non-zero ring (zero is not one)", (function (param) {
                          Curry._4(T.check, T.bool, undefined, V.non_zero_ring, true);
                        })),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy integral domain", A.make, A.make, V.integral_domain),
                    tl: {
                      hd: Curry._4(Q.property, undefined, "should satisfy non negative degree", A.make, V.non_negative_degree),
                      tl: {
                        hd: Curry._5(Q.property2, undefined, "should satisfy the properties for remainder", A.make, A.make, V.remainder),
                        tl: {
                          hd: Curry._5(Q.property2, undefined, "should satisfy submultiplicative", A.make, A.make, V.submultiplicative),
                          tl: /* [] */0
                        }
                      }
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Field = function (F, A) {
    var V = Bastet__Verify.Field(F);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Field", {
                  hd: Curry._5(Q.property2, undefined, "should satisfy non zero multiplicative inverse", A.make, A.make, V.non_zero_multiplicative_inverse),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Invariant = function (I, AA) {
    var V = Bastet__Verify.Invariant(I);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Invariant", {
                  hd: Curry._4(Q.property, undefined, "should satisfy reflexivity", Curry._1(AA.make, Q.arbitrary_int), V.identity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy composition", Curry._1(AA.make, Q.arbitrary_int), Curry._4(V.composition, (function (prim) {
                                return prim;
                              }), (function (prim) {
                                return prim | 0;
                              }), Curry._2($less$dot, (function (param) {
                                    return Math.imul(3, param);
                                  }), (function (prim) {
                                    return prim | 0;
                                  })), Curry._2($less$dot, (function (param) {
                                    return 4.0 * param;
                                  }), (function (prim) {
                                    return prim;
                                  })))),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var M = {
    $less$dot: $less$dot,
    Compare: Compare,
    Medial_Magma: Medial_Magma$1,
    Semigroup: Semigroup,
    Quasigroup: Quasigroup$1,
    Loop: Loop,
    Group: Group,
    Abelian_Group: Abelian_Group,
    Monoid: Monoid,
    Functor: Functor,
    Apply: Apply,
    Applicative: Applicative,
    Monad: Monad,
    Alt: Alt,
    Alternative: Alternative,
    Plus: Plus,
    Eq: Eq,
    Ord: Ord,
    Join_Semilattice: Join_Semilattice,
    Meet_Semilattice: Meet_Semilattice,
    Bounded_Join_Semilattice: Bounded_Join_Semilattice,
    Bounded_Meet_Semilattice: Bounded_Meet_Semilattice,
    Lattice: Lattice,
    Bounded_Lattice: Bounded_Lattice,
    Distributive_Lattice: Distributive_Lattice,
    Bounded_Distributive_Lattice: Bounded_Distributive_Lattice,
    Heyting_Algebra: Heyting_Algebra,
    Involutive_Heyting_Algebra: Involutive_Heyting_Algebra,
    Boolean_Algebra: Boolean_Algebra,
    Bounded: Bounded,
    Semiring: Semiring$1,
    Ring: Ring,
    Commutative_Ring: Commutative_Ring,
    Division_Ring: Division_Ring$1,
    Euclidean_Ring: Euclidean_Ring$1,
    Field: Field,
    Invariant: Invariant
  };
  var M$1 = Bastet__Bool.Conjunctive.Medial_Magma;
  var V = Bastet__Verify.Medial_Magma(M$1);
  var suite = function (name) {
    return Curry._2(T.suite, name + ".Medial_Magma", {
                hd: Curry._7(Q.property4, undefined, "should satisfy bicommutativity", A.make, A.make, A.make, A.make, V.bicommutativity),
                tl: /* [] */0
              });
  };
  var Medial_Magma$2 = {
    V: V,
    suite: suite
  };
  var S = Bastet__Bool.Conjunctive.Semigroup;
  var V$1 = Bastet__Verify.Semigroup(S);
  var suite$1 = function (name) {
    return Curry._2(T.suite, name + ".Semigroup", {
                hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V$1.associativity),
                tl: /* [] */0
              });
  };
  var Semigroup$1 = {
    V: V$1,
    suite: suite$1
  };
  var M$2 = Bastet__Bool.Conjunctive.Monoid;
  var V$2 = Bastet__Verify.Monoid(M$2);
  var suite$2 = function (name) {
    return Curry._2(T.suite, name + ".Monoid", {
                hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V$2.identity),
                tl: /* [] */0
              });
  };
  var Monoid$1 = {
    V: V$2,
    suite: suite$2
  };
  var Conjunctive = {
    Medial_Magma: Medial_Magma$2,
    Semigroup: Semigroup$1,
    Monoid: Monoid$1
  };
  var M$3 = Bastet__Bool.Disjunctive.Medial_Magma;
  var V$3 = Bastet__Verify.Medial_Magma(M$3);
  var suite$3 = function (name) {
    return Curry._2(T.suite, name + ".Medial_Magma", {
                hd: Curry._7(Q.property4, undefined, "should satisfy bicommutativity", A.make, A.make, A.make, A.make, V$3.bicommutativity),
                tl: /* [] */0
              });
  };
  var Medial_Magma$3 = {
    V: V$3,
    suite: suite$3
  };
  var S$1 = Bastet__Bool.Disjunctive.Semigroup;
  var V$4 = Bastet__Verify.Semigroup(S$1);
  var suite$4 = function (name) {
    return Curry._2(T.suite, name + ".Semigroup", {
                hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V$4.associativity),
                tl: /* [] */0
              });
  };
  var Semigroup$2 = {
    V: V$4,
    suite: suite$4
  };
  var M$4 = Bastet__Bool.Disjunctive.Monoid;
  var V$5 = Bastet__Verify.Monoid(M$4);
  var suite$5 = function (name) {
    return Curry._2(T.suite, name + ".Monoid", {
                hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V$5.identity),
                tl: /* [] */0
              });
  };
  var Monoid$2 = {
    V: V$5,
    suite: suite$5
  };
  var Disjunctive = {
    Medial_Magma: Medial_Magma$3,
    Semigroup: Semigroup$2,
    Monoid: Monoid$2
  };
  var E = Bastet__Bool.Eq;
  var V$6 = Bastet__Verify.Eq(E);
  var suite$6 = function (name) {
    return Curry._2(T.suite, name + ".Eq", {
                hd: Curry._4(Q.property, undefined, "should satisfy reflexivity", A.make, V$6.reflexivity),
                tl: {
                  hd: Curry._5(Q.property2, undefined, "should satisfy symmetry", A.make, A.make, V$6.symmetry),
                  tl: {
                    hd: Curry._6(Q.property3, undefined, "should satisfy transitivity", A.make, A.make, A.make, V$6.transitivity),
                    tl: /* [] */0
                  }
                }
              });
  };
  var Eq$1 = {
    V: V$6,
    suite: suite$6
  };
  var O = Bastet__Bool.Ord;
  var V$7 = Bastet__Verify.Ord(O);
  var suite$7 = function (name) {
    return Curry._2(T.suite, name + ".Ord", {
                hd: Curry._4(Q.property, undefined, "should satisfy reflexivity", A.make, V$7.reflexivity),
                tl: {
                  hd: Curry._5(Q.property2, undefined, "should satisfy antisymmetry", A.make, A.make, V$7.antisymmetry),
                  tl: {
                    hd: Curry._6(Q.property3, undefined, "should satisfy transitivity", A.make, A.make, A.make, V$7.transitivity),
                    tl: /* [] */0
                  }
                }
              });
  };
  var Ord$1 = {
    V: V$7,
    suite: suite$7
  };
  var JS = Bastet__Bool.Join_Semilattice;
  var V$8 = Bastet__Verify.Join_Semilattice(JS);
  var suite$8 = function (name) {
    return Curry._2(T.suite, name + ".Join_Semilattice", {
                hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V$8.associativity),
                tl: {
                  hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V$8.commutativity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy idempotency", A.make, V$8.idempotency),
                    tl: /* [] */0
                  }
                }
              });
  };
  var Join_Semilattice$1 = {
    V: V$8,
    suite: suite$8
  };
  var MS = Bastet__Bool.Meet_Semilattice;
  var V$9 = Bastet__Verify.Meet_Semilattice(MS);
  var suite$9 = function (name) {
    return Curry._2(T.suite, name + ".Meet_Semilattice", {
                hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V$9.associativity),
                tl: {
                  hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V$9.commutativity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy idempotency", A.make, V$9.idempotency),
                    tl: /* [] */0
                  }
                }
              });
  };
  var Meet_Semilattice$1 = {
    V: V$9,
    suite: suite$9
  };
  var BJS = Bastet__Bool.Bounded_Join_Semilattice;
  var V$10 = Bastet__Verify.Bounded_Join_Semilattice(BJS);
  var suite$10 = function (name) {
    return Curry._2(T.suite, name + ".Bounded_Join_Semilattice", {
                hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V$10.identity),
                tl: /* [] */0
              });
  };
  var Bounded_Join_Semilattice$1 = {
    V: V$10,
    suite: suite$10
  };
  var BMS = Bastet__Bool.Bounded_Meet_Semilattice;
  var V$11 = Bastet__Verify.Bounded_Meet_Semilattice(BMS);
  var suite$11 = function (name) {
    return Curry._2(T.suite, name + ".Bounded_Meet_Semilattice", {
                hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V$11.identity),
                tl: /* [] */0
              });
  };
  var Bounded_Meet_Semilattice$1 = {
    V: V$11,
    suite: suite$11
  };
  var L = Bastet__Bool.Lattice;
  var V$12 = Bastet__Verify.Lattice(L);
  var suite$12 = function (name) {
    return Curry._2(T.suite, name + ".Lattice", {
                hd: Curry._5(Q.property2, undefined, "should satisfy absorption", A.make, A.make, V$12.absorption),
                tl: /* [] */0
              });
  };
  var Lattice$1 = {
    V: V$12,
    suite: suite$12
  };
  var BL = Bastet__Bool.Bounded_Lattice;
  var V$13 = Bastet__Verify.Bounded_Lattice(BL);
  var suite$13 = function (name) {
    return Curry._2(T.suite, name + ".Bounded_Lattice", {
                hd: Curry._5(Q.property2, undefined, "should satisfy absorption", A.make, A.make, V$13.absorption),
                tl: /* [] */0
              });
  };
  var Bounded_Lattice$1 = {
    V: V$13,
    suite: suite$13
  };
  var DL = Bastet__Bool.Distributive_Lattice;
  var V$14 = Bastet__Verify.Distributive_Lattice(DL);
  var suite$14 = function (name) {
    return Curry._2(T.suite, name + ".Distributive_Lattice", {
                hd: Curry._6(Q.property3, undefined, "should satisfy distributivity", A.make, A.make, A.make, V$14.distributivity),
                tl: /* [] */0
              });
  };
  var Distributive_Lattice$1 = {
    V: V$14,
    suite: suite$14
  };
  var BDL = Bastet__Bool.Bounded_Distributive_Lattice;
  var V$15 = Bastet__Verify.Bounded_Distributive_Lattice(BDL);
  var suite$15 = function (name) {
    return Curry._2(T.suite, name + ".Bounded_Distributive_Lattice", {
                hd: Curry._6(Q.property3, undefined, "should satisfy distributivity", A.make, A.make, A.make, V$15.distributivity),
                tl: /* [] */0
              });
  };
  var Bounded_Distributive_Lattice$1 = {
    V: V$15,
    suite: suite$15
  };
  var HA = Bastet__Bool.Heyting_Algebra;
  var V$16 = Bastet__Verify.Heyting_Algebra(HA);
  var suite$16 = function (name) {
    return Curry._2(T.suite, name + ".Heyting_Algebra", {
                hd: Curry._4(Q.property, undefined, "should satisfy pseudocomplement", A.make, V$16.pseudocomplement),
                tl: {
                  hd: Curry._6(Q.property3, undefined, "should satisfy relative pseudocomplement", A.make, A.make, A.make, V$16.relative_pseudocomplement),
                  tl: /* [] */0
                }
              });
  };
  var Heyting_Algebra$1 = {
    V: V$16,
    suite: suite$16
  };
  var IHA = Bastet__Bool.Involutive_Heyting_Algebra;
  var V$17 = Bastet__Verify.Involutive_Heyting_Algebra(IHA);
  var suite$17 = function (name) {
    return Curry._2(T.suite, name + ".Involutive_Heyting_Algebra", {
                hd: Curry._4(Q.property, undefined, "should satisfy involution", A.make, V$17.involution),
                tl: /* [] */0
              });
  };
  var Involutive_Heyting_Algebra$1 = {
    V: V$17,
    suite: suite$17
  };
  var BA = Bastet__Bool.Boolean_Algebra;
  var V$18 = Bastet__Verify.Boolean_Algebra(BA);
  var suite$18 = function (name) {
    return Curry._2(T.suite, name + ".Boolean_Algebra", {
                hd: Curry._4(Q.property, undefined, "should satisfy the law of excluded middle", A.make, V$18.excluded_middle),
                tl: /* [] */0
              });
  };
  var Boolean_Algebra$1 = {
    V: V$18,
    suite: suite$18
  };
  var suites = Stdlib__ListLabels.concat({
        hd: Stdlib__ListLabels.map((function (suite) {
                return Curry._1(suite, "Bool.Conjunctive");
              }), {
              hd: suite,
              tl: {
                hd: suite$1,
                tl: {
                  hd: suite$2,
                  tl: /* [] */0
                }
              }
            }),
        tl: {
          hd: Stdlib__ListLabels.map((function (suite) {
                  return Curry._1(suite, "Bool.Disjunctive");
                }), {
                hd: suite$3,
                tl: {
                  hd: suite$4,
                  tl: {
                    hd: suite$5,
                    tl: /* [] */0
                  }
                }
              }),
          tl: {
            hd: Stdlib__ListLabels.map((function (suite) {
                    return Curry._1(suite, "Bool");
                  }), {
                  hd: suite$6,
                  tl: {
                    hd: suite$7,
                    tl: {
                      hd: suite$8,
                      tl: {
                        hd: suite$9,
                        tl: {
                          hd: suite$10,
                          tl: {
                            hd: suite$11,
                            tl: {
                              hd: suite$12,
                              tl: {
                                hd: suite$13,
                                tl: {
                                  hd: suite$14,
                                  tl: {
                                    hd: suite$15,
                                    tl: {
                                      hd: suite$16,
                                      tl: {
                                        hd: suite$17,
                                        tl: {
                                          hd: suite$18,
                                          tl: /* [] */0
                                        }
                                      }
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }),
            tl: /* [] */0
          }
        }
      });
  return {
          M: M,
          Conjunctive: Conjunctive,
          Disjunctive: Disjunctive,
          Eq: Eq$1,
          Ord: Ord$1,
          Join_Semilattice: Join_Semilattice$1,
          Meet_Semilattice: Meet_Semilattice$1,
          Bounded_Join_Semilattice: Bounded_Join_Semilattice$1,
          Bounded_Meet_Semilattice: Bounded_Meet_Semilattice$1,
          Lattice: Lattice$1,
          Bounded_Lattice: Bounded_Lattice$1,
          Distributive_Lattice: Distributive_Lattice$1,
          Bounded_Distributive_Lattice: Bounded_Distributive_Lattice$1,
          Heyting_Algebra: Heyting_Algebra$1,
          Involutive_Heyting_Algebra: Involutive_Heyting_Algebra$1,
          Boolean_Algebra: Boolean_Algebra$1,
          suites: suites
        };
}

function Default(T, Q) {
  var Fold_Map_Any = function (M) {
    var fold_map = function (f, x) {
      return Stdlib__ListLabels.fold_left((function (acc, x) {
                    return Curry._2(M.append, acc, Curry._1(f, x));
                  }), M.empty, x);
    };
    return {
            fold_map: fold_map
          };
  };
  var Fold_Map_Plus = function (P) {
    var fold_map = function (f, x) {
      return Stdlib__ListLabels.fold_left((function (acc, x) {
                    return Curry._2(P.alt, acc, Curry._1(f, x));
                  }), P.empty, x);
    };
    return {
            fold_map: fold_map
          };
  };
  var FM = {
    Fold_Map_Any: Fold_Map_Any,
    Fold_Map_Plus: Fold_Map_Plus
  };
  var F = Bastet__Default.Fold(FM);
  var fold_left = F.fold_left_default;
  var Foldable_fold_right = F.fold_right_default;
  var Foldable_Fold_Map = Bastet__List.Foldable.Fold_Map;
  var Foldable = {
    fold_left: fold_left,
    fold_right: Foldable_fold_right,
    Fold_Map: Foldable_Fold_Map,
    Fold_Map_Any: Fold_Map_Any,
    Fold_Map_Plus: Fold_Map_Plus
  };
  var Traversable = function (A) {
    var map = Bastet__List.Functor.map;
    var fold_left = Bastet__List.Foldable.fold_left;
    var fold_right = Bastet__List.Foldable.fold_right;
    var Fold_Map = Bastet__List.Foldable.Fold_Map;
    var Fold_Map_Any = Bastet__List.Foldable.Fold_Map_Any;
    var Fold_Map_Plus = Bastet__List.Foldable.Fold_Map_Plus;
    var I = Bastet__Infix.Apply(A);
    var sequence = function (xs) {
      return Stdlib__ListLabels.fold_right((function (acc, x) {
                    return Curry._2(I.$less$star$great, Curry._2(I.$less$star$great, Curry._1(A.pure, (function (y, ys) {
                                          return {
                                                  hd: y,
                                                  tl: ys
                                                };
                                        })), acc), x);
                  }), xs, Curry._1(A.pure, /* [] */0));
    };
    var D = Bastet__Default.Traverse({
          map: Bastet__List.Functor.map,
          sequence: sequence
        });
    var traverse = D.traverse_default;
    var List_Traversable = {
      map: map,
      fold_left: fold_left,
      fold_right: fold_right,
      Fold_Map: Fold_Map,
      Fold_Map_Any: Fold_Map_Any,
      Fold_Map_Plus: Fold_Map_Plus,
      traverse: traverse,
      sequence: sequence
    };
    return {
            List_Traversable: List_Traversable,
            map: map,
            fold_left: fold_left,
            fold_right: fold_right,
            Fold_Map: Fold_Map,
            Fold_Map_Any: Fold_Map_Any,
            Fold_Map_Plus: Fold_Map_Plus,
            traverse: traverse,
            sequence: sequence
          };
  };
  var foldable = Curry._2(T.suite, "Default.Foldable", {
        hd: Curry._2(T.test, "should do a left fold", (function (param) {
                Curry._4(T.check, T.$$int, undefined, Curry._3(fold_left, (function (prim0, prim1) {
                            return prim0 + prim1 | 0;
                          }), 0, {
                          hd: 1,
                          tl: {
                            hd: 2,
                            tl: {
                              hd: 3,
                              tl: {
                                hd: 4,
                                tl: {
                                  hd: 5,
                                  tl: /* [] */0
                                }
                              }
                            }
                          }
                        }), 15);
                Curry._4(T.check, T.$$int, undefined, Curry._3(fold_left, (function (prim0, prim1) {
                            return prim0 - prim1 | 0;
                          }), 10, {
                          hd: 3,
                          tl: {
                            hd: 2,
                            tl: {
                              hd: 1,
                              tl: /* [] */0
                            }
                          }
                        }), 4);
              })),
        tl: /* [] */0
      });
  var map = Bastet__List.Functor.map;
  var fold_left$1 = Bastet__List.Foldable.fold_left;
  var fold_right = Bastet__List.Foldable.fold_right;
  var Fold_Map = Bastet__List.Foldable.Fold_Map;
  var Fold_Map_Any$1 = Bastet__List.Foldable.Fold_Map_Any;
  var Fold_Map_Plus$1 = Bastet__List.Foldable.Fold_Map_Plus;
  var I = Bastet__Infix.Apply(Bastet__Option.Applicative);
  var sequence = function (xs) {
    return Stdlib__ListLabels.fold_right((function (acc, x) {
                  return Curry._2(I.$less$star$great, Curry._2(I.$less$star$great, Curry._1(Bastet__Option.Applicative.pure, (function (y, ys) {
                                        return {
                                                hd: y,
                                                tl: ys
                                              };
                                      })), acc), x);
                }), xs, Curry._1(Bastet__Option.Applicative.pure, /* [] */0));
  };
  var D = Bastet__Default.Traverse({
        map: Bastet__List.Functor.map,
        sequence: sequence
      });
  var traverse = D.traverse_default;
  var List_Traversable = {
    map: map,
    fold_left: fold_left$1,
    fold_right: fold_right,
    Fold_Map: Fold_Map,
    Fold_Map_Any: Fold_Map_Any$1,
    Fold_Map_Plus: Fold_Map_Plus$1,
    traverse: traverse,
    sequence: sequence
  };
  var Traverse = {
    List_Traversable: List_Traversable,
    map: map,
    fold_left: fold_left$1,
    fold_right: fold_right,
    Fold_Map: Fold_Map,
    Fold_Map_Any: Fold_Map_Any$1,
    Fold_Map_Plus: Fold_Map_Plus$1,
    traverse: traverse,
    sequence: sequence
  };
  var traversable = Curry._2(T.suite, "Default.Traversable", {
        hd: Curry._2(T.test, "should traverse the list", (function (param) {
                var positive_int = function (x) {
                  if (x >= 0) {
                    return x;
                  }
                  
                };
                Curry._4(T.check, Curry._1(T.option, Curry._1(T.list, T.$$int)), undefined, Curry._2(traverse, positive_int, {
                          hd: 1,
                          tl: {
                            hd: 2,
                            tl: {
                              hd: 3,
                              tl: /* [] */0
                            }
                          }
                        }), {
                      hd: 1,
                      tl: {
                        hd: 2,
                        tl: {
                          hd: 3,
                          tl: /* [] */0
                        }
                      }
                    });
              })),
        tl: /* [] */0
      });
  var suites_1 = {
    hd: traversable,
    tl: /* [] */0
  };
  var suites = {
    hd: foldable,
    tl: suites_1
  };
  return {
          Foldable: Foldable,
          Traversable: Traversable,
          foldable: foldable,
          Traverse: Traverse,
          traversable: traversable,
          suites: suites
        };
}

function Float(E, T, Q, A) {
  var $less$dot = Bastet__Function.Infix.$less$dot;
  var Medial_Magma = function (M, E, A) {
    var V = Bastet__Verify.Compare.Medial_Magma(M, E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Medial_Magma", {
                  hd: Curry._7(Q.property4, undefined, "should satisfy bicommutativity", A.make, A.make, A.make, A.make, V.bicommutativity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Quasigroup = function (QG, E, A) {
    var V = Bastet__Verify.Compare.Quasigroup(QG, E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Quasigroup", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.cancellative),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Semiring = function (S, E, A) {
    var V = Bastet__Verify.Compare.Semiring(S, E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Semiring", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy additive associativity", A.make, A.make, A.make, V.additive_associativity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy additive identity", A.make, V.additive_identity),
                    tl: {
                      hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V.commutativity),
                      tl: {
                        hd: Curry._6(Q.property3, undefined, "should satisfy multiplicative associativity", A.make, A.make, A.make, V.multiplicative_associativity),
                        tl: {
                          hd: Curry._4(Q.property, undefined, "should satisfy multiplicative identity", A.make, V.multiplicative_identity),
                          tl: {
                            hd: Curry._6(Q.property3, undefined, "should satisfy distributivity", A.make, A.make, A.make, V.distributivity),
                            tl: /* [] */0
                          }
                        }
                      }
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Division_Ring = function (D, E, A) {
    var V = Bastet__Verify.Compare.Division_Ring(D, E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Division_Ring", {
                  hd: Curry._2(T.test, "should be a non-zero ring (zero is not one)", (function (param) {
                          Curry._4(T.check, T.bool, undefined, V.non_zero_ring, true);
                        })),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy multiplicative inverse", A.make, V.multiplicative_inverse),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Euclidean_Ring = function (E, EQ, A) {
    var V = Bastet__Verify.Compare.Euclidean_Ring(E, EQ);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Euclidean_Ring", {
                  hd: Curry._2(T.test, "should be a non-zero ring (zero is not one)", (function (param) {
                          Curry._4(T.check, T.bool, undefined, V.non_zero_ring, true);
                        })),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy integral domain", A.make, A.make, V.integral_domain),
                    tl: {
                      hd: Curry._4(Q.property, undefined, "should satisfy non negative degree", A.make, V.non_negative_degree),
                      tl: {
                        hd: Curry._5(Q.property2, undefined, "should satisfy the properties for remainder", A.make, A.make, V.remainder),
                        tl: {
                          hd: Curry._5(Q.property2, undefined, "should satisfy submultiplicative", A.make, A.make, V.submultiplicative),
                          tl: /* [] */0
                        }
                      }
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Compare = {
    Medial_Magma: Medial_Magma,
    Quasigroup: Quasigroup,
    Semiring: Semiring,
    Division_Ring: Division_Ring,
    Euclidean_Ring: Euclidean_Ring
  };
  var Medial_Magma$1 = function (M, A) {
    var V = Bastet__Verify.Medial_Magma(M);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Medial_Magma", {
                  hd: Curry._7(Q.property4, undefined, "should satisfy bicommutativity", A.make, A.make, A.make, A.make, V.bicommutativity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Semigroup = function (S, A) {
    var V = Bastet__Verify.Semigroup(S);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Semigroup", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.associativity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Quasigroup$1 = function (QG, A) {
    var V = Bastet__Verify.Quasigroup(QG);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Quasigroup", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.cancellative),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Loop = function (L, A) {
    var V = Bastet__Verify.Loop(L);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Loop", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V.identity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Group = function (G, A) {
    var V = Bastet__Verify.Group(G);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Group", {
                  hd: Curry._4(Q.property, undefined, "should satisfy invertibility", A.make, V.invertibility),
                  tl: {
                    hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.associativity),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Abelian_Group = function (G, A) {
    var V = Bastet__Verify.Abelian_Group(G);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Abelian_Group", {
                  hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V.commutativity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Monoid = function (M, A) {
    var V = Bastet__Verify.Monoid(M);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Monoid", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V.identity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Functor = function (F, AA) {
    var V = Bastet__Verify.Functor(F);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Functor", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", Curry._1(AA.make, Q.arbitrary_int), V.identity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy composition", Curry._1(AA.make, Q.arbitrary_int), (function (a) {
                            return Curry._3(V.composition, (function (param) {
                                          return "!" + param;
                                        }), (function (prim) {
                                          return String(prim);
                                        }), a);
                          })),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Apply = function (A, AA) {
    var V = Bastet__Verify.Apply(A);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Apply", {
                  hd: Curry._4(Q.property, undefined, "should satisfy associative composition", Curry._1(AA.make, Q.arbitrary_int), (function (n) {
                          return Curry._3(V.associative_composition, Curry._1(A.pure, (function (param) {
                                            return "!" + param;
                                          })), Curry._1(A.pure, (function (prim) {
                                            return String(prim);
                                          })), n);
                        })),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Applicative = function (A, AA) {
    var V = Bastet__Verify.Applicative(A);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Applicative", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", Curry._1(AA.make, Q.arbitrary_int), V.identity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy homomorphism", Curry._1(AA.make, Q.arbitrary_int), Curry._1(V.homomorphism, Curry._1(A.map, (function (prim) {
                                    return String(prim);
                                  })))),
                    tl: {
                      hd: Curry._4(Q.property, undefined, "should satisfy interchange", Q.arbitrary_int, Curry._1(V.interchange, Curry._1(A.pure, (function (prim) {
                                      return String(prim);
                                    })))),
                      tl: /* [] */0
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Monad = function (M, AA) {
    var V = Bastet__Verify.Monad(M);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Monad", {
                  hd: Curry._4(Q.property, undefined, "should satisfy associativity", Curry._1(AA.make_bound, Q.arbitrary_int), Curry._2(V.associativity, Curry._2($less$dot, M.pure, (function (prim) {
                                  return String(prim);
                                })), Curry._2($less$dot, M.pure, (function (param) {
                                  return "!" + param;
                                })))),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy identity", Q.arbitrary_int, Curry._1(V.identity, Curry._2($less$dot, M.pure, (function (prim) {
                                    return String(prim);
                                  })))),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Alt = function (A, AA) {
    var V = Bastet__Verify.Alt(A);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Alt", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", Curry._1(AA.make, Q.arbitrary_int), Curry._1(AA.make, Q.arbitrary_int), Curry._1(AA.make, Q.arbitrary_int), V.associativity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy distributivity", Curry._1(AA.make, Q.arbitrary_int), Curry._1(AA.make, Q.arbitrary_int), Curry._1(V.distributivity, (function (prim) {
                                return String(prim);
                              }))),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Alternative = function (A, AA) {
    var V = Bastet__Verify.Alternative(A);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Alternative", {
                  hd: Curry._4(Q.property, undefined, "should satisfy distributivity", Curry._1(AA.make, Q.arbitrary_int), Curry._2(V.distributivity, Curry._1(A.pure, (function (param) {
                                  return (param << 1);
                                })), Curry._1(A.pure, (function (param) {
                                  return 3 + param | 0;
                                })))),
                  tl: {
                    hd: Curry._2(T.test, "should satisfy annihalation", (function (param) {
                            Curry._4(T.check, T.bool, undefined, Curry._1(V.annihalation, Curry._1(A.pure, (function (prim) {
                                            return String(prim);
                                          }))), true);
                          })),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Plus = function (P, AA) {
    var V = Bastet__Verify.Plus(P);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Plus", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", Curry._1(AA.make, Q.arbitrary_int), V.identity),
                  tl: {
                    hd: Curry._2(T.test, "should satisfy annihalation", (function (param) {
                            Curry._4(T.check, T.bool, undefined, Curry._1(V.annihalation, (function (prim) {
                                        return String(prim);
                                      })), true);
                          })),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Eq = function (E, A) {
    var V = Bastet__Verify.Eq(E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Eq", {
                  hd: Curry._4(Q.property, undefined, "should satisfy reflexivity", A.make, V.reflexivity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy symmetry", A.make, A.make, V.symmetry),
                    tl: {
                      hd: Curry._6(Q.property3, undefined, "should satisfy transitivity", A.make, A.make, A.make, V.transitivity),
                      tl: /* [] */0
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Ord = function (O, A) {
    var V = Bastet__Verify.Ord(O);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Ord", {
                  hd: Curry._4(Q.property, undefined, "should satisfy reflexivity", A.make, V.reflexivity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy antisymmetry", A.make, A.make, V.antisymmetry),
                    tl: {
                      hd: Curry._6(Q.property3, undefined, "should satisfy transitivity", A.make, A.make, A.make, V.transitivity),
                      tl: /* [] */0
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Join_Semilattice = function (JS, A) {
    var V = Bastet__Verify.Join_Semilattice(JS);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Join_Semilattice", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.associativity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V.commutativity),
                    tl: {
                      hd: Curry._4(Q.property, undefined, "should satisfy idempotency", A.make, V.idempotency),
                      tl: /* [] */0
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Meet_Semilattice = function (MS, A) {
    var V = Bastet__Verify.Meet_Semilattice(MS);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Meet_Semilattice", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.associativity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V.commutativity),
                    tl: {
                      hd: Curry._4(Q.property, undefined, "should satisfy idempotency", A.make, V.idempotency),
                      tl: /* [] */0
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Bounded_Join_Semilattice = function (BJS, A) {
    var V = Bastet__Verify.Bounded_Join_Semilattice(BJS);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Bounded_Join_Semilattice", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V.identity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Bounded_Meet_Semilattice = function (BMS, A) {
    var V = Bastet__Verify.Bounded_Meet_Semilattice(BMS);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Bounded_Meet_Semilattice", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V.identity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Lattice = function (L, A) {
    var V = Bastet__Verify.Lattice(L);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Lattice", {
                  hd: Curry._5(Q.property2, undefined, "should satisfy absorption", A.make, A.make, V.absorption),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Bounded_Lattice = function (BL, A) {
    var V = Bastet__Verify.Bounded_Lattice(BL);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Bounded_Lattice", {
                  hd: Curry._5(Q.property2, undefined, "should satisfy absorption", A.make, A.make, V.absorption),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Distributive_Lattice = function (DL, A) {
    var V = Bastet__Verify.Distributive_Lattice(DL);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Distributive_Lattice", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy distributivity", A.make, A.make, A.make, V.distributivity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Bounded_Distributive_Lattice = function (BDL, A) {
    var V = Bastet__Verify.Bounded_Distributive_Lattice(BDL);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Bounded_Distributive_Lattice", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy distributivity", A.make, A.make, A.make, V.distributivity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Heyting_Algebra = function (HA, A) {
    var V = Bastet__Verify.Heyting_Algebra(HA);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Heyting_Algebra", {
                  hd: Curry._4(Q.property, undefined, "should satisfy pseudocomplement", A.make, V.pseudocomplement),
                  tl: {
                    hd: Curry._6(Q.property3, undefined, "should satisfy relative pseudocomplement", A.make, A.make, A.make, V.relative_pseudocomplement),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Involutive_Heyting_Algebra = function (IHA, A) {
    var V = Bastet__Verify.Involutive_Heyting_Algebra(IHA);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Involutive_Heyting_Algebra", {
                  hd: Curry._4(Q.property, undefined, "should satisfy involution", A.make, V.involution),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Boolean_Algebra = function (BA, A) {
    var V = Bastet__Verify.Boolean_Algebra(BA);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Boolean_Algebra", {
                  hd: Curry._4(Q.property, undefined, "should satisfy the law of excluded middle", A.make, V.excluded_middle),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Bounded = function (B, A) {
    var V = Bastet__Verify.Bounded(B);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Bounded", {
                  hd: Curry._4(Q.property, undefined, "should satisfy bounded", A.make, V.bounded),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Semiring$1 = function (S, A) {
    var V = Bastet__Verify.Semiring(S);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Semiring", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy additive associativity", A.make, A.make, A.make, V.additive_associativity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy additive identity", A.make, V.additive_identity),
                    tl: {
                      hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V.commutativity),
                      tl: {
                        hd: Curry._6(Q.property3, undefined, "should satisfy multiplicative associativity", A.make, A.make, A.make, V.multiplicative_associativity),
                        tl: {
                          hd: Curry._4(Q.property, undefined, "should satisfy multiplicative identity", A.make, V.multiplicative_identity),
                          tl: {
                            hd: Curry._6(Q.property3, undefined, "should satisfy distributivity", A.make, A.make, A.make, V.distributivity),
                            tl: /* [] */0
                          }
                        }
                      }
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Ring = function (R, A) {
    var V = Bastet__Verify.Ring(R);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Ring", {
                  hd: Curry._4(Q.property, undefined, "should satisfy additive inverse", A.make, V.additive_inverse),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Commutative_Ring = function (C, A) {
    var V = Bastet__Verify.Commutative_Ring(C);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Commutative_Ring", {
                  hd: Curry._5(Q.property2, undefined, "should satisfy multiplicative commutativity", A.make, A.make, V.multiplicative_commutativity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Division_Ring$1 = function (D, A) {
    var V = Bastet__Verify.Division_Ring(D);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Division_Ring", {
                  hd: Curry._2(T.test, "should be a non-zero ring (zero is not one)", (function (param) {
                          Curry._4(T.check, T.bool, undefined, V.non_zero_ring, true);
                        })),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy multiplicative inverse", A.make, V.multiplicative_inverse),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Euclidean_Ring$1 = function (E, A) {
    var V = Bastet__Verify.Euclidean_Ring(E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Euclidean_Ring", {
                  hd: Curry._2(T.test, "should be a non-zero ring (zero is not one)", (function (param) {
                          Curry._4(T.check, T.bool, undefined, V.non_zero_ring, true);
                        })),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy integral domain", A.make, A.make, V.integral_domain),
                    tl: {
                      hd: Curry._4(Q.property, undefined, "should satisfy non negative degree", A.make, V.non_negative_degree),
                      tl: {
                        hd: Curry._5(Q.property2, undefined, "should satisfy the properties for remainder", A.make, A.make, V.remainder),
                        tl: {
                          hd: Curry._5(Q.property2, undefined, "should satisfy submultiplicative", A.make, A.make, V.submultiplicative),
                          tl: /* [] */0
                        }
                      }
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Field = function (F, A) {
    var V = Bastet__Verify.Field(F);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Field", {
                  hd: Curry._5(Q.property2, undefined, "should satisfy non zero multiplicative inverse", A.make, A.make, V.non_zero_multiplicative_inverse),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Invariant = function (I, AA) {
    var V = Bastet__Verify.Invariant(I);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Invariant", {
                  hd: Curry._4(Q.property, undefined, "should satisfy reflexivity", Curry._1(AA.make, Q.arbitrary_int), V.identity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy composition", Curry._1(AA.make, Q.arbitrary_int), Curry._4(V.composition, (function (prim) {
                                return prim;
                              }), (function (prim) {
                                return prim | 0;
                              }), Curry._2($less$dot, (function (param) {
                                    return Math.imul(3, param);
                                  }), (function (prim) {
                                    return prim | 0;
                                  })), Curry._2($less$dot, (function (param) {
                                    return 4.0 * param;
                                  }), (function (prim) {
                                    return prim;
                                  })))),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var M = {
    $less$dot: $less$dot,
    Compare: Compare,
    Medial_Magma: Medial_Magma$1,
    Semigroup: Semigroup,
    Quasigroup: Quasigroup$1,
    Loop: Loop,
    Group: Group,
    Abelian_Group: Abelian_Group,
    Monoid: Monoid,
    Functor: Functor,
    Apply: Apply,
    Applicative: Applicative,
    Monad: Monad,
    Alt: Alt,
    Alternative: Alternative,
    Plus: Plus,
    Eq: Eq,
    Ord: Ord,
    Join_Semilattice: Join_Semilattice,
    Meet_Semilattice: Meet_Semilattice,
    Bounded_Join_Semilattice: Bounded_Join_Semilattice,
    Bounded_Meet_Semilattice: Bounded_Meet_Semilattice,
    Lattice: Lattice,
    Bounded_Lattice: Bounded_Lattice,
    Distributive_Lattice: Distributive_Lattice,
    Bounded_Distributive_Lattice: Bounded_Distributive_Lattice,
    Heyting_Algebra: Heyting_Algebra,
    Involutive_Heyting_Algebra: Involutive_Heyting_Algebra,
    Boolean_Algebra: Boolean_Algebra,
    Bounded: Bounded,
    Semiring: Semiring$1,
    Ring: Ring,
    Commutative_Ring: Commutative_Ring,
    Division_Ring: Division_Ring$1,
    Euclidean_Ring: Euclidean_Ring$1,
    Field: Field,
    Invariant: Invariant
  };
  var M$1 = Bastet__Float.Additive.Medial_Magma;
  var V = Bastet__Verify.Compare.Medial_Magma(M$1, E);
  var suite = function (name) {
    return Curry._2(T.suite, name + ".Medial_Magma", {
                hd: Curry._7(Q.property4, undefined, "should satisfy bicommutativity", A.make, A.make, A.make, A.make, V.bicommutativity),
                tl: /* [] */0
              });
  };
  var Medial_Magma$2 = {
    V: V,
    suite: suite
  };
  var S = Bastet__Float.Additive.Semigroup;
  var V$1 = Bastet__Verify.Semigroup(S);
  var suite$1 = function (name) {
    return Curry._2(T.suite, name + ".Semigroup", {
                hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V$1.associativity),
                tl: /* [] */0
              });
  };
  var Semigroup$1 = {
    V: V$1,
    suite: suite$1
  };
  var M$2 = Bastet__Float.Additive.Monoid;
  var V$2 = Bastet__Verify.Monoid(M$2);
  var suite$2 = function (name) {
    return Curry._2(T.suite, name + ".Monoid", {
                hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V$2.identity),
                tl: /* [] */0
              });
  };
  var Monoid$1 = {
    V: V$2,
    suite: suite$2
  };
  var QG = Bastet__Float.Additive.Quasigroup;
  var V$3 = Bastet__Verify.Quasigroup(QG);
  var suite$3 = function (name) {
    return Curry._2(T.suite, name + ".Quasigroup", {
                hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V$3.cancellative),
                tl: /* [] */0
              });
  };
  var Quasigroup$2 = {
    V: V$3,
    suite: suite$3
  };
  var L = Bastet__Float.Additive.Loop;
  var V$4 = Bastet__Verify.Loop(L);
  var suite$4 = function (name) {
    return Curry._2(T.suite, name + ".Loop", {
                hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V$4.identity),
                tl: /* [] */0
              });
  };
  var Loop$1 = {
    V: V$4,
    suite: suite$4
  };
  var G = Bastet__Float.Additive.Group;
  var V$5 = Bastet__Verify.Group(G);
  var suite$5 = function (name) {
    return Curry._2(T.suite, name + ".Group", {
                hd: Curry._4(Q.property, undefined, "should satisfy invertibility", A.make, V$5.invertibility),
                tl: {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V$5.associativity),
                  tl: /* [] */0
                }
              });
  };
  var Group$1 = {
    V: V$5,
    suite: suite$5
  };
  var G$1 = Bastet__Float.Additive.Abelian_Group;
  var V$6 = Bastet__Verify.Abelian_Group(G$1);
  var suite$6 = function (name) {
    return Curry._2(T.suite, name + ".Abelian_Group", {
                hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V$6.commutativity),
                tl: /* [] */0
              });
  };
  var Abelian_Group$1 = {
    V: V$6,
    suite: suite$6
  };
  var Additive = {
    Medial_Magma: Medial_Magma$2,
    Semigroup: Semigroup$1,
    Monoid: Monoid$1,
    Quasigroup: Quasigroup$2,
    Loop: Loop$1,
    Group: Group$1,
    Abelian_Group: Abelian_Group$1
  };
  var M$3 = Bastet__Float.Multiplicative.Medial_Magma;
  var V$7 = Bastet__Verify.Compare.Medial_Magma(M$3, E);
  var suite$7 = function (name) {
    return Curry._2(T.suite, name + ".Medial_Magma", {
                hd: Curry._7(Q.property4, undefined, "should satisfy bicommutativity", A.make, A.make, A.make, A.make, V$7.bicommutativity),
                tl: /* [] */0
              });
  };
  var Medial_Magma$3 = {
    V: V$7,
    suite: suite$7
  };
  var S$1 = Bastet__Float.Multiplicative.Semigroup;
  var V$8 = Bastet__Verify.Semigroup(S$1);
  var suite$8 = function (name) {
    return Curry._2(T.suite, name + ".Semigroup", {
                hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V$8.associativity),
                tl: /* [] */0
              });
  };
  var Semigroup$2 = {
    V: V$8,
    suite: suite$8
  };
  var M$4 = Bastet__Float.Multiplicative.Monoid;
  var V$9 = Bastet__Verify.Monoid(M$4);
  var suite$9 = function (name) {
    return Curry._2(T.suite, name + ".Monoid", {
                hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V$9.identity),
                tl: /* [] */0
              });
  };
  var Monoid$2 = {
    V: V$9,
    suite: suite$9
  };
  var QG$1 = Bastet__Float.Multiplicative.Quasigroup;
  var V$10 = Bastet__Verify.Compare.Quasigroup(QG$1, E);
  var suite$10 = function (name) {
    return Curry._2(T.suite, name + ".Quasigroup", {
                hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V$10.cancellative),
                tl: /* [] */0
              });
  };
  var Quasigroup$3 = {
    V: V$10,
    suite: suite$10
  };
  var L$1 = Bastet__Float.Multiplicative.Loop;
  var V$11 = Bastet__Verify.Loop(L$1);
  var suite$11 = function (name) {
    return Curry._2(T.suite, name + ".Loop", {
                hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V$11.identity),
                tl: /* [] */0
              });
  };
  var Loop$2 = {
    V: V$11,
    suite: suite$11
  };
  var Multiplicative = {
    Medial_Magma: Medial_Magma$3,
    Semigroup: Semigroup$2,
    Monoid: Monoid$2,
    Quasigroup: Quasigroup$3,
    Loop: Loop$2
  };
  var M$5 = Bastet__Float.Subtractive.Medial_Magma;
  var V$12 = Bastet__Verify.Compare.Medial_Magma(M$5, E);
  var suite$12 = function (name) {
    return Curry._2(T.suite, name + ".Medial_Magma", {
                hd: Curry._7(Q.property4, undefined, "should satisfy bicommutativity", A.make, A.make, A.make, A.make, V$12.bicommutativity),
                tl: /* [] */0
              });
  };
  var Medial_Magma$4 = {
    V: V$12,
    suite: suite$12
  };
  var QG$2 = Bastet__Float.Subtractive.Quasigroup;
  var V$13 = Bastet__Verify.Compare.Quasigroup(QG$2, E);
  var suite$13 = function (name) {
    return Curry._2(T.suite, name + ".Quasigroup", {
                hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V$13.cancellative),
                tl: /* [] */0
              });
  };
  var Quasigroup$4 = {
    V: V$13,
    suite: suite$13
  };
  var Subtractive = {
    Medial_Magma: Medial_Magma$4,
    Quasigroup: Quasigroup$4
  };
  var M$6 = Bastet__Float.Divisive.Medial_Magma;
  var V$14 = Bastet__Verify.Compare.Medial_Magma(M$6, E);
  var suite$14 = function (name) {
    return Curry._2(T.suite, name + ".Medial_Magma", {
                hd: Curry._7(Q.property4, undefined, "should satisfy bicommutativity", A.make, A.make, A.make, A.make, V$14.bicommutativity),
                tl: /* [] */0
              });
  };
  var Medial_Magma$5 = {
    V: V$14,
    suite: suite$14
  };
  var QG$3 = Bastet__Float.Divisive.Quasigroup;
  var V$15 = Bastet__Verify.Compare.Quasigroup(QG$3, E);
  var suite$15 = function (name) {
    return Curry._2(T.suite, name + ".Quasigroup", {
                hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V$15.cancellative),
                tl: /* [] */0
              });
  };
  var Quasigroup$5 = {
    V: V$15,
    suite: suite$15
  };
  var Divisive = {
    Medial_Magma: Medial_Magma$5,
    Quasigroup: Quasigroup$5
  };
  var E$1 = Bastet__Float.Eq;
  var V$16 = Bastet__Verify.Eq(E$1);
  var suite$16 = function (name) {
    return Curry._2(T.suite, name + ".Eq", {
                hd: Curry._4(Q.property, undefined, "should satisfy reflexivity", A.make, V$16.reflexivity),
                tl: {
                  hd: Curry._5(Q.property2, undefined, "should satisfy symmetry", A.make, A.make, V$16.symmetry),
                  tl: {
                    hd: Curry._6(Q.property3, undefined, "should satisfy transitivity", A.make, A.make, A.make, V$16.transitivity),
                    tl: /* [] */0
                  }
                }
              });
  };
  var Eq$1 = {
    V: V$16,
    suite: suite$16
  };
  var O = Bastet__Float.Ord;
  var V$17 = Bastet__Verify.Ord(O);
  var suite$17 = function (name) {
    return Curry._2(T.suite, name + ".Ord", {
                hd: Curry._4(Q.property, undefined, "should satisfy reflexivity", A.make, V$17.reflexivity),
                tl: {
                  hd: Curry._5(Q.property2, undefined, "should satisfy antisymmetry", A.make, A.make, V$17.antisymmetry),
                  tl: {
                    hd: Curry._6(Q.property3, undefined, "should satisfy transitivity", A.make, A.make, A.make, V$17.transitivity),
                    tl: /* [] */0
                  }
                }
              });
  };
  var Ord$1 = {
    V: V$17,
    suite: suite$17
  };
  var B = Bastet__Float.Bounded;
  var V$18 = Bastet__Verify.Bounded(B);
  var suite$18 = function (name) {
    return Curry._2(T.suite, name + ".Bounded", {
                hd: Curry._4(Q.property, undefined, "should satisfy bounded", A.make, V$18.bounded),
                tl: /* [] */0
              });
  };
  var Bounded$1 = {
    V: V$18,
    suite: suite$18
  };
  var S$2 = Bastet__Float.Semiring;
  var V$19 = Bastet__Verify.Compare.Semiring(S$2, E);
  var suite$19 = function (name) {
    return Curry._2(T.suite, name + ".Semiring", {
                hd: Curry._6(Q.property3, undefined, "should satisfy additive associativity", A.make, A.make, A.make, V$19.additive_associativity),
                tl: {
                  hd: Curry._4(Q.property, undefined, "should satisfy additive identity", A.make, V$19.additive_identity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V$19.commutativity),
                    tl: {
                      hd: Curry._6(Q.property3, undefined, "should satisfy multiplicative associativity", A.make, A.make, A.make, V$19.multiplicative_associativity),
                      tl: {
                        hd: Curry._4(Q.property, undefined, "should satisfy multiplicative identity", A.make, V$19.multiplicative_identity),
                        tl: {
                          hd: Curry._6(Q.property3, undefined, "should satisfy distributivity", A.make, A.make, A.make, V$19.distributivity),
                          tl: /* [] */0
                        }
                      }
                    }
                  }
                }
              });
  };
  var Semiring$2 = {
    V: V$19,
    suite: suite$19
  };
  var R = Bastet__Float.Ring;
  var V$20 = Bastet__Verify.Ring(R);
  var suite$20 = function (name) {
    return Curry._2(T.suite, name + ".Ring", {
                hd: Curry._4(Q.property, undefined, "should satisfy additive inverse", A.make, V$20.additive_inverse),
                tl: /* [] */0
              });
  };
  var Ring$1 = {
    V: V$20,
    suite: suite$20
  };
  var C = Bastet__Float.Commutative_Ring;
  var V$21 = Bastet__Verify.Commutative_Ring(C);
  var suite$21 = function (name) {
    return Curry._2(T.suite, name + ".Commutative_Ring", {
                hd: Curry._5(Q.property2, undefined, "should satisfy multiplicative commutativity", A.make, A.make, V$21.multiplicative_commutativity),
                tl: /* [] */0
              });
  };
  var Commutative_Ring$1 = {
    V: V$21,
    suite: suite$21
  };
  var D = Bastet__Float.Division_Ring;
  var V$22 = Bastet__Verify.Compare.Division_Ring(D, E);
  var suite$22 = function (name) {
    return Curry._2(T.suite, name + ".Division_Ring", {
                hd: Curry._2(T.test, "should be a non-zero ring (zero is not one)", (function (param) {
                        Curry._4(T.check, T.bool, undefined, V$22.non_zero_ring, true);
                      })),
                tl: {
                  hd: Curry._4(Q.property, undefined, "should satisfy multiplicative inverse", A.make, V$22.multiplicative_inverse),
                  tl: /* [] */0
                }
              });
  };
  var Division_Ring$2 = {
    V: V$22,
    suite: suite$22
  };
  var E$2 = Bastet__Float.Euclidean_Ring;
  var V$23 = Bastet__Verify.Compare.Euclidean_Ring(E$2, E);
  var suite$23 = function (name) {
    return Curry._2(T.suite, name + ".Euclidean_Ring", {
                hd: Curry._2(T.test, "should be a non-zero ring (zero is not one)", (function (param) {
                        Curry._4(T.check, T.bool, undefined, V$23.non_zero_ring, true);
                      })),
                tl: {
                  hd: Curry._5(Q.property2, undefined, "should satisfy integral domain", A.make, A.make, V$23.integral_domain),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy non negative degree", A.make, V$23.non_negative_degree),
                    tl: {
                      hd: Curry._5(Q.property2, undefined, "should satisfy the properties for remainder", A.make, A.make, V$23.remainder),
                      tl: {
                        hd: Curry._5(Q.property2, undefined, "should satisfy submultiplicative", A.make, A.make, V$23.submultiplicative),
                        tl: /* [] */0
                      }
                    }
                  }
                }
              });
  };
  var Euclidean_Ring$2 = {
    V: V$23,
    suite: suite$23
  };
  var F = Bastet__Float.Field;
  var V$24 = Bastet__Verify.Field(F);
  var suite$24 = function (name) {
    return Curry._2(T.suite, name + ".Field", {
                hd: Curry._5(Q.property2, undefined, "should satisfy non zero multiplicative inverse", A.make, A.make, V$24.non_zero_multiplicative_inverse),
                tl: /* [] */0
              });
  };
  var Field$1 = {
    V: V$24,
    suite: suite$24
  };
  var suites = Stdlib__ListLabels.concat({
        hd: Stdlib__ListLabels.map((function (suite) {
                return Curry._1(suite, "Float.Additive");
              }), {
              hd: suite,
              tl: {
                hd: suite$1,
                tl: {
                  hd: suite$2,
                  tl: {
                    hd: suite$3,
                    tl: {
                      hd: suite$4,
                      tl: {
                        hd: suite$5,
                        tl: {
                          hd: suite$6,
                          tl: /* [] */0
                        }
                      }
                    }
                  }
                }
              }
            }),
        tl: {
          hd: Stdlib__ListLabels.map((function (suite) {
                  return Curry._1(suite, "Float.Multiplicative");
                }), {
                hd: suite$7,
                tl: {
                  hd: suite$8,
                  tl: {
                    hd: suite$9,
                    tl: {
                      hd: suite$10,
                      tl: {
                        hd: suite$11,
                        tl: /* [] */0
                      }
                    }
                  }
                }
              }),
          tl: {
            hd: Stdlib__ListLabels.map((function (suite) {
                    return Curry._1(suite, "Float.Subtractive");
                  }), {
                  hd: suite$12,
                  tl: {
                    hd: suite$13,
                    tl: /* [] */0
                  }
                }),
            tl: {
              hd: Stdlib__ListLabels.map((function (suite) {
                      return Curry._1(suite, "Float.Divisive");
                    }), {
                    hd: suite$14,
                    tl: {
                      hd: suite$15,
                      tl: /* [] */0
                    }
                  }),
              tl: {
                hd: Stdlib__ListLabels.map((function (suite) {
                        return Curry._1(suite, "Float");
                      }), {
                      hd: suite$16,
                      tl: {
                        hd: suite$17,
                        tl: {
                          hd: suite$18,
                          tl: {
                            hd: suite$19,
                            tl: {
                              hd: suite$20,
                              tl: {
                                hd: suite$21,
                                tl: {
                                  hd: suite$22,
                                  tl: {
                                    hd: suite$23,
                                    tl: {
                                      hd: suite$24,
                                      tl: /* [] */0
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }
                      }
                    }),
                tl: /* [] */0
              }
            }
          }
        }
      });
  return {
          M: M,
          Additive: Additive,
          Multiplicative: Multiplicative,
          Subtractive: Subtractive,
          Divisive: Divisive,
          Eq: Eq$1,
          Ord: Ord$1,
          Bounded: Bounded$1,
          Semiring: Semiring$2,
          Ring: Ring$1,
          Commutative_Ring: Commutative_Ring$1,
          Division_Ring: Division_Ring$2,
          Euclidean_Ring: Euclidean_Ring$2,
          Field: Field$1,
          suites: suites
        };
}

function List(T, Q, A, AA) {
  var $less$dot = Bastet__Function.Infix.$less$dot;
  var Medial_Magma = function (M, E, A) {
    var V = Bastet__Verify.Compare.Medial_Magma(M, E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Medial_Magma", {
                  hd: Curry._7(Q.property4, undefined, "should satisfy bicommutativity", A.make, A.make, A.make, A.make, V.bicommutativity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Quasigroup = function (QG, E, A) {
    var V = Bastet__Verify.Compare.Quasigroup(QG, E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Quasigroup", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.cancellative),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Semiring = function (S, E, A) {
    var V = Bastet__Verify.Compare.Semiring(S, E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Semiring", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy additive associativity", A.make, A.make, A.make, V.additive_associativity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy additive identity", A.make, V.additive_identity),
                    tl: {
                      hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V.commutativity),
                      tl: {
                        hd: Curry._6(Q.property3, undefined, "should satisfy multiplicative associativity", A.make, A.make, A.make, V.multiplicative_associativity),
                        tl: {
                          hd: Curry._4(Q.property, undefined, "should satisfy multiplicative identity", A.make, V.multiplicative_identity),
                          tl: {
                            hd: Curry._6(Q.property3, undefined, "should satisfy distributivity", A.make, A.make, A.make, V.distributivity),
                            tl: /* [] */0
                          }
                        }
                      }
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Division_Ring = function (D, E, A) {
    var V = Bastet__Verify.Compare.Division_Ring(D, E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Division_Ring", {
                  hd: Curry._2(T.test, "should be a non-zero ring (zero is not one)", (function (param) {
                          Curry._4(T.check, T.bool, undefined, V.non_zero_ring, true);
                        })),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy multiplicative inverse", A.make, V.multiplicative_inverse),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Euclidean_Ring = function (E, EQ, A) {
    var V = Bastet__Verify.Compare.Euclidean_Ring(E, EQ);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Euclidean_Ring", {
                  hd: Curry._2(T.test, "should be a non-zero ring (zero is not one)", (function (param) {
                          Curry._4(T.check, T.bool, undefined, V.non_zero_ring, true);
                        })),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy integral domain", A.make, A.make, V.integral_domain),
                    tl: {
                      hd: Curry._4(Q.property, undefined, "should satisfy non negative degree", A.make, V.non_negative_degree),
                      tl: {
                        hd: Curry._5(Q.property2, undefined, "should satisfy the properties for remainder", A.make, A.make, V.remainder),
                        tl: {
                          hd: Curry._5(Q.property2, undefined, "should satisfy submultiplicative", A.make, A.make, V.submultiplicative),
                          tl: /* [] */0
                        }
                      }
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Compare = {
    Medial_Magma: Medial_Magma,
    Quasigroup: Quasigroup,
    Semiring: Semiring,
    Division_Ring: Division_Ring,
    Euclidean_Ring: Euclidean_Ring
  };
  var Medial_Magma$1 = function (M, A) {
    var V = Bastet__Verify.Medial_Magma(M);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Medial_Magma", {
                  hd: Curry._7(Q.property4, undefined, "should satisfy bicommutativity", A.make, A.make, A.make, A.make, V.bicommutativity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Semigroup = function (S, A) {
    var V = Bastet__Verify.Semigroup(S);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Semigroup", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.associativity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Quasigroup$1 = function (QG, A) {
    var V = Bastet__Verify.Quasigroup(QG);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Quasigroup", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.cancellative),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Loop = function (L, A) {
    var V = Bastet__Verify.Loop(L);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Loop", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V.identity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Group = function (G, A) {
    var V = Bastet__Verify.Group(G);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Group", {
                  hd: Curry._4(Q.property, undefined, "should satisfy invertibility", A.make, V.invertibility),
                  tl: {
                    hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.associativity),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Abelian_Group = function (G, A) {
    var V = Bastet__Verify.Abelian_Group(G);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Abelian_Group", {
                  hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V.commutativity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Monoid = function (M, A) {
    var V = Bastet__Verify.Monoid(M);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Monoid", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V.identity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Functor = function (F, AA) {
    var V = Bastet__Verify.Functor(F);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Functor", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", Curry._1(AA.make, Q.arbitrary_int), V.identity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy composition", Curry._1(AA.make, Q.arbitrary_int), (function (a) {
                            return Curry._3(V.composition, (function (param) {
                                          return "!" + param;
                                        }), (function (prim) {
                                          return String(prim);
                                        }), a);
                          })),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Apply = function (A, AA) {
    var V = Bastet__Verify.Apply(A);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Apply", {
                  hd: Curry._4(Q.property, undefined, "should satisfy associative composition", Curry._1(AA.make, Q.arbitrary_int), (function (n) {
                          return Curry._3(V.associative_composition, Curry._1(A.pure, (function (param) {
                                            return "!" + param;
                                          })), Curry._1(A.pure, (function (prim) {
                                            return String(prim);
                                          })), n);
                        })),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Applicative = function (A, AA) {
    var V = Bastet__Verify.Applicative(A);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Applicative", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", Curry._1(AA.make, Q.arbitrary_int), V.identity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy homomorphism", Curry._1(AA.make, Q.arbitrary_int), Curry._1(V.homomorphism, Curry._1(A.map, (function (prim) {
                                    return String(prim);
                                  })))),
                    tl: {
                      hd: Curry._4(Q.property, undefined, "should satisfy interchange", Q.arbitrary_int, Curry._1(V.interchange, Curry._1(A.pure, (function (prim) {
                                      return String(prim);
                                    })))),
                      tl: /* [] */0
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Monad = function (M, AA) {
    var V = Bastet__Verify.Monad(M);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Monad", {
                  hd: Curry._4(Q.property, undefined, "should satisfy associativity", Curry._1(AA.make_bound, Q.arbitrary_int), Curry._2(V.associativity, Curry._2($less$dot, M.pure, (function (prim) {
                                  return String(prim);
                                })), Curry._2($less$dot, M.pure, (function (param) {
                                  return "!" + param;
                                })))),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy identity", Q.arbitrary_int, Curry._1(V.identity, Curry._2($less$dot, M.pure, (function (prim) {
                                    return String(prim);
                                  })))),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Alt = function (A, AA) {
    var V = Bastet__Verify.Alt(A);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Alt", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", Curry._1(AA.make, Q.arbitrary_int), Curry._1(AA.make, Q.arbitrary_int), Curry._1(AA.make, Q.arbitrary_int), V.associativity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy distributivity", Curry._1(AA.make, Q.arbitrary_int), Curry._1(AA.make, Q.arbitrary_int), Curry._1(V.distributivity, (function (prim) {
                                return String(prim);
                              }))),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Alternative = function (A, AA) {
    var V = Bastet__Verify.Alternative(A);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Alternative", {
                  hd: Curry._4(Q.property, undefined, "should satisfy distributivity", Curry._1(AA.make, Q.arbitrary_int), Curry._2(V.distributivity, Curry._1(A.pure, (function (param) {
                                  return (param << 1);
                                })), Curry._1(A.pure, (function (param) {
                                  return 3 + param | 0;
                                })))),
                  tl: {
                    hd: Curry._2(T.test, "should satisfy annihalation", (function (param) {
                            Curry._4(T.check, T.bool, undefined, Curry._1(V.annihalation, Curry._1(A.pure, (function (prim) {
                                            return String(prim);
                                          }))), true);
                          })),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Plus = function (P, AA) {
    var V = Bastet__Verify.Plus(P);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Plus", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", Curry._1(AA.make, Q.arbitrary_int), V.identity),
                  tl: {
                    hd: Curry._2(T.test, "should satisfy annihalation", (function (param) {
                            Curry._4(T.check, T.bool, undefined, Curry._1(V.annihalation, (function (prim) {
                                        return String(prim);
                                      })), true);
                          })),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Eq = function (E, A) {
    var V = Bastet__Verify.Eq(E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Eq", {
                  hd: Curry._4(Q.property, undefined, "should satisfy reflexivity", A.make, V.reflexivity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy symmetry", A.make, A.make, V.symmetry),
                    tl: {
                      hd: Curry._6(Q.property3, undefined, "should satisfy transitivity", A.make, A.make, A.make, V.transitivity),
                      tl: /* [] */0
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Ord = function (O, A) {
    var V = Bastet__Verify.Ord(O);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Ord", {
                  hd: Curry._4(Q.property, undefined, "should satisfy reflexivity", A.make, V.reflexivity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy antisymmetry", A.make, A.make, V.antisymmetry),
                    tl: {
                      hd: Curry._6(Q.property3, undefined, "should satisfy transitivity", A.make, A.make, A.make, V.transitivity),
                      tl: /* [] */0
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Join_Semilattice = function (JS, A) {
    var V = Bastet__Verify.Join_Semilattice(JS);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Join_Semilattice", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.associativity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V.commutativity),
                    tl: {
                      hd: Curry._4(Q.property, undefined, "should satisfy idempotency", A.make, V.idempotency),
                      tl: /* [] */0
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Meet_Semilattice = function (MS, A) {
    var V = Bastet__Verify.Meet_Semilattice(MS);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Meet_Semilattice", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.associativity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V.commutativity),
                    tl: {
                      hd: Curry._4(Q.property, undefined, "should satisfy idempotency", A.make, V.idempotency),
                      tl: /* [] */0
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Bounded_Join_Semilattice = function (BJS, A) {
    var V = Bastet__Verify.Bounded_Join_Semilattice(BJS);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Bounded_Join_Semilattice", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V.identity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Bounded_Meet_Semilattice = function (BMS, A) {
    var V = Bastet__Verify.Bounded_Meet_Semilattice(BMS);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Bounded_Meet_Semilattice", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V.identity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Lattice = function (L, A) {
    var V = Bastet__Verify.Lattice(L);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Lattice", {
                  hd: Curry._5(Q.property2, undefined, "should satisfy absorption", A.make, A.make, V.absorption),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Bounded_Lattice = function (BL, A) {
    var V = Bastet__Verify.Bounded_Lattice(BL);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Bounded_Lattice", {
                  hd: Curry._5(Q.property2, undefined, "should satisfy absorption", A.make, A.make, V.absorption),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Distributive_Lattice = function (DL, A) {
    var V = Bastet__Verify.Distributive_Lattice(DL);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Distributive_Lattice", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy distributivity", A.make, A.make, A.make, V.distributivity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Bounded_Distributive_Lattice = function (BDL, A) {
    var V = Bastet__Verify.Bounded_Distributive_Lattice(BDL);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Bounded_Distributive_Lattice", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy distributivity", A.make, A.make, A.make, V.distributivity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Heyting_Algebra = function (HA, A) {
    var V = Bastet__Verify.Heyting_Algebra(HA);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Heyting_Algebra", {
                  hd: Curry._4(Q.property, undefined, "should satisfy pseudocomplement", A.make, V.pseudocomplement),
                  tl: {
                    hd: Curry._6(Q.property3, undefined, "should satisfy relative pseudocomplement", A.make, A.make, A.make, V.relative_pseudocomplement),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Involutive_Heyting_Algebra = function (IHA, A) {
    var V = Bastet__Verify.Involutive_Heyting_Algebra(IHA);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Involutive_Heyting_Algebra", {
                  hd: Curry._4(Q.property, undefined, "should satisfy involution", A.make, V.involution),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Boolean_Algebra = function (BA, A) {
    var V = Bastet__Verify.Boolean_Algebra(BA);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Boolean_Algebra", {
                  hd: Curry._4(Q.property, undefined, "should satisfy the law of excluded middle", A.make, V.excluded_middle),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Bounded = function (B, A) {
    var V = Bastet__Verify.Bounded(B);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Bounded", {
                  hd: Curry._4(Q.property, undefined, "should satisfy bounded", A.make, V.bounded),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Semiring$1 = function (S, A) {
    var V = Bastet__Verify.Semiring(S);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Semiring", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy additive associativity", A.make, A.make, A.make, V.additive_associativity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy additive identity", A.make, V.additive_identity),
                    tl: {
                      hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V.commutativity),
                      tl: {
                        hd: Curry._6(Q.property3, undefined, "should satisfy multiplicative associativity", A.make, A.make, A.make, V.multiplicative_associativity),
                        tl: {
                          hd: Curry._4(Q.property, undefined, "should satisfy multiplicative identity", A.make, V.multiplicative_identity),
                          tl: {
                            hd: Curry._6(Q.property3, undefined, "should satisfy distributivity", A.make, A.make, A.make, V.distributivity),
                            tl: /* [] */0
                          }
                        }
                      }
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Ring = function (R, A) {
    var V = Bastet__Verify.Ring(R);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Ring", {
                  hd: Curry._4(Q.property, undefined, "should satisfy additive inverse", A.make, V.additive_inverse),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Commutative_Ring = function (C, A) {
    var V = Bastet__Verify.Commutative_Ring(C);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Commutative_Ring", {
                  hd: Curry._5(Q.property2, undefined, "should satisfy multiplicative commutativity", A.make, A.make, V.multiplicative_commutativity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Division_Ring$1 = function (D, A) {
    var V = Bastet__Verify.Division_Ring(D);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Division_Ring", {
                  hd: Curry._2(T.test, "should be a non-zero ring (zero is not one)", (function (param) {
                          Curry._4(T.check, T.bool, undefined, V.non_zero_ring, true);
                        })),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy multiplicative inverse", A.make, V.multiplicative_inverse),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Euclidean_Ring$1 = function (E, A) {
    var V = Bastet__Verify.Euclidean_Ring(E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Euclidean_Ring", {
                  hd: Curry._2(T.test, "should be a non-zero ring (zero is not one)", (function (param) {
                          Curry._4(T.check, T.bool, undefined, V.non_zero_ring, true);
                        })),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy integral domain", A.make, A.make, V.integral_domain),
                    tl: {
                      hd: Curry._4(Q.property, undefined, "should satisfy non negative degree", A.make, V.non_negative_degree),
                      tl: {
                        hd: Curry._5(Q.property2, undefined, "should satisfy the properties for remainder", A.make, A.make, V.remainder),
                        tl: {
                          hd: Curry._5(Q.property2, undefined, "should satisfy submultiplicative", A.make, A.make, V.submultiplicative),
                          tl: /* [] */0
                        }
                      }
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Field = function (F, A) {
    var V = Bastet__Verify.Field(F);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Field", {
                  hd: Curry._5(Q.property2, undefined, "should satisfy non zero multiplicative inverse", A.make, A.make, V.non_zero_multiplicative_inverse),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Invariant = function (I, AA) {
    var V = Bastet__Verify.Invariant(I);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Invariant", {
                  hd: Curry._4(Q.property, undefined, "should satisfy reflexivity", Curry._1(AA.make, Q.arbitrary_int), V.identity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy composition", Curry._1(AA.make, Q.arbitrary_int), Curry._4(V.composition, (function (prim) {
                                return prim;
                              }), (function (prim) {
                                return prim | 0;
                              }), Curry._2($less$dot, (function (param) {
                                    return Math.imul(3, param);
                                  }), (function (prim) {
                                    return prim | 0;
                                  })), Curry._2($less$dot, (function (param) {
                                    return 4.0 * param;
                                  }), (function (prim) {
                                    return prim;
                                  })))),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var M = {
    $less$dot: $less$dot,
    Compare: Compare,
    Medial_Magma: Medial_Magma$1,
    Semigroup: Semigroup,
    Quasigroup: Quasigroup$1,
    Loop: Loop,
    Group: Group,
    Abelian_Group: Abelian_Group,
    Monoid: Monoid,
    Functor: Functor,
    Apply: Apply,
    Applicative: Applicative,
    Monad: Monad,
    Alt: Alt,
    Alternative: Alternative,
    Plus: Plus,
    Eq: Eq,
    Ord: Ord,
    Join_Semilattice: Join_Semilattice,
    Meet_Semilattice: Meet_Semilattice,
    Bounded_Join_Semilattice: Bounded_Join_Semilattice,
    Bounded_Meet_Semilattice: Bounded_Meet_Semilattice,
    Lattice: Lattice,
    Bounded_Lattice: Bounded_Lattice,
    Distributive_Lattice: Distributive_Lattice,
    Bounded_Distributive_Lattice: Bounded_Distributive_Lattice,
    Heyting_Algebra: Heyting_Algebra,
    Involutive_Heyting_Algebra: Involutive_Heyting_Algebra,
    Boolean_Algebra: Boolean_Algebra,
    Bounded: Bounded,
    Semiring: Semiring$1,
    Ring: Ring,
    Commutative_Ring: Commutative_Ring,
    Division_Ring: Division_Ring$1,
    Euclidean_Ring: Euclidean_Ring$1,
    Field: Field,
    Invariant: Invariant
  };
  var F = Bastet__List.Functor;
  var V = Bastet__Verify.Functor(F);
  var suite = function (name) {
    return Curry._2(T.suite, name + ".Functor", {
                hd: Curry._4(Q.property, undefined, "should satisfy identity", Curry._1(AA.make, Q.arbitrary_int), V.identity),
                tl: {
                  hd: Curry._4(Q.property, undefined, "should satisfy composition", Curry._1(AA.make, Q.arbitrary_int), (function (a) {
                          return Curry._3(V.composition, (function (param) {
                                        return "!" + param;
                                      }), (function (prim) {
                                        return String(prim);
                                      }), a);
                        })),
                  tl: /* [] */0
                }
              });
  };
  var Functor$1 = {
    V: V,
    suite: suite
  };
  var A$1 = Bastet__List.Applicative;
  var V$1 = Bastet__Verify.Apply(A$1);
  var suite$1 = function (name) {
    return Curry._2(T.suite, name + ".Apply", {
                hd: Curry._4(Q.property, undefined, "should satisfy associative composition", Curry._1(AA.make, Q.arbitrary_int), (function (n) {
                        return Curry._3(V$1.associative_composition, Curry._1(A$1.pure, (function (param) {
                                          return "!" + param;
                                        })), Curry._1(A$1.pure, (function (prim) {
                                          return String(prim);
                                        })), n);
                      })),
                tl: /* [] */0
              });
  };
  var Apply$1 = {
    V: V$1,
    suite: suite$1
  };
  var A$2 = Bastet__List.Applicative;
  var V$2 = Bastet__Verify.Applicative(A$2);
  var suite$2 = function (name) {
    return Curry._2(T.suite, name + ".Applicative", {
                hd: Curry._4(Q.property, undefined, "should satisfy identity", Curry._1(AA.make, Q.arbitrary_int), V$2.identity),
                tl: {
                  hd: Curry._4(Q.property, undefined, "should satisfy homomorphism", Curry._1(AA.make, Q.arbitrary_int), Curry._1(V$2.homomorphism, Curry._1(A$2.map, (function (prim) {
                                  return String(prim);
                                })))),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy interchange", Q.arbitrary_int, Curry._1(V$2.interchange, Curry._1(A$2.pure, (function (prim) {
                                    return String(prim);
                                  })))),
                    tl: /* [] */0
                  }
                }
              });
  };
  var Applicative$1 = {
    V: V$2,
    suite: suite$2
  };
  var M$1 = Bastet__List.Monad;
  var V$3 = Bastet__Verify.Monad(M$1);
  var suite$3 = function (name) {
    return Curry._2(T.suite, name + ".Monad", {
                hd: Curry._4(Q.property, undefined, "should satisfy associativity", Curry._1(AA.make_bound, Q.arbitrary_int), Curry._2(V$3.associativity, Curry._2($less$dot, M$1.pure, (function (prim) {
                                return String(prim);
                              })), Curry._2($less$dot, M$1.pure, (function (param) {
                                return "!" + param;
                              })))),
                tl: {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", Q.arbitrary_int, Curry._1(V$3.identity, Curry._2($less$dot, M$1.pure, (function (prim) {
                                  return String(prim);
                                })))),
                  tl: /* [] */0
                }
              });
  };
  var Monad$1 = {
    V: V$3,
    suite: suite$3
  };
  var A$3 = Bastet__List.Alt;
  var V$4 = Bastet__Verify.Alt(A$3);
  var suite$4 = function (name) {
    return Curry._2(T.suite, name + ".Alt", {
                hd: Curry._6(Q.property3, undefined, "should satisfy associativity", Curry._1(AA.make, Q.arbitrary_int), Curry._1(AA.make, Q.arbitrary_int), Curry._1(AA.make, Q.arbitrary_int), V$4.associativity),
                tl: {
                  hd: Curry._5(Q.property2, undefined, "should satisfy distributivity", Curry._1(AA.make, Q.arbitrary_int), Curry._1(AA.make, Q.arbitrary_int), Curry._1(V$4.distributivity, (function (prim) {
                              return String(prim);
                            }))),
                  tl: /* [] */0
                }
              });
  };
  var Alt$1 = {
    V: V$4,
    suite: suite$4
  };
  var E = Bastet__Functors.ListF.Int.Eq;
  var V$5 = Bastet__Verify.Eq(E);
  var suite$5 = function (name) {
    return Curry._2(T.suite, name + ".Eq", {
                hd: Curry._4(Q.property, undefined, "should satisfy reflexivity", A.make, V$5.reflexivity),
                tl: {
                  hd: Curry._5(Q.property2, undefined, "should satisfy symmetry", A.make, A.make, V$5.symmetry),
                  tl: {
                    hd: Curry._6(Q.property3, undefined, "should satisfy transitivity", A.make, A.make, A.make, V$5.transitivity),
                    tl: /* [] */0
                  }
                }
              });
  };
  var Eq$1 = {
    V: V$5,
    suite: suite$5
  };
  var foldable = Curry._2(T.suite, "List.Foldable", {
        hd: Curry._2(T.test, "should do a left fold", (function (param) {
                Curry._4(T.check, T.$$int, undefined, Bastet__List.Foldable.fold_left((function (prim0, prim1) {
                              return prim0 + prim1 | 0;
                            }), 0)({
                          hd: 1,
                          tl: {
                            hd: 2,
                            tl: {
                              hd: 3,
                              tl: {
                                hd: 4,
                                tl: {
                                  hd: 5,
                                  tl: /* [] */0
                                }
                              }
                            }
                          }
                        }), 15);
                Curry._4(T.check, T.$$int, undefined, Bastet__List.Foldable.fold_left((function (prim0, prim1) {
                              return prim0 - prim1 | 0;
                            }), 10)({
                          hd: 3,
                          tl: {
                            hd: 2,
                            tl: {
                              hd: 1,
                              tl: /* [] */0
                            }
                          }
                        }), 4);
              })),
        tl: {
          hd: Curry._2(T.test, "should do a right fold", (function (param) {
                  Curry._4(T.check, T.$$int, undefined, Bastet__List.Foldable.fold_right((function (prim0, prim1) {
                                return prim0 - prim1 | 0;
                              }), 10)({
                            hd: 3,
                            tl: {
                              hd: 2,
                              tl: {
                                hd: 1,
                                tl: /* [] */0
                              }
                            }
                          }), -8);
                })),
          tl: {
            hd: Curry._2(T.test, "should do a map fold (int)", (function (param) {
                    var fold_map = Bastet__Functors.ListF.Int.Additive.Fold_Map.fold_map;
                    Curry._4(T.check, T.$$int, undefined, Curry._2(fold_map, Bastet__Function.Category.id, {
                              hd: 1,
                              tl: {
                                hd: 2,
                                tl: {
                                  hd: 3,
                                  tl: /* [] */0
                                }
                              }
                            }), 6);
                  })),
            tl: {
              hd: Curry._2(T.test, "should do a map fold (list)", (function (param) {
                      var fold_map = Bastet__Functors.ListF.List.Fold_Map_Plus.fold_map;
                      Curry._4(T.check, Curry._1(T.list, Curry._1(T.list, T.$$int)), undefined, Curry._2(fold_map, Bastet__List.Applicative.pure, {
                                hd: {
                                  hd: 1,
                                  tl: {
                                    hd: 2,
                                    tl: {
                                      hd: 3,
                                      tl: /* [] */0
                                    }
                                  }
                                },
                                tl: {
                                  hd: {
                                    hd: 4,
                                    tl: {
                                      hd: 5,
                                      tl: /* [] */0
                                    }
                                  },
                                  tl: /* [] */0
                                }
                              }), {
                            hd: {
                              hd: 1,
                              tl: {
                                hd: 2,
                                tl: {
                                  hd: 3,
                                  tl: /* [] */0
                                }
                              }
                            },
                            tl: {
                              hd: {
                                hd: 4,
                                tl: {
                                  hd: 5,
                                  tl: /* [] */0
                                }
                              },
                              tl: /* [] */0
                            }
                          });
                    })),
              tl: /* [] */0
            }
          }
        }
      });
  var unfoldable = Curry._2(T.suite, "List.Unfoldable", {
        hd: Curry._2(T.test, "should do an unfold", (function (param) {
                Curry._4(T.check, Curry._1(T.list, T.$$int), undefined, Bastet__List.Unfoldable.unfold((function (x) {
                            if (x > 5) {
                              return ;
                            } else {
                              return [
                                      x,
                                      x + 1 | 0
                                    ];
                            }
                          }), 0), {
                      hd: 0,
                      tl: {
                        hd: 1,
                        tl: {
                          hd: 2,
                          tl: {
                            hd: 3,
                            tl: {
                              hd: 4,
                              tl: {
                                hd: 5,
                                tl: /* [] */0
                              }
                            }
                          }
                        }
                      }
                    });
              })),
        tl: {
          hd: Curry._2(T.test, "should do an unfold", (function (param) {
                  Curry._4(T.check, Curry._1(T.list, T.$$int), undefined, Bastet__List.Unfoldable.unfold((function (x) {
                              if (x > 20) {
                                return ;
                              } else {
                                return [
                                        x,
                                        x + 5 | 0
                                      ];
                              }
                            }), 0), {
                        hd: 0,
                        tl: {
                          hd: 5,
                          tl: {
                            hd: 10,
                            tl: {
                              hd: 15,
                              tl: {
                                hd: 20,
                                tl: /* [] */0
                              }
                            }
                          }
                        }
                      });
                })),
          tl: /* [] */0
        }
      });
  var traverse = Bastet__Functors.ListF.$$Option.Traversable.traverse;
  var sequence = Bastet__Functors.ListF.$$Option.Traversable.sequence;
  var traversable = Curry._2(T.suite, "List.Traversable", {
        hd: Curry._2(T.test, "should traverse the list", (function (param) {
                var positive_int = function (x) {
                  if (x >= 0) {
                    return x;
                  }
                  
                };
                Curry._4(T.check, Curry._1(T.option, Curry._1(T.list, T.$$int)), undefined, Curry._2(traverse, positive_int, {
                          hd: 1,
                          tl: {
                            hd: 2,
                            tl: {
                              hd: 3,
                              tl: /* [] */0
                            }
                          }
                        }), {
                      hd: 1,
                      tl: {
                        hd: 2,
                        tl: {
                          hd: 3,
                          tl: /* [] */0
                        }
                      }
                    });
                Curry._4(T.check, Curry._1(T.option, Curry._1(T.list, T.$$int)), undefined, Curry._2(traverse, positive_int, {
                          hd: 1,
                          tl: {
                            hd: 2,
                            tl: {
                              hd: -3,
                              tl: /* [] */0
                            }
                          }
                        }), undefined);
              })),
        tl: {
          hd: Curry._2(T.test, "should sequence the list", (function (param) {
                  Curry._4(T.check, Curry._1(T.option, Curry._1(T.list, T.$$int)), undefined, Curry._1(sequence, {
                            hd: 3,
                            tl: {
                              hd: 4,
                              tl: {
                                hd: 5,
                                tl: /* [] */0
                              }
                            }
                          }), {
                        hd: 3,
                        tl: {
                          hd: 4,
                          tl: {
                            hd: 5,
                            tl: /* [] */0
                          }
                        }
                      });
                  Curry._4(T.check, Curry._1(T.option, Curry._1(T.list, T.$$int)), undefined, Curry._1(sequence, {
                            hd: 3,
                            tl: {
                              hd: 4,
                              tl: {
                                hd: undefined,
                                tl: /* [] */0
                              }
                            }
                          }), undefined);
                })),
          tl: /* [] */0
        }
      });
  var S = Bastet__List.Show(Bastet__Int.Show);
  var show = Curry._2(T.suite, "List.Show", {
        hd: Curry._2(T.test, "should show the list", (function (param) {
                Curry._4(T.check, T.string, undefined, Curry._1(S.show, {
                          hd: 1,
                          tl: {
                            hd: 1,
                            tl: {
                              hd: 2,
                              tl: {
                                hd: 3,
                                tl: {
                                  hd: 5,
                                  tl: {
                                    hd: 8,
                                    tl: {
                                      hd: 13,
                                      tl: /* [] */0
                                    }
                                  }
                                }
                              }
                            }
                          }
                        }), "[1, 1, 2, 3, 5, 8, 13]");
              })),
        tl: /* [] */0
      });
  var alt_order = Curry._2(T.suite, "List.Alt.alt", {
        hd: Curry._2(T.test, "should order the lists correctly", (function (param) {
                Curry._4(T.check, Curry._1(T.list, T.$$int), undefined, Curry._2(Bastet__List.Alt.alt, {
                          hd: 1,
                          tl: {
                            hd: 2,
                            tl: {
                              hd: 3,
                              tl: /* [] */0
                            }
                          }
                        }, {
                          hd: 4,
                          tl: {
                            hd: 5,
                            tl: /* [] */0
                          }
                        }), {
                      hd: 1,
                      tl: {
                        hd: 2,
                        tl: {
                          hd: 3,
                          tl: {
                            hd: 4,
                            tl: {
                              hd: 5,
                              tl: /* [] */0
                            }
                          }
                        }
                      }
                    });
              })),
        tl: /* [] */0
      });
  var suites = Stdlib__ListLabels.append({
        hd: foldable,
        tl: {
          hd: unfoldable,
          tl: {
            hd: traversable,
            tl: {
              hd: show,
              tl: {
                hd: alt_order,
                tl: /* [] */0
              }
            }
          }
        }
      }, Stdlib__ListLabels.map((function (suite) {
              return Curry._1(suite, "List");
            }), {
            hd: suite,
            tl: {
              hd: suite$1,
              tl: {
                hd: suite$2,
                tl: {
                  hd: suite$3,
                  tl: {
                    hd: suite$4,
                    tl: {
                      hd: suite$5,
                      tl: /* [] */0
                    }
                  }
                }
              }
            }
          }));
  return {
          M: M,
          Functor: Functor$1,
          Apply: Apply$1,
          Applicative: Applicative$1,
          Monad: Monad$1,
          Alt: Alt$1,
          Eq: Eq$1,
          foldable: foldable,
          unfoldable: unfoldable,
          traversable: traversable,
          show: show,
          alt_order: alt_order,
          suites: suites
        };
}

function Int(T, Q, A) {
  var $less$dot = Bastet__Function.Infix.$less$dot;
  var Medial_Magma = function (M, E, A) {
    var V = Bastet__Verify.Compare.Medial_Magma(M, E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Medial_Magma", {
                  hd: Curry._7(Q.property4, undefined, "should satisfy bicommutativity", A.make, A.make, A.make, A.make, V.bicommutativity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Quasigroup = function (QG, E, A) {
    var V = Bastet__Verify.Compare.Quasigroup(QG, E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Quasigroup", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.cancellative),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Semiring = function (S, E, A) {
    var V = Bastet__Verify.Compare.Semiring(S, E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Semiring", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy additive associativity", A.make, A.make, A.make, V.additive_associativity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy additive identity", A.make, V.additive_identity),
                    tl: {
                      hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V.commutativity),
                      tl: {
                        hd: Curry._6(Q.property3, undefined, "should satisfy multiplicative associativity", A.make, A.make, A.make, V.multiplicative_associativity),
                        tl: {
                          hd: Curry._4(Q.property, undefined, "should satisfy multiplicative identity", A.make, V.multiplicative_identity),
                          tl: {
                            hd: Curry._6(Q.property3, undefined, "should satisfy distributivity", A.make, A.make, A.make, V.distributivity),
                            tl: /* [] */0
                          }
                        }
                      }
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Division_Ring = function (D, E, A) {
    var V = Bastet__Verify.Compare.Division_Ring(D, E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Division_Ring", {
                  hd: Curry._2(T.test, "should be a non-zero ring (zero is not one)", (function (param) {
                          Curry._4(T.check, T.bool, undefined, V.non_zero_ring, true);
                        })),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy multiplicative inverse", A.make, V.multiplicative_inverse),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Euclidean_Ring = function (E, EQ, A) {
    var V = Bastet__Verify.Compare.Euclidean_Ring(E, EQ);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Euclidean_Ring", {
                  hd: Curry._2(T.test, "should be a non-zero ring (zero is not one)", (function (param) {
                          Curry._4(T.check, T.bool, undefined, V.non_zero_ring, true);
                        })),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy integral domain", A.make, A.make, V.integral_domain),
                    tl: {
                      hd: Curry._4(Q.property, undefined, "should satisfy non negative degree", A.make, V.non_negative_degree),
                      tl: {
                        hd: Curry._5(Q.property2, undefined, "should satisfy the properties for remainder", A.make, A.make, V.remainder),
                        tl: {
                          hd: Curry._5(Q.property2, undefined, "should satisfy submultiplicative", A.make, A.make, V.submultiplicative),
                          tl: /* [] */0
                        }
                      }
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Compare = {
    Medial_Magma: Medial_Magma,
    Quasigroup: Quasigroup,
    Semiring: Semiring,
    Division_Ring: Division_Ring,
    Euclidean_Ring: Euclidean_Ring
  };
  var Medial_Magma$1 = function (M, A) {
    var V = Bastet__Verify.Medial_Magma(M);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Medial_Magma", {
                  hd: Curry._7(Q.property4, undefined, "should satisfy bicommutativity", A.make, A.make, A.make, A.make, V.bicommutativity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Semigroup = function (S, A) {
    var V = Bastet__Verify.Semigroup(S);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Semigroup", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.associativity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Quasigroup$1 = function (QG, A) {
    var V = Bastet__Verify.Quasigroup(QG);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Quasigroup", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.cancellative),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Loop = function (L, A) {
    var V = Bastet__Verify.Loop(L);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Loop", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V.identity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Group = function (G, A) {
    var V = Bastet__Verify.Group(G);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Group", {
                  hd: Curry._4(Q.property, undefined, "should satisfy invertibility", A.make, V.invertibility),
                  tl: {
                    hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.associativity),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Abelian_Group = function (G, A) {
    var V = Bastet__Verify.Abelian_Group(G);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Abelian_Group", {
                  hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V.commutativity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Monoid = function (M, A) {
    var V = Bastet__Verify.Monoid(M);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Monoid", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V.identity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Functor = function (F, AA) {
    var V = Bastet__Verify.Functor(F);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Functor", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", Curry._1(AA.make, Q.arbitrary_int), V.identity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy composition", Curry._1(AA.make, Q.arbitrary_int), (function (a) {
                            return Curry._3(V.composition, (function (param) {
                                          return "!" + param;
                                        }), (function (prim) {
                                          return String(prim);
                                        }), a);
                          })),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Apply = function (A, AA) {
    var V = Bastet__Verify.Apply(A);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Apply", {
                  hd: Curry._4(Q.property, undefined, "should satisfy associative composition", Curry._1(AA.make, Q.arbitrary_int), (function (n) {
                          return Curry._3(V.associative_composition, Curry._1(A.pure, (function (param) {
                                            return "!" + param;
                                          })), Curry._1(A.pure, (function (prim) {
                                            return String(prim);
                                          })), n);
                        })),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Applicative = function (A, AA) {
    var V = Bastet__Verify.Applicative(A);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Applicative", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", Curry._1(AA.make, Q.arbitrary_int), V.identity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy homomorphism", Curry._1(AA.make, Q.arbitrary_int), Curry._1(V.homomorphism, Curry._1(A.map, (function (prim) {
                                    return String(prim);
                                  })))),
                    tl: {
                      hd: Curry._4(Q.property, undefined, "should satisfy interchange", Q.arbitrary_int, Curry._1(V.interchange, Curry._1(A.pure, (function (prim) {
                                      return String(prim);
                                    })))),
                      tl: /* [] */0
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Monad = function (M, AA) {
    var V = Bastet__Verify.Monad(M);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Monad", {
                  hd: Curry._4(Q.property, undefined, "should satisfy associativity", Curry._1(AA.make_bound, Q.arbitrary_int), Curry._2(V.associativity, Curry._2($less$dot, M.pure, (function (prim) {
                                  return String(prim);
                                })), Curry._2($less$dot, M.pure, (function (param) {
                                  return "!" + param;
                                })))),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy identity", Q.arbitrary_int, Curry._1(V.identity, Curry._2($less$dot, M.pure, (function (prim) {
                                    return String(prim);
                                  })))),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Alt = function (A, AA) {
    var V = Bastet__Verify.Alt(A);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Alt", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", Curry._1(AA.make, Q.arbitrary_int), Curry._1(AA.make, Q.arbitrary_int), Curry._1(AA.make, Q.arbitrary_int), V.associativity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy distributivity", Curry._1(AA.make, Q.arbitrary_int), Curry._1(AA.make, Q.arbitrary_int), Curry._1(V.distributivity, (function (prim) {
                                return String(prim);
                              }))),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Alternative = function (A, AA) {
    var V = Bastet__Verify.Alternative(A);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Alternative", {
                  hd: Curry._4(Q.property, undefined, "should satisfy distributivity", Curry._1(AA.make, Q.arbitrary_int), Curry._2(V.distributivity, Curry._1(A.pure, (function (param) {
                                  return (param << 1);
                                })), Curry._1(A.pure, (function (param) {
                                  return 3 + param | 0;
                                })))),
                  tl: {
                    hd: Curry._2(T.test, "should satisfy annihalation", (function (param) {
                            Curry._4(T.check, T.bool, undefined, Curry._1(V.annihalation, Curry._1(A.pure, (function (prim) {
                                            return String(prim);
                                          }))), true);
                          })),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Plus = function (P, AA) {
    var V = Bastet__Verify.Plus(P);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Plus", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", Curry._1(AA.make, Q.arbitrary_int), V.identity),
                  tl: {
                    hd: Curry._2(T.test, "should satisfy annihalation", (function (param) {
                            Curry._4(T.check, T.bool, undefined, Curry._1(V.annihalation, (function (prim) {
                                        return String(prim);
                                      })), true);
                          })),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Eq = function (E, A) {
    var V = Bastet__Verify.Eq(E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Eq", {
                  hd: Curry._4(Q.property, undefined, "should satisfy reflexivity", A.make, V.reflexivity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy symmetry", A.make, A.make, V.symmetry),
                    tl: {
                      hd: Curry._6(Q.property3, undefined, "should satisfy transitivity", A.make, A.make, A.make, V.transitivity),
                      tl: /* [] */0
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Ord = function (O, A) {
    var V = Bastet__Verify.Ord(O);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Ord", {
                  hd: Curry._4(Q.property, undefined, "should satisfy reflexivity", A.make, V.reflexivity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy antisymmetry", A.make, A.make, V.antisymmetry),
                    tl: {
                      hd: Curry._6(Q.property3, undefined, "should satisfy transitivity", A.make, A.make, A.make, V.transitivity),
                      tl: /* [] */0
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Join_Semilattice = function (JS, A) {
    var V = Bastet__Verify.Join_Semilattice(JS);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Join_Semilattice", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.associativity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V.commutativity),
                    tl: {
                      hd: Curry._4(Q.property, undefined, "should satisfy idempotency", A.make, V.idempotency),
                      tl: /* [] */0
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Meet_Semilattice = function (MS, A) {
    var V = Bastet__Verify.Meet_Semilattice(MS);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Meet_Semilattice", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.associativity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V.commutativity),
                    tl: {
                      hd: Curry._4(Q.property, undefined, "should satisfy idempotency", A.make, V.idempotency),
                      tl: /* [] */0
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Bounded_Join_Semilattice = function (BJS, A) {
    var V = Bastet__Verify.Bounded_Join_Semilattice(BJS);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Bounded_Join_Semilattice", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V.identity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Bounded_Meet_Semilattice = function (BMS, A) {
    var V = Bastet__Verify.Bounded_Meet_Semilattice(BMS);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Bounded_Meet_Semilattice", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V.identity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Lattice = function (L, A) {
    var V = Bastet__Verify.Lattice(L);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Lattice", {
                  hd: Curry._5(Q.property2, undefined, "should satisfy absorption", A.make, A.make, V.absorption),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Bounded_Lattice = function (BL, A) {
    var V = Bastet__Verify.Bounded_Lattice(BL);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Bounded_Lattice", {
                  hd: Curry._5(Q.property2, undefined, "should satisfy absorption", A.make, A.make, V.absorption),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Distributive_Lattice = function (DL, A) {
    var V = Bastet__Verify.Distributive_Lattice(DL);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Distributive_Lattice", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy distributivity", A.make, A.make, A.make, V.distributivity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Bounded_Distributive_Lattice = function (BDL, A) {
    var V = Bastet__Verify.Bounded_Distributive_Lattice(BDL);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Bounded_Distributive_Lattice", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy distributivity", A.make, A.make, A.make, V.distributivity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Heyting_Algebra = function (HA, A) {
    var V = Bastet__Verify.Heyting_Algebra(HA);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Heyting_Algebra", {
                  hd: Curry._4(Q.property, undefined, "should satisfy pseudocomplement", A.make, V.pseudocomplement),
                  tl: {
                    hd: Curry._6(Q.property3, undefined, "should satisfy relative pseudocomplement", A.make, A.make, A.make, V.relative_pseudocomplement),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Involutive_Heyting_Algebra = function (IHA, A) {
    var V = Bastet__Verify.Involutive_Heyting_Algebra(IHA);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Involutive_Heyting_Algebra", {
                  hd: Curry._4(Q.property, undefined, "should satisfy involution", A.make, V.involution),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Boolean_Algebra = function (BA, A) {
    var V = Bastet__Verify.Boolean_Algebra(BA);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Boolean_Algebra", {
                  hd: Curry._4(Q.property, undefined, "should satisfy the law of excluded middle", A.make, V.excluded_middle),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Bounded = function (B, A) {
    var V = Bastet__Verify.Bounded(B);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Bounded", {
                  hd: Curry._4(Q.property, undefined, "should satisfy bounded", A.make, V.bounded),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Semiring$1 = function (S, A) {
    var V = Bastet__Verify.Semiring(S);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Semiring", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy additive associativity", A.make, A.make, A.make, V.additive_associativity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy additive identity", A.make, V.additive_identity),
                    tl: {
                      hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V.commutativity),
                      tl: {
                        hd: Curry._6(Q.property3, undefined, "should satisfy multiplicative associativity", A.make, A.make, A.make, V.multiplicative_associativity),
                        tl: {
                          hd: Curry._4(Q.property, undefined, "should satisfy multiplicative identity", A.make, V.multiplicative_identity),
                          tl: {
                            hd: Curry._6(Q.property3, undefined, "should satisfy distributivity", A.make, A.make, A.make, V.distributivity),
                            tl: /* [] */0
                          }
                        }
                      }
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Ring = function (R, A) {
    var V = Bastet__Verify.Ring(R);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Ring", {
                  hd: Curry._4(Q.property, undefined, "should satisfy additive inverse", A.make, V.additive_inverse),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Commutative_Ring = function (C, A) {
    var V = Bastet__Verify.Commutative_Ring(C);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Commutative_Ring", {
                  hd: Curry._5(Q.property2, undefined, "should satisfy multiplicative commutativity", A.make, A.make, V.multiplicative_commutativity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Division_Ring$1 = function (D, A) {
    var V = Bastet__Verify.Division_Ring(D);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Division_Ring", {
                  hd: Curry._2(T.test, "should be a non-zero ring (zero is not one)", (function (param) {
                          Curry._4(T.check, T.bool, undefined, V.non_zero_ring, true);
                        })),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy multiplicative inverse", A.make, V.multiplicative_inverse),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Euclidean_Ring$1 = function (E, A) {
    var V = Bastet__Verify.Euclidean_Ring(E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Euclidean_Ring", {
                  hd: Curry._2(T.test, "should be a non-zero ring (zero is not one)", (function (param) {
                          Curry._4(T.check, T.bool, undefined, V.non_zero_ring, true);
                        })),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy integral domain", A.make, A.make, V.integral_domain),
                    tl: {
                      hd: Curry._4(Q.property, undefined, "should satisfy non negative degree", A.make, V.non_negative_degree),
                      tl: {
                        hd: Curry._5(Q.property2, undefined, "should satisfy the properties for remainder", A.make, A.make, V.remainder),
                        tl: {
                          hd: Curry._5(Q.property2, undefined, "should satisfy submultiplicative", A.make, A.make, V.submultiplicative),
                          tl: /* [] */0
                        }
                      }
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Field = function (F, A) {
    var V = Bastet__Verify.Field(F);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Field", {
                  hd: Curry._5(Q.property2, undefined, "should satisfy non zero multiplicative inverse", A.make, A.make, V.non_zero_multiplicative_inverse),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Invariant = function (I, AA) {
    var V = Bastet__Verify.Invariant(I);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Invariant", {
                  hd: Curry._4(Q.property, undefined, "should satisfy reflexivity", Curry._1(AA.make, Q.arbitrary_int), V.identity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy composition", Curry._1(AA.make, Q.arbitrary_int), Curry._4(V.composition, (function (prim) {
                                return prim;
                              }), (function (prim) {
                                return prim | 0;
                              }), Curry._2($less$dot, (function (param) {
                                    return Math.imul(3, param);
                                  }), (function (prim) {
                                    return prim | 0;
                                  })), Curry._2($less$dot, (function (param) {
                                    return 4.0 * param;
                                  }), (function (prim) {
                                    return prim;
                                  })))),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var M = {
    $less$dot: $less$dot,
    Compare: Compare,
    Medial_Magma: Medial_Magma$1,
    Semigroup: Semigroup,
    Quasigroup: Quasigroup$1,
    Loop: Loop,
    Group: Group,
    Abelian_Group: Abelian_Group,
    Monoid: Monoid,
    Functor: Functor,
    Apply: Apply,
    Applicative: Applicative,
    Monad: Monad,
    Alt: Alt,
    Alternative: Alternative,
    Plus: Plus,
    Eq: Eq,
    Ord: Ord,
    Join_Semilattice: Join_Semilattice,
    Meet_Semilattice: Meet_Semilattice,
    Bounded_Join_Semilattice: Bounded_Join_Semilattice,
    Bounded_Meet_Semilattice: Bounded_Meet_Semilattice,
    Lattice: Lattice,
    Bounded_Lattice: Bounded_Lattice,
    Distributive_Lattice: Distributive_Lattice,
    Bounded_Distributive_Lattice: Bounded_Distributive_Lattice,
    Heyting_Algebra: Heyting_Algebra,
    Involutive_Heyting_Algebra: Involutive_Heyting_Algebra,
    Boolean_Algebra: Boolean_Algebra,
    Bounded: Bounded,
    Semiring: Semiring$1,
    Ring: Ring,
    Commutative_Ring: Commutative_Ring,
    Division_Ring: Division_Ring$1,
    Euclidean_Ring: Euclidean_Ring$1,
    Field: Field,
    Invariant: Invariant
  };
  var M$1 = Bastet__Int.Additive.Medial_Magma;
  var V = Bastet__Verify.Medial_Magma(M$1);
  var suite = function (name) {
    return Curry._2(T.suite, name + ".Medial_Magma", {
                hd: Curry._7(Q.property4, undefined, "should satisfy bicommutativity", A.make, A.make, A.make, A.make, V.bicommutativity),
                tl: /* [] */0
              });
  };
  var Medial_Magma$2 = {
    V: V,
    suite: suite
  };
  var S = Bastet__Int.Additive.Semigroup;
  var V$1 = Bastet__Verify.Semigroup(S);
  var suite$1 = function (name) {
    return Curry._2(T.suite, name + ".Semigroup", {
                hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V$1.associativity),
                tl: /* [] */0
              });
  };
  var Semigroup$1 = {
    V: V$1,
    suite: suite$1
  };
  var M$2 = Bastet__Int.Additive.Monoid;
  var V$2 = Bastet__Verify.Monoid(M$2);
  var suite$2 = function (name) {
    return Curry._2(T.suite, name + ".Monoid", {
                hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V$2.identity),
                tl: /* [] */0
              });
  };
  var Monoid$1 = {
    V: V$2,
    suite: suite$2
  };
  var QG = Bastet__Int.Additive.Quasigroup;
  var V$3 = Bastet__Verify.Quasigroup(QG);
  var suite$3 = function (name) {
    return Curry._2(T.suite, name + ".Quasigroup", {
                hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V$3.cancellative),
                tl: /* [] */0
              });
  };
  var Quasigroup$2 = {
    V: V$3,
    suite: suite$3
  };
  var L = Bastet__Int.Additive.Loop;
  var V$4 = Bastet__Verify.Loop(L);
  var suite$4 = function (name) {
    return Curry._2(T.suite, name + ".Loop", {
                hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V$4.identity),
                tl: /* [] */0
              });
  };
  var Loop$1 = {
    V: V$4,
    suite: suite$4
  };
  var G = Bastet__Int.Additive.Group;
  var V$5 = Bastet__Verify.Group(G);
  var suite$5 = function (name) {
    return Curry._2(T.suite, name + ".Group", {
                hd: Curry._4(Q.property, undefined, "should satisfy invertibility", A.make, V$5.invertibility),
                tl: {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V$5.associativity),
                  tl: /* [] */0
                }
              });
  };
  var Group$1 = {
    V: V$5,
    suite: suite$5
  };
  var G$1 = Bastet__Int.Additive.Abelian_Group;
  var V$6 = Bastet__Verify.Abelian_Group(G$1);
  var suite$6 = function (name) {
    return Curry._2(T.suite, name + ".Abelian_Group", {
                hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V$6.commutativity),
                tl: /* [] */0
              });
  };
  var Abelian_Group$1 = {
    V: V$6,
    suite: suite$6
  };
  var Additive = {
    Medial_Magma: Medial_Magma$2,
    Semigroup: Semigroup$1,
    Monoid: Monoid$1,
    Quasigroup: Quasigroup$2,
    Loop: Loop$1,
    Group: Group$1,
    Abelian_Group: Abelian_Group$1
  };
  var M$3 = Bastet__Int.Multiplicative.Medial_Magma;
  var V$7 = Bastet__Verify.Medial_Magma(M$3);
  var suite$7 = function (name) {
    return Curry._2(T.suite, name + ".Medial_Magma", {
                hd: Curry._7(Q.property4, undefined, "should satisfy bicommutativity", A.make, A.make, A.make, A.make, V$7.bicommutativity),
                tl: /* [] */0
              });
  };
  var Medial_Magma$3 = {
    V: V$7,
    suite: suite$7
  };
  var S$1 = Bastet__Int.Multiplicative.Semigroup;
  var V$8 = Bastet__Verify.Semigroup(S$1);
  var suite$8 = function (name) {
    return Curry._2(T.suite, name + ".Semigroup", {
                hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V$8.associativity),
                tl: /* [] */0
              });
  };
  var Semigroup$2 = {
    V: V$8,
    suite: suite$8
  };
  var M$4 = Bastet__Int.Multiplicative.Monoid;
  var V$9 = Bastet__Verify.Monoid(M$4);
  var suite$9 = function (name) {
    return Curry._2(T.suite, name + ".Monoid", {
                hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V$9.identity),
                tl: /* [] */0
              });
  };
  var Monoid$2 = {
    V: V$9,
    suite: suite$9
  };
  var QG$1 = Bastet__Int.Multiplicative.Quasigroup;
  var V$10 = Bastet__Verify.Quasigroup(QG$1);
  var suite$10 = function (name) {
    return Curry._2(T.suite, name + ".Quasigroup", {
                hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V$10.cancellative),
                tl: /* [] */0
              });
  };
  var Quasigroup$3 = {
    V: V$10,
    suite: suite$10
  };
  var L$1 = Bastet__Int.Multiplicative.Loop;
  var V$11 = Bastet__Verify.Loop(L$1);
  var suite$11 = function (name) {
    return Curry._2(T.suite, name + ".Loop", {
                hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V$11.identity),
                tl: /* [] */0
              });
  };
  var Loop$2 = {
    V: V$11,
    suite: suite$11
  };
  var Multiplicative = {
    Medial_Magma: Medial_Magma$3,
    Semigroup: Semigroup$2,
    Monoid: Monoid$2,
    Quasigroup: Quasigroup$3,
    Loop: Loop$2
  };
  var M$5 = Bastet__Int.Subtractive.Medial_Magma;
  var V$12 = Bastet__Verify.Medial_Magma(M$5);
  var suite$12 = function (name) {
    return Curry._2(T.suite, name + ".Medial_Magma", {
                hd: Curry._7(Q.property4, undefined, "should satisfy bicommutativity", A.make, A.make, A.make, A.make, V$12.bicommutativity),
                tl: /* [] */0
              });
  };
  var Medial_Magma$4 = {
    V: V$12,
    suite: suite$12
  };
  var QG$2 = Bastet__Int.Subtractive.Quasigroup;
  var V$13 = Bastet__Verify.Quasigroup(QG$2);
  var suite$13 = function (name) {
    return Curry._2(T.suite, name + ".Quasigroup", {
                hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V$13.cancellative),
                tl: /* [] */0
              });
  };
  var Quasigroup$4 = {
    V: V$13,
    suite: suite$13
  };
  var Subtractive = {
    Medial_Magma: Medial_Magma$4,
    Quasigroup: Quasigroup$4
  };
  var E = Bastet__Int.Eq;
  var V$14 = Bastet__Verify.Eq(E);
  var suite$14 = function (name) {
    return Curry._2(T.suite, name + ".Eq", {
                hd: Curry._4(Q.property, undefined, "should satisfy reflexivity", A.make, V$14.reflexivity),
                tl: {
                  hd: Curry._5(Q.property2, undefined, "should satisfy symmetry", A.make, A.make, V$14.symmetry),
                  tl: {
                    hd: Curry._6(Q.property3, undefined, "should satisfy transitivity", A.make, A.make, A.make, V$14.transitivity),
                    tl: /* [] */0
                  }
                }
              });
  };
  var Eq$1 = {
    V: V$14,
    suite: suite$14
  };
  var O = Bastet__Int.Ord;
  var V$15 = Bastet__Verify.Ord(O);
  var suite$15 = function (name) {
    return Curry._2(T.suite, name + ".Ord", {
                hd: Curry._4(Q.property, undefined, "should satisfy reflexivity", A.make, V$15.reflexivity),
                tl: {
                  hd: Curry._5(Q.property2, undefined, "should satisfy antisymmetry", A.make, A.make, V$15.antisymmetry),
                  tl: {
                    hd: Curry._6(Q.property3, undefined, "should satisfy transitivity", A.make, A.make, A.make, V$15.transitivity),
                    tl: /* [] */0
                  }
                }
              });
  };
  var Ord$1 = {
    V: V$15,
    suite: suite$15
  };
  var B = Bastet__Int.Bounded;
  var V$16 = Bastet__Verify.Bounded(B);
  var suite$16 = function (name) {
    return Curry._2(T.suite, name + ".Bounded", {
                hd: Curry._4(Q.property, undefined, "should satisfy bounded", A.make, V$16.bounded),
                tl: /* [] */0
              });
  };
  var Bounded$1 = {
    V: V$16,
    suite: suite$16
  };
  var S$2 = Bastet__Int.Semiring;
  var V$17 = Bastet__Verify.Semiring(S$2);
  var suite$17 = function (name) {
    return Curry._2(T.suite, name + ".Semiring", {
                hd: Curry._6(Q.property3, undefined, "should satisfy additive associativity", A.make, A.make, A.make, V$17.additive_associativity),
                tl: {
                  hd: Curry._4(Q.property, undefined, "should satisfy additive identity", A.make, V$17.additive_identity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V$17.commutativity),
                    tl: {
                      hd: Curry._6(Q.property3, undefined, "should satisfy multiplicative associativity", A.make, A.make, A.make, V$17.multiplicative_associativity),
                      tl: {
                        hd: Curry._4(Q.property, undefined, "should satisfy multiplicative identity", A.make, V$17.multiplicative_identity),
                        tl: {
                          hd: Curry._6(Q.property3, undefined, "should satisfy distributivity", A.make, A.make, A.make, V$17.distributivity),
                          tl: /* [] */0
                        }
                      }
                    }
                  }
                }
              });
  };
  var Semiring$2 = {
    V: V$17,
    suite: suite$17
  };
  var R = Bastet__Int.Ring;
  var V$18 = Bastet__Verify.Ring(R);
  var suite$18 = function (name) {
    return Curry._2(T.suite, name + ".Ring", {
                hd: Curry._4(Q.property, undefined, "should satisfy additive inverse", A.make, V$18.additive_inverse),
                tl: /* [] */0
              });
  };
  var Ring$1 = {
    V: V$18,
    suite: suite$18
  };
  var C = Bastet__Int.Commutative_Ring;
  var V$19 = Bastet__Verify.Commutative_Ring(C);
  var suite$19 = function (name) {
    return Curry._2(T.suite, name + ".Commutative_Ring", {
                hd: Curry._5(Q.property2, undefined, "should satisfy multiplicative commutativity", A.make, A.make, V$19.multiplicative_commutativity),
                tl: /* [] */0
              });
  };
  var Commutative_Ring$1 = {
    V: V$19,
    suite: suite$19
  };
  var E$1 = Bastet__Int.Euclidean_Ring;
  var V$20 = Bastet__Verify.Euclidean_Ring(E$1);
  var suite$20 = function (name) {
    return Curry._2(T.suite, name + ".Euclidean_Ring", {
                hd: Curry._2(T.test, "should be a non-zero ring (zero is not one)", (function (param) {
                        Curry._4(T.check, T.bool, undefined, V$20.non_zero_ring, true);
                      })),
                tl: {
                  hd: Curry._5(Q.property2, undefined, "should satisfy integral domain", A.make, A.make, V$20.integral_domain),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy non negative degree", A.make, V$20.non_negative_degree),
                    tl: {
                      hd: Curry._5(Q.property2, undefined, "should satisfy the properties for remainder", A.make, A.make, V$20.remainder),
                      tl: {
                        hd: Curry._5(Q.property2, undefined, "should satisfy submultiplicative", A.make, A.make, V$20.submultiplicative),
                        tl: /* [] */0
                      }
                    }
                  }
                }
              });
  };
  var Euclidean_Ring$2 = {
    V: V$20,
    suite: suite$20
  };
  var suites = Stdlib__ListLabels.concat({
        hd: Stdlib__ListLabels.map((function (suite) {
                return Curry._1(suite, "Int.Additive");
              }), {
              hd: suite,
              tl: {
                hd: suite$1,
                tl: {
                  hd: suite$2,
                  tl: {
                    hd: suite$3,
                    tl: {
                      hd: suite$4,
                      tl: {
                        hd: suite$5,
                        tl: {
                          hd: suite$6,
                          tl: /* [] */0
                        }
                      }
                    }
                  }
                }
              }
            }),
        tl: {
          hd: Stdlib__ListLabels.map((function (suite) {
                  return Curry._1(suite, "Int.Multiplicative");
                }), {
                hd: suite$7,
                tl: {
                  hd: suite$8,
                  tl: {
                    hd: suite$9,
                    tl: {
                      hd: suite$10,
                      tl: {
                        hd: suite$11,
                        tl: /* [] */0
                      }
                    }
                  }
                }
              }),
          tl: {
            hd: Stdlib__ListLabels.map((function (suite) {
                    return Curry._1(suite, "Int.Subtractive");
                  }), {
                  hd: suite$12,
                  tl: {
                    hd: suite$13,
                    tl: /* [] */0
                  }
                }),
            tl: {
              hd: Stdlib__ListLabels.map((function (suite) {
                      return Curry._1(suite, "Int");
                    }), {
                    hd: suite$14,
                    tl: {
                      hd: suite$15,
                      tl: {
                        hd: suite$16,
                        tl: {
                          hd: suite$17,
                          tl: {
                            hd: suite$18,
                            tl: {
                              hd: suite$19,
                              tl: {
                                hd: suite$20,
                                tl: /* [] */0
                              }
                            }
                          }
                        }
                      }
                    }
                  }),
              tl: /* [] */0
            }
          }
        }
      });
  return {
          M: M,
          Additive: Additive,
          Multiplicative: Multiplicative,
          Subtractive: Subtractive,
          Eq: Eq$1,
          Ord: Ord$1,
          Bounded: Bounded$1,
          Semiring: Semiring$2,
          Ring: Ring$1,
          Commutative_Ring: Commutative_Ring$1,
          Euclidean_Ring: Euclidean_Ring$2,
          suites: suites
        };
}

function $$Option(T, Q, A, AA) {
  var $less$dot = Bastet__Function.Infix.$less$dot;
  var Medial_Magma = function (M, E, A) {
    var V = Bastet__Verify.Compare.Medial_Magma(M, E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Medial_Magma", {
                  hd: Curry._7(Q.property4, undefined, "should satisfy bicommutativity", A.make, A.make, A.make, A.make, V.bicommutativity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Quasigroup = function (QG, E, A) {
    var V = Bastet__Verify.Compare.Quasigroup(QG, E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Quasigroup", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.cancellative),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Semiring = function (S, E, A) {
    var V = Bastet__Verify.Compare.Semiring(S, E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Semiring", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy additive associativity", A.make, A.make, A.make, V.additive_associativity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy additive identity", A.make, V.additive_identity),
                    tl: {
                      hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V.commutativity),
                      tl: {
                        hd: Curry._6(Q.property3, undefined, "should satisfy multiplicative associativity", A.make, A.make, A.make, V.multiplicative_associativity),
                        tl: {
                          hd: Curry._4(Q.property, undefined, "should satisfy multiplicative identity", A.make, V.multiplicative_identity),
                          tl: {
                            hd: Curry._6(Q.property3, undefined, "should satisfy distributivity", A.make, A.make, A.make, V.distributivity),
                            tl: /* [] */0
                          }
                        }
                      }
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Division_Ring = function (D, E, A) {
    var V = Bastet__Verify.Compare.Division_Ring(D, E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Division_Ring", {
                  hd: Curry._2(T.test, "should be a non-zero ring (zero is not one)", (function (param) {
                          Curry._4(T.check, T.bool, undefined, V.non_zero_ring, true);
                        })),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy multiplicative inverse", A.make, V.multiplicative_inverse),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Euclidean_Ring = function (E, EQ, A) {
    var V = Bastet__Verify.Compare.Euclidean_Ring(E, EQ);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Euclidean_Ring", {
                  hd: Curry._2(T.test, "should be a non-zero ring (zero is not one)", (function (param) {
                          Curry._4(T.check, T.bool, undefined, V.non_zero_ring, true);
                        })),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy integral domain", A.make, A.make, V.integral_domain),
                    tl: {
                      hd: Curry._4(Q.property, undefined, "should satisfy non negative degree", A.make, V.non_negative_degree),
                      tl: {
                        hd: Curry._5(Q.property2, undefined, "should satisfy the properties for remainder", A.make, A.make, V.remainder),
                        tl: {
                          hd: Curry._5(Q.property2, undefined, "should satisfy submultiplicative", A.make, A.make, V.submultiplicative),
                          tl: /* [] */0
                        }
                      }
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Compare = {
    Medial_Magma: Medial_Magma,
    Quasigroup: Quasigroup,
    Semiring: Semiring,
    Division_Ring: Division_Ring,
    Euclidean_Ring: Euclidean_Ring
  };
  var Medial_Magma$1 = function (M, A) {
    var V = Bastet__Verify.Medial_Magma(M);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Medial_Magma", {
                  hd: Curry._7(Q.property4, undefined, "should satisfy bicommutativity", A.make, A.make, A.make, A.make, V.bicommutativity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Semigroup = function (S, A) {
    var V = Bastet__Verify.Semigroup(S);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Semigroup", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.associativity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Quasigroup$1 = function (QG, A) {
    var V = Bastet__Verify.Quasigroup(QG);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Quasigroup", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.cancellative),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Loop = function (L, A) {
    var V = Bastet__Verify.Loop(L);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Loop", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V.identity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Group = function (G, A) {
    var V = Bastet__Verify.Group(G);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Group", {
                  hd: Curry._4(Q.property, undefined, "should satisfy invertibility", A.make, V.invertibility),
                  tl: {
                    hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.associativity),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Abelian_Group = function (G, A) {
    var V = Bastet__Verify.Abelian_Group(G);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Abelian_Group", {
                  hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V.commutativity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Monoid = function (M, A) {
    var V = Bastet__Verify.Monoid(M);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Monoid", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V.identity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Functor = function (F, AA) {
    var V = Bastet__Verify.Functor(F);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Functor", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", Curry._1(AA.make, Q.arbitrary_int), V.identity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy composition", Curry._1(AA.make, Q.arbitrary_int), (function (a) {
                            return Curry._3(V.composition, (function (param) {
                                          return "!" + param;
                                        }), (function (prim) {
                                          return String(prim);
                                        }), a);
                          })),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Apply = function (A, AA) {
    var V = Bastet__Verify.Apply(A);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Apply", {
                  hd: Curry._4(Q.property, undefined, "should satisfy associative composition", Curry._1(AA.make, Q.arbitrary_int), (function (n) {
                          return Curry._3(V.associative_composition, Curry._1(A.pure, (function (param) {
                                            return "!" + param;
                                          })), Curry._1(A.pure, (function (prim) {
                                            return String(prim);
                                          })), n);
                        })),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Applicative = function (A, AA) {
    var V = Bastet__Verify.Applicative(A);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Applicative", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", Curry._1(AA.make, Q.arbitrary_int), V.identity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy homomorphism", Curry._1(AA.make, Q.arbitrary_int), Curry._1(V.homomorphism, Curry._1(A.map, (function (prim) {
                                    return String(prim);
                                  })))),
                    tl: {
                      hd: Curry._4(Q.property, undefined, "should satisfy interchange", Q.arbitrary_int, Curry._1(V.interchange, Curry._1(A.pure, (function (prim) {
                                      return String(prim);
                                    })))),
                      tl: /* [] */0
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Monad = function (M, AA) {
    var V = Bastet__Verify.Monad(M);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Monad", {
                  hd: Curry._4(Q.property, undefined, "should satisfy associativity", Curry._1(AA.make_bound, Q.arbitrary_int), Curry._2(V.associativity, Curry._2($less$dot, M.pure, (function (prim) {
                                  return String(prim);
                                })), Curry._2($less$dot, M.pure, (function (param) {
                                  return "!" + param;
                                })))),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy identity", Q.arbitrary_int, Curry._1(V.identity, Curry._2($less$dot, M.pure, (function (prim) {
                                    return String(prim);
                                  })))),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Alt = function (A, AA) {
    var V = Bastet__Verify.Alt(A);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Alt", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", Curry._1(AA.make, Q.arbitrary_int), Curry._1(AA.make, Q.arbitrary_int), Curry._1(AA.make, Q.arbitrary_int), V.associativity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy distributivity", Curry._1(AA.make, Q.arbitrary_int), Curry._1(AA.make, Q.arbitrary_int), Curry._1(V.distributivity, (function (prim) {
                                return String(prim);
                              }))),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Alternative = function (A, AA) {
    var V = Bastet__Verify.Alternative(A);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Alternative", {
                  hd: Curry._4(Q.property, undefined, "should satisfy distributivity", Curry._1(AA.make, Q.arbitrary_int), Curry._2(V.distributivity, Curry._1(A.pure, (function (param) {
                                  return (param << 1);
                                })), Curry._1(A.pure, (function (param) {
                                  return 3 + param | 0;
                                })))),
                  tl: {
                    hd: Curry._2(T.test, "should satisfy annihalation", (function (param) {
                            Curry._4(T.check, T.bool, undefined, Curry._1(V.annihalation, Curry._1(A.pure, (function (prim) {
                                            return String(prim);
                                          }))), true);
                          })),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Plus = function (P, AA) {
    var V = Bastet__Verify.Plus(P);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Plus", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", Curry._1(AA.make, Q.arbitrary_int), V.identity),
                  tl: {
                    hd: Curry._2(T.test, "should satisfy annihalation", (function (param) {
                            Curry._4(T.check, T.bool, undefined, Curry._1(V.annihalation, (function (prim) {
                                        return String(prim);
                                      })), true);
                          })),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Eq = function (E, A) {
    var V = Bastet__Verify.Eq(E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Eq", {
                  hd: Curry._4(Q.property, undefined, "should satisfy reflexivity", A.make, V.reflexivity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy symmetry", A.make, A.make, V.symmetry),
                    tl: {
                      hd: Curry._6(Q.property3, undefined, "should satisfy transitivity", A.make, A.make, A.make, V.transitivity),
                      tl: /* [] */0
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Ord = function (O, A) {
    var V = Bastet__Verify.Ord(O);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Ord", {
                  hd: Curry._4(Q.property, undefined, "should satisfy reflexivity", A.make, V.reflexivity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy antisymmetry", A.make, A.make, V.antisymmetry),
                    tl: {
                      hd: Curry._6(Q.property3, undefined, "should satisfy transitivity", A.make, A.make, A.make, V.transitivity),
                      tl: /* [] */0
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Join_Semilattice = function (JS, A) {
    var V = Bastet__Verify.Join_Semilattice(JS);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Join_Semilattice", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.associativity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V.commutativity),
                    tl: {
                      hd: Curry._4(Q.property, undefined, "should satisfy idempotency", A.make, V.idempotency),
                      tl: /* [] */0
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Meet_Semilattice = function (MS, A) {
    var V = Bastet__Verify.Meet_Semilattice(MS);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Meet_Semilattice", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.associativity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V.commutativity),
                    tl: {
                      hd: Curry._4(Q.property, undefined, "should satisfy idempotency", A.make, V.idempotency),
                      tl: /* [] */0
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Bounded_Join_Semilattice = function (BJS, A) {
    var V = Bastet__Verify.Bounded_Join_Semilattice(BJS);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Bounded_Join_Semilattice", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V.identity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Bounded_Meet_Semilattice = function (BMS, A) {
    var V = Bastet__Verify.Bounded_Meet_Semilattice(BMS);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Bounded_Meet_Semilattice", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V.identity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Lattice = function (L, A) {
    var V = Bastet__Verify.Lattice(L);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Lattice", {
                  hd: Curry._5(Q.property2, undefined, "should satisfy absorption", A.make, A.make, V.absorption),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Bounded_Lattice = function (BL, A) {
    var V = Bastet__Verify.Bounded_Lattice(BL);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Bounded_Lattice", {
                  hd: Curry._5(Q.property2, undefined, "should satisfy absorption", A.make, A.make, V.absorption),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Distributive_Lattice = function (DL, A) {
    var V = Bastet__Verify.Distributive_Lattice(DL);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Distributive_Lattice", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy distributivity", A.make, A.make, A.make, V.distributivity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Bounded_Distributive_Lattice = function (BDL, A) {
    var V = Bastet__Verify.Bounded_Distributive_Lattice(BDL);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Bounded_Distributive_Lattice", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy distributivity", A.make, A.make, A.make, V.distributivity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Heyting_Algebra = function (HA, A) {
    var V = Bastet__Verify.Heyting_Algebra(HA);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Heyting_Algebra", {
                  hd: Curry._4(Q.property, undefined, "should satisfy pseudocomplement", A.make, V.pseudocomplement),
                  tl: {
                    hd: Curry._6(Q.property3, undefined, "should satisfy relative pseudocomplement", A.make, A.make, A.make, V.relative_pseudocomplement),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Involutive_Heyting_Algebra = function (IHA, A) {
    var V = Bastet__Verify.Involutive_Heyting_Algebra(IHA);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Involutive_Heyting_Algebra", {
                  hd: Curry._4(Q.property, undefined, "should satisfy involution", A.make, V.involution),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Boolean_Algebra = function (BA, A) {
    var V = Bastet__Verify.Boolean_Algebra(BA);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Boolean_Algebra", {
                  hd: Curry._4(Q.property, undefined, "should satisfy the law of excluded middle", A.make, V.excluded_middle),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Bounded = function (B, A) {
    var V = Bastet__Verify.Bounded(B);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Bounded", {
                  hd: Curry._4(Q.property, undefined, "should satisfy bounded", A.make, V.bounded),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Semiring$1 = function (S, A) {
    var V = Bastet__Verify.Semiring(S);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Semiring", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy additive associativity", A.make, A.make, A.make, V.additive_associativity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy additive identity", A.make, V.additive_identity),
                    tl: {
                      hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V.commutativity),
                      tl: {
                        hd: Curry._6(Q.property3, undefined, "should satisfy multiplicative associativity", A.make, A.make, A.make, V.multiplicative_associativity),
                        tl: {
                          hd: Curry._4(Q.property, undefined, "should satisfy multiplicative identity", A.make, V.multiplicative_identity),
                          tl: {
                            hd: Curry._6(Q.property3, undefined, "should satisfy distributivity", A.make, A.make, A.make, V.distributivity),
                            tl: /* [] */0
                          }
                        }
                      }
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Ring = function (R, A) {
    var V = Bastet__Verify.Ring(R);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Ring", {
                  hd: Curry._4(Q.property, undefined, "should satisfy additive inverse", A.make, V.additive_inverse),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Commutative_Ring = function (C, A) {
    var V = Bastet__Verify.Commutative_Ring(C);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Commutative_Ring", {
                  hd: Curry._5(Q.property2, undefined, "should satisfy multiplicative commutativity", A.make, A.make, V.multiplicative_commutativity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Division_Ring$1 = function (D, A) {
    var V = Bastet__Verify.Division_Ring(D);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Division_Ring", {
                  hd: Curry._2(T.test, "should be a non-zero ring (zero is not one)", (function (param) {
                          Curry._4(T.check, T.bool, undefined, V.non_zero_ring, true);
                        })),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy multiplicative inverse", A.make, V.multiplicative_inverse),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Euclidean_Ring$1 = function (E, A) {
    var V = Bastet__Verify.Euclidean_Ring(E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Euclidean_Ring", {
                  hd: Curry._2(T.test, "should be a non-zero ring (zero is not one)", (function (param) {
                          Curry._4(T.check, T.bool, undefined, V.non_zero_ring, true);
                        })),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy integral domain", A.make, A.make, V.integral_domain),
                    tl: {
                      hd: Curry._4(Q.property, undefined, "should satisfy non negative degree", A.make, V.non_negative_degree),
                      tl: {
                        hd: Curry._5(Q.property2, undefined, "should satisfy the properties for remainder", A.make, A.make, V.remainder),
                        tl: {
                          hd: Curry._5(Q.property2, undefined, "should satisfy submultiplicative", A.make, A.make, V.submultiplicative),
                          tl: /* [] */0
                        }
                      }
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Field = function (F, A) {
    var V = Bastet__Verify.Field(F);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Field", {
                  hd: Curry._5(Q.property2, undefined, "should satisfy non zero multiplicative inverse", A.make, A.make, V.non_zero_multiplicative_inverse),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Invariant = function (I, AA) {
    var V = Bastet__Verify.Invariant(I);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Invariant", {
                  hd: Curry._4(Q.property, undefined, "should satisfy reflexivity", Curry._1(AA.make, Q.arbitrary_int), V.identity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy composition", Curry._1(AA.make, Q.arbitrary_int), Curry._4(V.composition, (function (prim) {
                                return prim;
                              }), (function (prim) {
                                return prim | 0;
                              }), Curry._2($less$dot, (function (param) {
                                    return Math.imul(3, param);
                                  }), (function (prim) {
                                    return prim | 0;
                                  })), Curry._2($less$dot, (function (param) {
                                    return 4.0 * param;
                                  }), (function (prim) {
                                    return prim;
                                  })))),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var M = {
    $less$dot: $less$dot,
    Compare: Compare,
    Medial_Magma: Medial_Magma$1,
    Semigroup: Semigroup,
    Quasigroup: Quasigroup$1,
    Loop: Loop,
    Group: Group,
    Abelian_Group: Abelian_Group,
    Monoid: Monoid,
    Functor: Functor,
    Apply: Apply,
    Applicative: Applicative,
    Monad: Monad,
    Alt: Alt,
    Alternative: Alternative,
    Plus: Plus,
    Eq: Eq,
    Ord: Ord,
    Join_Semilattice: Join_Semilattice,
    Meet_Semilattice: Meet_Semilattice,
    Bounded_Join_Semilattice: Bounded_Join_Semilattice,
    Bounded_Meet_Semilattice: Bounded_Meet_Semilattice,
    Lattice: Lattice,
    Bounded_Lattice: Bounded_Lattice,
    Distributive_Lattice: Distributive_Lattice,
    Bounded_Distributive_Lattice: Bounded_Distributive_Lattice,
    Heyting_Algebra: Heyting_Algebra,
    Involutive_Heyting_Algebra: Involutive_Heyting_Algebra,
    Boolean_Algebra: Boolean_Algebra,
    Bounded: Bounded,
    Semiring: Semiring$1,
    Ring: Ring,
    Commutative_Ring: Commutative_Ring,
    Division_Ring: Division_Ring$1,
    Euclidean_Ring: Euclidean_Ring$1,
    Field: Field,
    Invariant: Invariant
  };
  var S = Bastet__Functors.OptionF.Int.Additive.Semigroup;
  var V = Bastet__Verify.Semigroup(S);
  var suite = function (name) {
    return Curry._2(T.suite, name + ".Semigroup", {
                hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.associativity),
                tl: /* [] */0
              });
  };
  var Semigroup$1 = {
    V: V,
    suite: suite
  };
  var M$1 = Bastet__Functors.OptionF.Int.Additive.Monoid;
  var V$1 = Bastet__Verify.Monoid(M$1);
  var suite$1 = function (name) {
    return Curry._2(T.suite, name + ".Monoid", {
                hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V$1.identity),
                tl: /* [] */0
              });
  };
  var Monoid$1 = {
    V: V$1,
    suite: suite$1
  };
  var F = Bastet__Option.Functor;
  var V$2 = Bastet__Verify.Functor(F);
  var suite$2 = function (name) {
    return Curry._2(T.suite, name + ".Functor", {
                hd: Curry._4(Q.property, undefined, "should satisfy identity", Curry._1(AA.make, Q.arbitrary_int), V$2.identity),
                tl: {
                  hd: Curry._4(Q.property, undefined, "should satisfy composition", Curry._1(AA.make, Q.arbitrary_int), (function (a) {
                          return Curry._3(V$2.composition, (function (param) {
                                        return "!" + param;
                                      }), (function (prim) {
                                        return String(prim);
                                      }), a);
                        })),
                  tl: /* [] */0
                }
              });
  };
  var Functor$1 = {
    V: V$2,
    suite: suite$2
  };
  var A$1 = Bastet__Option.Applicative;
  var V$3 = Bastet__Verify.Apply(A$1);
  var suite$3 = function (name) {
    return Curry._2(T.suite, name + ".Apply", {
                hd: Curry._4(Q.property, undefined, "should satisfy associative composition", Curry._1(AA.make, Q.arbitrary_int), (function (n) {
                        return Curry._3(V$3.associative_composition, Curry._1(A$1.pure, (function (param) {
                                          return "!" + param;
                                        })), Curry._1(A$1.pure, (function (prim) {
                                          return String(prim);
                                        })), n);
                      })),
                tl: /* [] */0
              });
  };
  var Apply$1 = {
    V: V$3,
    suite: suite$3
  };
  var A$2 = Bastet__Option.Applicative;
  var V$4 = Bastet__Verify.Applicative(A$2);
  var suite$4 = function (name) {
    return Curry._2(T.suite, name + ".Applicative", {
                hd: Curry._4(Q.property, undefined, "should satisfy identity", Curry._1(AA.make, Q.arbitrary_int), V$4.identity),
                tl: {
                  hd: Curry._4(Q.property, undefined, "should satisfy homomorphism", Curry._1(AA.make, Q.arbitrary_int), Curry._1(V$4.homomorphism, Curry._1(A$2.map, (function (prim) {
                                  return String(prim);
                                })))),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy interchange", Q.arbitrary_int, Curry._1(V$4.interchange, Curry._1(A$2.pure, (function (prim) {
                                    return String(prim);
                                  })))),
                    tl: /* [] */0
                  }
                }
              });
  };
  var Applicative$1 = {
    V: V$4,
    suite: suite$4
  };
  var M$2 = Bastet__Option.Monad;
  var V$5 = Bastet__Verify.Monad(M$2);
  var suite$5 = function (name) {
    return Curry._2(T.suite, name + ".Monad", {
                hd: Curry._4(Q.property, undefined, "should satisfy associativity", Curry._1(AA.make_bound, Q.arbitrary_int), Curry._2(V$5.associativity, Curry._2($less$dot, M$2.pure, (function (prim) {
                                return String(prim);
                              })), Curry._2($less$dot, M$2.pure, (function (param) {
                                return "!" + param;
                              })))),
                tl: {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", Q.arbitrary_int, Curry._1(V$5.identity, Curry._2($less$dot, M$2.pure, (function (prim) {
                                  return String(prim);
                                })))),
                  tl: /* [] */0
                }
              });
  };
  var Monad$1 = {
    V: V$5,
    suite: suite$5
  };
  var A$3 = Bastet__Option.Alt;
  var V$6 = Bastet__Verify.Alt(A$3);
  var suite$6 = function (name) {
    return Curry._2(T.suite, name + ".Alt", {
                hd: Curry._6(Q.property3, undefined, "should satisfy associativity", Curry._1(AA.make, Q.arbitrary_int), Curry._1(AA.make, Q.arbitrary_int), Curry._1(AA.make, Q.arbitrary_int), V$6.associativity),
                tl: {
                  hd: Curry._5(Q.property2, undefined, "should satisfy distributivity", Curry._1(AA.make, Q.arbitrary_int), Curry._1(AA.make, Q.arbitrary_int), Curry._1(V$6.distributivity, (function (prim) {
                              return String(prim);
                            }))),
                  tl: /* [] */0
                }
              });
  };
  var Alt$1 = {
    V: V$6,
    suite: suite$6
  };
  var P = Bastet__Option.Plus;
  var V$7 = Bastet__Verify.Plus(P);
  var suite$7 = function (name) {
    return Curry._2(T.suite, name + ".Plus", {
                hd: Curry._4(Q.property, undefined, "should satisfy identity", Curry._1(AA.make, Q.arbitrary_int), V$7.identity),
                tl: {
                  hd: Curry._2(T.test, "should satisfy annihalation", (function (param) {
                          Curry._4(T.check, T.bool, undefined, Curry._1(V$7.annihalation, (function (prim) {
                                      return String(prim);
                                    })), true);
                        })),
                  tl: /* [] */0
                }
              });
  };
  var Plus$1 = {
    V: V$7,
    suite: suite$7
  };
  var A$4 = Bastet__Option.Alternative;
  var V$8 = Bastet__Verify.Alternative(A$4);
  var suite$8 = function (name) {
    return Curry._2(T.suite, name + ".Alternative", {
                hd: Curry._4(Q.property, undefined, "should satisfy distributivity", Curry._1(AA.make, Q.arbitrary_int), Curry._2(V$8.distributivity, Curry._1(A$4.pure, (function (param) {
                                return (param << 1);
                              })), Curry._1(A$4.pure, (function (param) {
                                return 3 + param | 0;
                              })))),
                tl: {
                  hd: Curry._2(T.test, "should satisfy annihalation", (function (param) {
                          Curry._4(T.check, T.bool, undefined, Curry._1(V$8.annihalation, Curry._1(A$4.pure, (function (prim) {
                                          return String(prim);
                                        }))), true);
                        })),
                  tl: /* [] */0
                }
              });
  };
  var Alternative$1 = {
    V: V$8,
    suite: suite$8
  };
  var E = Bastet__Functors.OptionF.Int.Eq;
  var V$9 = Bastet__Verify.Eq(E);
  var suite$9 = function (name) {
    return Curry._2(T.suite, name + ".Eq", {
                hd: Curry._4(Q.property, undefined, "should satisfy reflexivity", A.make, V$9.reflexivity),
                tl: {
                  hd: Curry._5(Q.property2, undefined, "should satisfy symmetry", A.make, A.make, V$9.symmetry),
                  tl: {
                    hd: Curry._6(Q.property3, undefined, "should satisfy transitivity", A.make, A.make, A.make, V$9.transitivity),
                    tl: /* [] */0
                  }
                }
              });
  };
  var Eq$1 = {
    V: V$9,
    suite: suite$9
  };
  var O = Bastet__Functors.OptionF.Int.Ord;
  var V$10 = Bastet__Verify.Ord(O);
  var suite$10 = function (name) {
    return Curry._2(T.suite, name + ".Ord", {
                hd: Curry._4(Q.property, undefined, "should satisfy reflexivity", A.make, V$10.reflexivity),
                tl: {
                  hd: Curry._5(Q.property2, undefined, "should satisfy antisymmetry", A.make, A.make, V$10.antisymmetry),
                  tl: {
                    hd: Curry._6(Q.property3, undefined, "should satisfy transitivity", A.make, A.make, A.make, V$10.transitivity),
                    tl: /* [] */0
                  }
                }
              });
  };
  var Ord$1 = {
    V: V$10,
    suite: suite$10
  };
  var infix = Curry._2(T.suite, "Option.Infix", {
        hd: Curry._2(T.test, "should apply a default value if it's None", (function (param) {
                var $pipe$question = Bastet__Option.Infix.$pipe$question;
                Curry._4(T.check, T.string, undefined, Curry._2($pipe$question, "foo", "bar"), "bar");
                Curry._4(T.check, T.string, undefined, Curry._2($pipe$question, "foo", undefined), "foo");
              })),
        tl: /* [] */0
      });
  var foldable = Curry._2(T.suite, "Option.Foldable", {
        hd: Curry._2(T.test, "should do a left fold", (function (param) {
                Curry._4(T.check, T.$$int, undefined, Bastet__Option.Foldable.fold_left((function (prim0, prim1) {
                            return prim0 + prim1 | 0;
                          }), 0, 1), 1);
              })),
        tl: {
          hd: Curry._2(T.test, "should do a right fold", (function (param) {
                  Curry._4(T.check, T.$$int, undefined, Bastet__Option.Foldable.fold_right((function (prim0, prim1) {
                              return prim0 + prim1 | 0;
                            }), 0, 1), 1);
                  Curry._4(T.check, T.$$int, undefined, Bastet__Option.Foldable.fold_right((function (prim0, prim1) {
                              return prim0 + prim1 | 0;
                            }), 0, undefined), 0);
                })),
          tl: {
            hd: Curry._2(T.test, "should do a map fold (int)", (function (param) {
                    var fold_map = Bastet__Functors.OptionF.Int.Additive.Fold_Map.fold_map;
                    Curry._4(T.check, T.$$int, undefined, Curry._2(fold_map, (function (param) {
                                return (param << 1);
                              }), 3), 6);
                    Curry._4(T.check, T.$$int, undefined, Curry._2(fold_map, (function (param) {
                                return 1 + param | 0;
                              }), undefined), 0);
                  })),
            tl: {
              hd: Curry._2(T.test, "should do a map fold (list)", (function (param) {
                      var fold_map = Bastet__Functors.OptionF.List.Fold_Map_Plus.fold_map;
                      Curry._4(T.check, Curry._1(T.list, T.$$int), undefined, Curry._2(fold_map, (function (x) {
                                  return {
                                          hd: x,
                                          tl: /* [] */0
                                        };
                                }), 123), {
                            hd: 123,
                            tl: /* [] */0
                          });
                    })),
              tl: /* [] */0
            }
          }
        }
      });
  var traverse = Bastet__Functors.OptionF.List.Traversable.traverse;
  var sequence = Bastet__Functors.OptionF.List.Traversable.sequence;
  var traversable = Curry._2(T.suite, "Option.Traversable", {
        hd: Curry._2(T.test, "should traverse the list", (function (param) {
                var positive_int = function (x) {
                  if (x >= 0) {
                    return {
                            hd: x,
                            tl: /* [] */0
                          };
                  } else {
                    return /* [] */0;
                  }
                };
                Curry._4(T.check, Curry._1(T.list, Curry._1(T.option, T.$$int)), undefined, Curry._2(traverse, positive_int, 123), {
                      hd: 123,
                      tl: /* [] */0
                    });
              })),
        tl: {
          hd: Curry._2(T.test, "should sequence the list", (function (param) {
                  Curry._4(T.check, Curry._1(T.list, Curry._1(T.option, T.$$int)), undefined, Curry._1(sequence, {
                            hd: 3,
                            tl: {
                              hd: 4,
                              tl: {
                                hd: 5,
                                tl: /* [] */0
                              }
                            }
                          }), {
                        hd: 3,
                        tl: {
                          hd: 4,
                          tl: {
                            hd: 5,
                            tl: /* [] */0
                          }
                        }
                      });
                  Curry._4(T.check, Curry._1(T.list, Curry._1(T.option, T.$$int)), undefined, Curry._1(sequence, undefined), {
                        hd: undefined,
                        tl: /* [] */0
                      });
                })),
          tl: /* [] */0
        }
      });
  var suites = Stdlib__ListLabels.append({
        hd: infix,
        tl: {
          hd: foldable,
          tl: {
            hd: traversable,
            tl: /* [] */0
          }
        }
      }, Stdlib__ListLabels.map((function (suite) {
              return Curry._1(suite, "Option");
            }), {
            hd: suite,
            tl: {
              hd: suite$1,
              tl: {
                hd: suite$2,
                tl: {
                  hd: suite$3,
                  tl: {
                    hd: suite$4,
                    tl: {
                      hd: suite$5,
                      tl: {
                        hd: suite$6,
                        tl: {
                          hd: suite$8,
                          tl: {
                            hd: suite$7,
                            tl: {
                              hd: suite$9,
                              tl: {
                                hd: suite$10,
                                tl: /* [] */0
                              }
                            }
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          }));
  return {
          M: M,
          Semigroup: Semigroup$1,
          Monoid: Monoid$1,
          Functor: Functor$1,
          Apply: Apply$1,
          Applicative: Applicative$1,
          Monad: Monad$1,
          Alt: Alt$1,
          Plus: Plus$1,
          Alternative: Alternative$1,
          Eq: Eq$1,
          Ord: Ord$1,
          infix: infix,
          foldable: foldable,
          traversable: traversable,
          suites: suites
        };
}

function $$String$1(T, Q, A) {
  var $less$dot = Bastet__Function.Infix.$less$dot;
  var Medial_Magma = function (M, E, A) {
    var V = Bastet__Verify.Compare.Medial_Magma(M, E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Medial_Magma", {
                  hd: Curry._7(Q.property4, undefined, "should satisfy bicommutativity", A.make, A.make, A.make, A.make, V.bicommutativity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Quasigroup = function (QG, E, A) {
    var V = Bastet__Verify.Compare.Quasigroup(QG, E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Quasigroup", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.cancellative),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Semiring = function (S, E, A) {
    var V = Bastet__Verify.Compare.Semiring(S, E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Semiring", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy additive associativity", A.make, A.make, A.make, V.additive_associativity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy additive identity", A.make, V.additive_identity),
                    tl: {
                      hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V.commutativity),
                      tl: {
                        hd: Curry._6(Q.property3, undefined, "should satisfy multiplicative associativity", A.make, A.make, A.make, V.multiplicative_associativity),
                        tl: {
                          hd: Curry._4(Q.property, undefined, "should satisfy multiplicative identity", A.make, V.multiplicative_identity),
                          tl: {
                            hd: Curry._6(Q.property3, undefined, "should satisfy distributivity", A.make, A.make, A.make, V.distributivity),
                            tl: /* [] */0
                          }
                        }
                      }
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Division_Ring = function (D, E, A) {
    var V = Bastet__Verify.Compare.Division_Ring(D, E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Division_Ring", {
                  hd: Curry._2(T.test, "should be a non-zero ring (zero is not one)", (function (param) {
                          Curry._4(T.check, T.bool, undefined, V.non_zero_ring, true);
                        })),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy multiplicative inverse", A.make, V.multiplicative_inverse),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Euclidean_Ring = function (E, EQ, A) {
    var V = Bastet__Verify.Compare.Euclidean_Ring(E, EQ);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Euclidean_Ring", {
                  hd: Curry._2(T.test, "should be a non-zero ring (zero is not one)", (function (param) {
                          Curry._4(T.check, T.bool, undefined, V.non_zero_ring, true);
                        })),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy integral domain", A.make, A.make, V.integral_domain),
                    tl: {
                      hd: Curry._4(Q.property, undefined, "should satisfy non negative degree", A.make, V.non_negative_degree),
                      tl: {
                        hd: Curry._5(Q.property2, undefined, "should satisfy the properties for remainder", A.make, A.make, V.remainder),
                        tl: {
                          hd: Curry._5(Q.property2, undefined, "should satisfy submultiplicative", A.make, A.make, V.submultiplicative),
                          tl: /* [] */0
                        }
                      }
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Compare = {
    Medial_Magma: Medial_Magma,
    Quasigroup: Quasigroup,
    Semiring: Semiring,
    Division_Ring: Division_Ring,
    Euclidean_Ring: Euclidean_Ring
  };
  var Medial_Magma$1 = function (M, A) {
    var V = Bastet__Verify.Medial_Magma(M);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Medial_Magma", {
                  hd: Curry._7(Q.property4, undefined, "should satisfy bicommutativity", A.make, A.make, A.make, A.make, V.bicommutativity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Semigroup = function (S, A) {
    var V = Bastet__Verify.Semigroup(S);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Semigroup", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.associativity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Quasigroup$1 = function (QG, A) {
    var V = Bastet__Verify.Quasigroup(QG);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Quasigroup", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.cancellative),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Loop = function (L, A) {
    var V = Bastet__Verify.Loop(L);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Loop", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V.identity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Group = function (G, A) {
    var V = Bastet__Verify.Group(G);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Group", {
                  hd: Curry._4(Q.property, undefined, "should satisfy invertibility", A.make, V.invertibility),
                  tl: {
                    hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.associativity),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Abelian_Group = function (G, A) {
    var V = Bastet__Verify.Abelian_Group(G);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Abelian_Group", {
                  hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V.commutativity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Monoid = function (M, A) {
    var V = Bastet__Verify.Monoid(M);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Monoid", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V.identity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Functor = function (F, AA) {
    var V = Bastet__Verify.Functor(F);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Functor", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", Curry._1(AA.make, Q.arbitrary_int), V.identity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy composition", Curry._1(AA.make, Q.arbitrary_int), (function (a) {
                            return Curry._3(V.composition, (function (param) {
                                          return "!" + param;
                                        }), (function (prim) {
                                          return String(prim);
                                        }), a);
                          })),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Apply = function (A, AA) {
    var V = Bastet__Verify.Apply(A);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Apply", {
                  hd: Curry._4(Q.property, undefined, "should satisfy associative composition", Curry._1(AA.make, Q.arbitrary_int), (function (n) {
                          return Curry._3(V.associative_composition, Curry._1(A.pure, (function (param) {
                                            return "!" + param;
                                          })), Curry._1(A.pure, (function (prim) {
                                            return String(prim);
                                          })), n);
                        })),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Applicative = function (A, AA) {
    var V = Bastet__Verify.Applicative(A);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Applicative", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", Curry._1(AA.make, Q.arbitrary_int), V.identity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy homomorphism", Curry._1(AA.make, Q.arbitrary_int), Curry._1(V.homomorphism, Curry._1(A.map, (function (prim) {
                                    return String(prim);
                                  })))),
                    tl: {
                      hd: Curry._4(Q.property, undefined, "should satisfy interchange", Q.arbitrary_int, Curry._1(V.interchange, Curry._1(A.pure, (function (prim) {
                                      return String(prim);
                                    })))),
                      tl: /* [] */0
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Monad = function (M, AA) {
    var V = Bastet__Verify.Monad(M);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Monad", {
                  hd: Curry._4(Q.property, undefined, "should satisfy associativity", Curry._1(AA.make_bound, Q.arbitrary_int), Curry._2(V.associativity, Curry._2($less$dot, M.pure, (function (prim) {
                                  return String(prim);
                                })), Curry._2($less$dot, M.pure, (function (param) {
                                  return "!" + param;
                                })))),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy identity", Q.arbitrary_int, Curry._1(V.identity, Curry._2($less$dot, M.pure, (function (prim) {
                                    return String(prim);
                                  })))),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Alt = function (A, AA) {
    var V = Bastet__Verify.Alt(A);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Alt", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", Curry._1(AA.make, Q.arbitrary_int), Curry._1(AA.make, Q.arbitrary_int), Curry._1(AA.make, Q.arbitrary_int), V.associativity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy distributivity", Curry._1(AA.make, Q.arbitrary_int), Curry._1(AA.make, Q.arbitrary_int), Curry._1(V.distributivity, (function (prim) {
                                return String(prim);
                              }))),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Alternative = function (A, AA) {
    var V = Bastet__Verify.Alternative(A);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Alternative", {
                  hd: Curry._4(Q.property, undefined, "should satisfy distributivity", Curry._1(AA.make, Q.arbitrary_int), Curry._2(V.distributivity, Curry._1(A.pure, (function (param) {
                                  return (param << 1);
                                })), Curry._1(A.pure, (function (param) {
                                  return 3 + param | 0;
                                })))),
                  tl: {
                    hd: Curry._2(T.test, "should satisfy annihalation", (function (param) {
                            Curry._4(T.check, T.bool, undefined, Curry._1(V.annihalation, Curry._1(A.pure, (function (prim) {
                                            return String(prim);
                                          }))), true);
                          })),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Plus = function (P, AA) {
    var V = Bastet__Verify.Plus(P);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Plus", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", Curry._1(AA.make, Q.arbitrary_int), V.identity),
                  tl: {
                    hd: Curry._2(T.test, "should satisfy annihalation", (function (param) {
                            Curry._4(T.check, T.bool, undefined, Curry._1(V.annihalation, (function (prim) {
                                        return String(prim);
                                      })), true);
                          })),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Eq = function (E, A) {
    var V = Bastet__Verify.Eq(E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Eq", {
                  hd: Curry._4(Q.property, undefined, "should satisfy reflexivity", A.make, V.reflexivity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy symmetry", A.make, A.make, V.symmetry),
                    tl: {
                      hd: Curry._6(Q.property3, undefined, "should satisfy transitivity", A.make, A.make, A.make, V.transitivity),
                      tl: /* [] */0
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Ord = function (O, A) {
    var V = Bastet__Verify.Ord(O);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Ord", {
                  hd: Curry._4(Q.property, undefined, "should satisfy reflexivity", A.make, V.reflexivity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy antisymmetry", A.make, A.make, V.antisymmetry),
                    tl: {
                      hd: Curry._6(Q.property3, undefined, "should satisfy transitivity", A.make, A.make, A.make, V.transitivity),
                      tl: /* [] */0
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Join_Semilattice = function (JS, A) {
    var V = Bastet__Verify.Join_Semilattice(JS);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Join_Semilattice", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.associativity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V.commutativity),
                    tl: {
                      hd: Curry._4(Q.property, undefined, "should satisfy idempotency", A.make, V.idempotency),
                      tl: /* [] */0
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Meet_Semilattice = function (MS, A) {
    var V = Bastet__Verify.Meet_Semilattice(MS);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Meet_Semilattice", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.associativity),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V.commutativity),
                    tl: {
                      hd: Curry._4(Q.property, undefined, "should satisfy idempotency", A.make, V.idempotency),
                      tl: /* [] */0
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Bounded_Join_Semilattice = function (BJS, A) {
    var V = Bastet__Verify.Bounded_Join_Semilattice(BJS);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Bounded_Join_Semilattice", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V.identity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Bounded_Meet_Semilattice = function (BMS, A) {
    var V = Bastet__Verify.Bounded_Meet_Semilattice(BMS);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Bounded_Meet_Semilattice", {
                  hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V.identity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Lattice = function (L, A) {
    var V = Bastet__Verify.Lattice(L);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Lattice", {
                  hd: Curry._5(Q.property2, undefined, "should satisfy absorption", A.make, A.make, V.absorption),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Bounded_Lattice = function (BL, A) {
    var V = Bastet__Verify.Bounded_Lattice(BL);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Bounded_Lattice", {
                  hd: Curry._5(Q.property2, undefined, "should satisfy absorption", A.make, A.make, V.absorption),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Distributive_Lattice = function (DL, A) {
    var V = Bastet__Verify.Distributive_Lattice(DL);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Distributive_Lattice", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy distributivity", A.make, A.make, A.make, V.distributivity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Bounded_Distributive_Lattice = function (BDL, A) {
    var V = Bastet__Verify.Bounded_Distributive_Lattice(BDL);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Bounded_Distributive_Lattice", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy distributivity", A.make, A.make, A.make, V.distributivity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Heyting_Algebra = function (HA, A) {
    var V = Bastet__Verify.Heyting_Algebra(HA);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Heyting_Algebra", {
                  hd: Curry._4(Q.property, undefined, "should satisfy pseudocomplement", A.make, V.pseudocomplement),
                  tl: {
                    hd: Curry._6(Q.property3, undefined, "should satisfy relative pseudocomplement", A.make, A.make, A.make, V.relative_pseudocomplement),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Involutive_Heyting_Algebra = function (IHA, A) {
    var V = Bastet__Verify.Involutive_Heyting_Algebra(IHA);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Involutive_Heyting_Algebra", {
                  hd: Curry._4(Q.property, undefined, "should satisfy involution", A.make, V.involution),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Boolean_Algebra = function (BA, A) {
    var V = Bastet__Verify.Boolean_Algebra(BA);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Boolean_Algebra", {
                  hd: Curry._4(Q.property, undefined, "should satisfy the law of excluded middle", A.make, V.excluded_middle),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Bounded = function (B, A) {
    var V = Bastet__Verify.Bounded(B);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Bounded", {
                  hd: Curry._4(Q.property, undefined, "should satisfy bounded", A.make, V.bounded),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Semiring$1 = function (S, A) {
    var V = Bastet__Verify.Semiring(S);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Semiring", {
                  hd: Curry._6(Q.property3, undefined, "should satisfy additive associativity", A.make, A.make, A.make, V.additive_associativity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy additive identity", A.make, V.additive_identity),
                    tl: {
                      hd: Curry._5(Q.property2, undefined, "should satisfy commutativity", A.make, A.make, V.commutativity),
                      tl: {
                        hd: Curry._6(Q.property3, undefined, "should satisfy multiplicative associativity", A.make, A.make, A.make, V.multiplicative_associativity),
                        tl: {
                          hd: Curry._4(Q.property, undefined, "should satisfy multiplicative identity", A.make, V.multiplicative_identity),
                          tl: {
                            hd: Curry._6(Q.property3, undefined, "should satisfy distributivity", A.make, A.make, A.make, V.distributivity),
                            tl: /* [] */0
                          }
                        }
                      }
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Ring = function (R, A) {
    var V = Bastet__Verify.Ring(R);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Ring", {
                  hd: Curry._4(Q.property, undefined, "should satisfy additive inverse", A.make, V.additive_inverse),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Commutative_Ring = function (C, A) {
    var V = Bastet__Verify.Commutative_Ring(C);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Commutative_Ring", {
                  hd: Curry._5(Q.property2, undefined, "should satisfy multiplicative commutativity", A.make, A.make, V.multiplicative_commutativity),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Division_Ring$1 = function (D, A) {
    var V = Bastet__Verify.Division_Ring(D);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Division_Ring", {
                  hd: Curry._2(T.test, "should be a non-zero ring (zero is not one)", (function (param) {
                          Curry._4(T.check, T.bool, undefined, V.non_zero_ring, true);
                        })),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy multiplicative inverse", A.make, V.multiplicative_inverse),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Euclidean_Ring$1 = function (E, A) {
    var V = Bastet__Verify.Euclidean_Ring(E);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Euclidean_Ring", {
                  hd: Curry._2(T.test, "should be a non-zero ring (zero is not one)", (function (param) {
                          Curry._4(T.check, T.bool, undefined, V.non_zero_ring, true);
                        })),
                  tl: {
                    hd: Curry._5(Q.property2, undefined, "should satisfy integral domain", A.make, A.make, V.integral_domain),
                    tl: {
                      hd: Curry._4(Q.property, undefined, "should satisfy non negative degree", A.make, V.non_negative_degree),
                      tl: {
                        hd: Curry._5(Q.property2, undefined, "should satisfy the properties for remainder", A.make, A.make, V.remainder),
                        tl: {
                          hd: Curry._5(Q.property2, undefined, "should satisfy submultiplicative", A.make, A.make, V.submultiplicative),
                          tl: /* [] */0
                        }
                      }
                    }
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Field = function (F, A) {
    var V = Bastet__Verify.Field(F);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Field", {
                  hd: Curry._5(Q.property2, undefined, "should satisfy non zero multiplicative inverse", A.make, A.make, V.non_zero_multiplicative_inverse),
                  tl: /* [] */0
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var Invariant = function (I, AA) {
    var V = Bastet__Verify.Invariant(I);
    var suite = function (name) {
      return Curry._2(T.suite, name + ".Invariant", {
                  hd: Curry._4(Q.property, undefined, "should satisfy reflexivity", Curry._1(AA.make, Q.arbitrary_int), V.identity),
                  tl: {
                    hd: Curry._4(Q.property, undefined, "should satisfy composition", Curry._1(AA.make, Q.arbitrary_int), Curry._4(V.composition, (function (prim) {
                                return prim;
                              }), (function (prim) {
                                return prim | 0;
                              }), Curry._2($less$dot, (function (param) {
                                    return Math.imul(3, param);
                                  }), (function (prim) {
                                    return prim | 0;
                                  })), Curry._2($less$dot, (function (param) {
                                    return 4.0 * param;
                                  }), (function (prim) {
                                    return prim;
                                  })))),
                    tl: /* [] */0
                  }
                });
    };
    return {
            V: V,
            suite: suite
          };
  };
  var M = {
    $less$dot: $less$dot,
    Compare: Compare,
    Medial_Magma: Medial_Magma$1,
    Semigroup: Semigroup,
    Quasigroup: Quasigroup$1,
    Loop: Loop,
    Group: Group,
    Abelian_Group: Abelian_Group,
    Monoid: Monoid,
    Functor: Functor,
    Apply: Apply,
    Applicative: Applicative,
    Monad: Monad,
    Alt: Alt,
    Alternative: Alternative,
    Plus: Plus,
    Eq: Eq,
    Ord: Ord,
    Join_Semilattice: Join_Semilattice,
    Meet_Semilattice: Meet_Semilattice,
    Bounded_Join_Semilattice: Bounded_Join_Semilattice,
    Bounded_Meet_Semilattice: Bounded_Meet_Semilattice,
    Lattice: Lattice,
    Bounded_Lattice: Bounded_Lattice,
    Distributive_Lattice: Distributive_Lattice,
    Bounded_Distributive_Lattice: Bounded_Distributive_Lattice,
    Heyting_Algebra: Heyting_Algebra,
    Involutive_Heyting_Algebra: Involutive_Heyting_Algebra,
    Boolean_Algebra: Boolean_Algebra,
    Bounded: Bounded,
    Semiring: Semiring$1,
    Ring: Ring,
    Commutative_Ring: Commutative_Ring,
    Division_Ring: Division_Ring$1,
    Euclidean_Ring: Euclidean_Ring$1,
    Field: Field,
    Invariant: Invariant
  };
  var S = Bastet__String.Semigroup;
  var V = Bastet__Verify.Semigroup(S);
  var suite = function (name) {
    return Curry._2(T.suite, name + ".Semigroup", {
                hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V.associativity),
                tl: /* [] */0
              });
  };
  var Semigroup$1 = {
    V: V,
    suite: suite
  };
  var M$1 = Bastet__String.Monoid;
  var V$1 = Bastet__Verify.Monoid(M$1);
  var suite$1 = function (name) {
    return Curry._2(T.suite, name + ".Monoid", {
                hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V$1.identity),
                tl: /* [] */0
              });
  };
  var Monoid$1 = {
    V: V$1,
    suite: suite$1
  };
  var QG = Bastet__String.Quasigroup;
  var V$2 = Bastet__Verify.Quasigroup(QG);
  var suite$2 = function (name) {
    return Curry._2(T.suite, name + ".Quasigroup", {
                hd: Curry._6(Q.property3, undefined, "should satisfy associativity", A.make, A.make, A.make, V$2.cancellative),
                tl: /* [] */0
              });
  };
  var Quasigroup$2 = {
    V: V$2,
    suite: suite$2
  };
  var L = Bastet__String.Loop;
  var V$3 = Bastet__Verify.Loop(L);
  var suite$3 = function (name) {
    return Curry._2(T.suite, name + ".Loop", {
                hd: Curry._4(Q.property, undefined, "should satisfy identity", A.make, V$3.identity),
                tl: /* [] */0
              });
  };
  var Loop$1 = {
    V: V$3,
    suite: suite$3
  };
  var E = Bastet__String.Eq;
  var V$4 = Bastet__Verify.Eq(E);
  var suite$4 = function (name) {
    return Curry._2(T.suite, name + ".Eq", {
                hd: Curry._4(Q.property, undefined, "should satisfy reflexivity", A.make, V$4.reflexivity),
                tl: {
                  hd: Curry._5(Q.property2, undefined, "should satisfy symmetry", A.make, A.make, V$4.symmetry),
                  tl: {
                    hd: Curry._6(Q.property3, undefined, "should satisfy transitivity", A.make, A.make, A.make, V$4.transitivity),
                    tl: /* [] */0
                  }
                }
              });
  };
  var Eq$1 = {
    V: V$4,
    suite: suite$4
  };
  var O = Bastet__String.Ord;
  var V$5 = Bastet__Verify.Ord(O);
  var suite$5 = function (name) {
    return Curry._2(T.suite, name + ".Ord", {
                hd: Curry._4(Q.property, undefined, "should satisfy reflexivity", A.make, V$5.reflexivity),
                tl: {
                  hd: Curry._5(Q.property2, undefined, "should satisfy antisymmetry", A.make, A.make, V$5.antisymmetry),
                  tl: {
                    hd: Curry._6(Q.property3, undefined, "should satisfy transitivity", A.make, A.make, A.make, V$5.transitivity),
                    tl: /* [] */0
                  }
                }
              });
  };
  var Ord$1 = {
    V: V$5,
    suite: suite$5
  };
  var suites = Stdlib__ListLabels.map((function (suite) {
          return Curry._1(suite, "String");
        }), {
        hd: suite,
        tl: {
          hd: suite$1,
          tl: {
            hd: suite$2,
            tl: {
              hd: suite$3,
              tl: {
                hd: suite$4,
                tl: {
                  hd: suite$5,
                  tl: /* [] */0
                }
              }
            }
          }
        }
      });
  return {
          M: M,
          Semigroup: Semigroup$1,
          Monoid: Monoid$1,
          Quasigroup: Quasigroup$2,
          Loop: Loop$1,
          Eq: Eq$1,
          Ord: Ord$1,
          suites: suites
        };
}

exports.Make = Make;
exports.$$Array = $$Array;
exports.Bool = Bool;
exports.Default = Default;
exports.Float = Float;
exports.List = List;
exports.Int = Int;
exports.$$Option = $$Option;
exports.$$String = $$String$1;
/* Bastet__Int Not a pure module */
