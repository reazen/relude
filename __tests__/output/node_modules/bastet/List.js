// Generated by Melange
'use strict';

var Curry = require("melange.runtime/curry.js");
var Bastet__Infix = require("./Infix.js");
var Bastet__String = require("./String.js");
var Bastet__Default = require("./Default.js");
var Bastet__Functions = require("./Functions.js");
var Stdlib__ListLabels = require("melange/./listLabels.js");

function map(f) {
  return function (param) {
    return Stdlib__ListLabels.map(f, param);
  };
}

var Functor = {
  map: map
};

var Alt = {
  map: map,
  alt: Stdlib__ListLabels.append
};

function apply(fn_array, a) {
  return Stdlib__ListLabels.fold_left((function (acc, f) {
                return Stdlib__ListLabels.append(acc, Stdlib__ListLabels.map(f, a));
              }), /* [] */0, fn_array);
}

var Apply = {
  map: map,
  apply: apply
};

function pure(a) {
  return {
          hd: a,
          tl: /* [] */0
        };
}

var Applicative = {
  map: map,
  apply: apply,
  pure: pure
};

function flat_map(x, f) {
  return Stdlib__ListLabels.fold_left((function (acc, a) {
                return Stdlib__ListLabels.append(acc, Curry._1(f, a));
              }), /* [] */0, x);
}

var Monad = {
  map: map,
  apply: apply,
  pure: pure,
  flat_map: flat_map
};

var Plus = {
  map: map,
  alt: Stdlib__ListLabels.append,
  empty: /* [] */0
};

var Alternative = {
  apply: apply,
  pure: pure,
  map: map,
  alt: Stdlib__ListLabels.append,
  empty: /* [] */0
};

function fold_left(f, init) {
  return function (param) {
    return Stdlib__ListLabels.fold_left(f, init, param);
  };
}

function fold_right(f, init) {
  return function (param) {
    return Stdlib__ListLabels.fold_right(f, param, init);
  };
}

function Foldable_Fold_Map(funarg) {
  var D = Bastet__Default.Fold_Map(funarg, {
        fold_left: fold_left,
        fold_right: fold_right
      });
  return {
          fold_map: D.fold_map_default_left
        };
}

function Foldable_Fold_Map_Any(funarg) {
  var D = Bastet__Default.Fold_Map_Any(funarg, {
        fold_left: fold_left,
        fold_right: fold_right
      });
  return {
          fold_map: D.fold_map_default_left
        };
}

function Foldable_Fold_Map_Plus(funarg) {
  var D = Bastet__Default.Fold_Map_Plus(funarg, {
        fold_left: fold_left,
        fold_right: fold_right
      });
  return {
          fold_map: D.fold_map_default_left
        };
}

var Foldable = {
  fold_left: fold_left,
  fold_right: fold_right,
  Fold_Map: Foldable_Fold_Map,
  Fold_Map_Any: Foldable_Fold_Map_Any,
  Fold_Map_Plus: Foldable_Fold_Map_Plus
};

function unfold(f, init) {
  var match = Curry._1(f, init);
  if (match !== undefined) {
    return {
            hd: match[0],
            tl: unfold(f, match[1])
          };
  } else {
    return /* [] */0;
  }
}

var Unfoldable = {
  unfold: unfold
};

function Traversable(A) {
  var I = Bastet__Infix.Apply(A);
  var traverse = function (f) {
    var arg = Curry._1(A.pure, /* [] */0);
    return function (param) {
      return Stdlib__ListLabels.fold_right((function (acc, x) {
                    return Curry._2(I.$less$star$great, Curry._2(I.$less$star$great, Curry._1(A.pure, (function (y, ys) {
                                          return {
                                                  hd: y,
                                                  tl: ys
                                                };
                                        })), Curry._1(f, acc)), x);
                  }), param, arg);
    };
  };
  var D = Bastet__Default.Sequence({
        traverse: traverse
      });
  return {
          map: map,
          fold_left: fold_left,
          fold_right: fold_right,
          Fold_Map: Foldable_Fold_Map,
          Fold_Map_Any: Foldable_Fold_Map_Any,
          Fold_Map_Plus: Foldable_Fold_Map_Plus,
          traverse: traverse,
          sequence: D.sequence_default
        };
}

function Eq(E) {
  var eq = function (xs, ys) {
    if (Stdlib__ListLabels.length(xs) === Stdlib__ListLabels.length(ys)) {
      return Stdlib__ListLabels.fold_left((function (acc, param) {
                    if (acc) {
                      return Curry._2(E.eq, param[0], param[1]);
                    } else {
                      return false;
                    }
                  }), true, Stdlib__ListLabels.combine(xs, ys));
    } else {
      return false;
    }
  };
  return {
          eq: eq
        };
}

function Show(S) {
  var F = Bastet__Functions.Foldable(Foldable);
  var M = Curry._1(F.Monoid, Bastet__String.Monoid);
  var show = function (xs) {
    return "[" + (Curry._2(M.intercalate, ", ", Stdlib__ListLabels.map(S.show, xs)) + "]");
  };
  return {
          show: show
        };
}

var include = Bastet__Infix.Monad(Monad);

var include$1 = Bastet__Infix.Alternative(Alternative);

var Infix_$great$great$eq = include.$great$great$eq;

var Infix_$eq$less$less = include.$eq$less$less;

var Infix_$great$eq$great = include.$great$eq$great;

var Infix_$less$eq$less = include.$less$eq$less;

var Infix_$less$pipe$great = include$1.$less$pipe$great;

var Infix_$less$$great = include$1.$less$$great;

var Infix_$less$at$great = include$1.$less$at$great;

var Infix_$less$star$great = include$1.$less$star$great;

var Infix = {
  $great$great$eq: Infix_$great$great$eq,
  $eq$less$less: Infix_$eq$less$less,
  $great$eq$great: Infix_$great$eq$great,
  $less$eq$less: Infix_$less$eq$less,
  $less$pipe$great: Infix_$less$pipe$great,
  $less$$great: Infix_$less$$great,
  $less$at$great: Infix_$less$at$great,
  $less$star$great: Infix_$less$star$great
};

exports.Functor = Functor;
exports.Alt = Alt;
exports.Apply = Apply;
exports.Applicative = Applicative;
exports.Monad = Monad;
exports.Plus = Plus;
exports.Alternative = Alternative;
exports.Foldable = Foldable;
exports.Unfoldable = Unfoldable;
exports.Traversable = Traversable;
exports.Eq = Eq;
exports.Show = Show;
exports.Infix = Infix;
/* include Not a pure module */
