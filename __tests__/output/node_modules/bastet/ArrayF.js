// Generated by Melange
'use strict';

var Curry = require("melange.runtime/curry.js");
var Caml_array = require("melange.runtime/caml_array.js");
var Bastet__Infix = require("./Infix.js");
var Bastet__String = require("./String.js");
var Bastet__Default = require("./Default.js");
var Bastet__Functions = require("./Functions.js");
var Stdlib__ArrayLabels = require("melange/./arrayLabels.js");

function Make(A) {
  var zip_with = function (f, xs, ys) {
    var l = Curry._1(A.length, xs) < Curry._1(A.length, ys) ? Curry._1(A.length, xs) : Curry._1(A.length, ys);
    var index = 0;
    var result;
    for(var i = 0; i < l; ++i){
      var value = Curry._2(f, Caml_array.get(xs, i), Caml_array.get(ys, i));
      var arr = result;
      if (arr !== undefined) {
        Caml_array.set(arr, index, value);
      } else {
        result = Curry._2(A.make, l, value);
      }
      index = index + 1 | 0;
    }
    var array = result;
    if (array !== undefined) {
      return array;
    } else {
      return [];
    }
  };
  var zip = function (xs, ys) {
    return zip_with((function (a, b) {
                  return [
                          a,
                          b
                        ];
                }), xs, ys);
  };
  var map = A.map;
  var Functor = {
    map: map
  };
  var alt = A.append;
  var Alt = {
    map: map,
    alt: alt
  };
  var apply = function (fn_array, a) {
    return Curry._3(A.fold_left, (function (acc, f) {
                  return Curry._2(alt, acc, Curry._2(map, f, a));
                }), [], fn_array);
  };
  var Apply = {
    map: map,
    apply: apply
  };
  var pure = function (a) {
    return [a];
  };
  var Applicative = {
    map: map,
    apply: apply,
    pure: pure
  };
  var flat_map = function (x, f) {
    return Curry._3(A.fold_left, (function (acc, a) {
                  return Curry._2(alt, acc, Curry._1(f, a));
                }), [], x);
  };
  var Monad = {
    map: map,
    apply: apply,
    pure: pure,
    flat_map: flat_map
  };
  var fold_left = A.fold_left;
  var fold_right = function (f, init) {
    return function (param) {
      return Stdlib__ArrayLabels.fold_right(f, param, init);
    };
  };
  var Foldable_Fold_Map = function (funarg) {
    var D = Bastet__Default.Fold_Map(funarg, {
          fold_left: fold_left,
          fold_right: fold_right
        });
    return {
            fold_map: D.fold_map_default_left
          };
  };
  var Foldable_Fold_Map_Any = function (funarg) {
    var D = Bastet__Default.Fold_Map_Any(funarg, {
          fold_left: fold_left,
          fold_right: fold_right
        });
    return {
            fold_map: D.fold_map_default_left
          };
  };
  var Foldable_Fold_Map_Plus = function (funarg) {
    var D = Bastet__Default.Fold_Map_Plus(funarg, {
          fold_left: fold_left,
          fold_right: fold_right
        });
    return {
            fold_map: D.fold_map_default_left
          };
  };
  var Foldable = {
    fold_left: fold_left,
    fold_right: fold_right,
    Fold_Map: Foldable_Fold_Map,
    Fold_Map_Any: Foldable_Fold_Map_Any,
    Fold_Map_Plus: Foldable_Fold_Map_Plus
  };
  var unfold = function (f, init) {
    var match = Curry._1(f, init);
    if (match !== undefined) {
      return Curry._2(alt, [match[0]], unfold(f, match[1]));
    } else {
      return [];
    }
  };
  var Unfoldable = {
    unfold: unfold
  };
  var Traversable = function (A) {
    var I = Bastet__Infix.Apply(A);
    var traverse = function (f) {
      var arg = Curry._1(A.pure, []);
      return function (param) {
        return Stdlib__ArrayLabels.fold_right((function (acc, x) {
                      return Curry._2(I.$less$star$great, Curry._2(I.$less$star$great, Curry._1(A.pure, (function (x, y) {
                                            return Curry._2(alt, [x], y);
                                          })), Curry._1(f, acc)), x);
                    }), param, arg);
      };
    };
    var D = Bastet__Default.Sequence({
          traverse: traverse
        });
    return {
            map: map,
            fold_left: fold_left,
            fold_right: fold_right,
            Fold_Map: Foldable_Fold_Map,
            Fold_Map_Any: Foldable_Fold_Map_Any,
            Fold_Map_Plus: Foldable_Fold_Map_Plus,
            traverse: traverse,
            sequence: D.sequence_default
          };
  };
  var Eq = function (E) {
    var eq = function (xs, ys) {
      if (Curry._1(A.length, xs) === Curry._1(A.length, ys)) {
        return Curry._2(A.every, (function (param) {
                      return Curry._2(E.eq, param[0], param[1]);
                    }), zip(xs, ys));
      } else {
        return false;
      }
    };
    return {
            eq: eq
          };
  };
  var Ord = function (O) {
    var eq = function (xs, ys) {
      if (Curry._1(A.length, xs) === Curry._1(A.length, ys)) {
        return Curry._2(A.every, (function (param) {
                      return Curry._2(O.eq, param[0], param[1]);
                    }), zip(xs, ys));
      } else {
        return false;
      }
    };
    var compare = function (xs, ys) {
      if (Curry._1(A.length, xs) !== Curry._1(A.length, ys)) {
        if (Curry._1(A.length, xs) < Curry._1(A.length, ys)) {
          return "less_than";
        } else {
          return "greater_than";
        }
      }
      var index = {
        contents: 0
      };
      return Curry._3(A.fold_left, (function (acc, e) {
                    var result = acc !== "equal_to" ? acc : Curry._2(O.compare, e, Caml_array.get(ys, index.contents));
                    index.contents = index.contents + 1 | 0;
                    return result;
                  }), "equal_to", xs);
    };
    return {
            eq: eq,
            compare: compare
          };
  };
  var Show = function (S) {
    var F = Bastet__Functions.Foldable(Foldable);
    var M = Curry._1(F.Monoid, Bastet__String.Monoid);
    var show = function (xs) {
      return "[" + (Curry._2(M.intercalate, ", ", Curry._2(map, S.show, xs)) + "]");
    };
    return {
            show: show
          };
  };
  var imap = function (f, param) {
    return Curry._1(map, f);
  };
  var Invariant = {
    imap: imap
  };
  var extend = function (f, xs) {
    return Curry._2(A.mapi, (function (param, i) {
                  return Curry._1(f, Curry._3(A.slice, i, Curry._1(A.length, xs), xs));
                }), xs);
  };
  var Extend = {
    map: map,
    extend: extend
  };
  var include = Bastet__Infix.Monad(Monad);
  var include$1 = Bastet__Infix.Extend(Extend);
  var Infix_$less$$great = include.$less$$great;
  var Infix_$less$at$great = include.$less$at$great;
  var Infix_$less$star$great = include.$less$star$great;
  var Infix_$great$great$eq = include.$great$great$eq;
  var Infix_$eq$less$less = include.$eq$less$less;
  var Infix_$great$eq$great = include.$great$eq$great;
  var Infix_$less$eq$less = include.$less$eq$less;
  var Infix_$less$less$eq = include$1.$less$less$eq;
  var Infix_$eq$great$great = include$1.$eq$great$great;
  var Infix = {
    $less$$great: Infix_$less$$great,
    $less$at$great: Infix_$less$at$great,
    $less$star$great: Infix_$less$star$great,
    $great$great$eq: Infix_$great$great$eq,
    $eq$less$less: Infix_$eq$less$less,
    $great$eq$great: Infix_$great$eq$great,
    $less$eq$less: Infix_$less$eq$less,
    $less$less$eq: Infix_$less$less$eq,
    $eq$great$great: Infix_$eq$great$great
  };
  return {
          zip_with: zip_with,
          zip: zip,
          Functor: Functor,
          Alt: Alt,
          Apply: Apply,
          Applicative: Applicative,
          Monad: Monad,
          Foldable: Foldable,
          Unfoldable: Unfoldable,
          Traversable: Traversable,
          Eq: Eq,
          Ord: Ord,
          Show: Show,
          Invariant: Invariant,
          Extend: Extend,
          Infix: Infix
        };
}

exports.Make = Make;
/* Bastet__String Not a pure module */
