// Generated by Melange
'use strict';

var Caml = require("melange.runtime/caml.js");
var Stdlib = require("melange/./stdlib.js");
var Caml_obj = require("melange.runtime/caml_obj.js");
var Caml_int32 = require("melange.runtime/caml_int32.js");
var Bastet__Infix = require("./Infix.js");
var Bastet__Interface = require("./Interface.js");

function append(prim0, prim1) {
  return prim0 + prim1 | 0;
}

var Magma = {
  append: append
};

var Semigroup = {
  append: append
};

var Monoid = {
  append: append,
  empty: 0
};

var Quasigroup = {
  append: append
};

var Medial_Quasigroup = {
  append: append
};

var Loop = {
  append: append,
  empty: 0
};

function inverse(param) {
  return Math.imul(-1, param);
}

var Group = {
  append: append,
  empty: 0,
  inverse: inverse
};

var Abelian_Group = {
  append: append,
  empty: 0,
  inverse: inverse
};

var Additive = {
  Magma: Magma,
  Medial_Magma: Magma,
  Semigroup: Semigroup,
  Monoid: Monoid,
  Quasigroup: Quasigroup,
  Medial_Quasigroup: Medial_Quasigroup,
  Loop: Loop,
  Group: Group,
  Abelian_Group: Abelian_Group
};

function append$1(prim0, prim1) {
  return Math.imul(prim0, prim1);
}

var Magma$1 = {
  append: append$1
};

var Semigroup$1 = {
  append: append$1
};

var Monoid$1 = {
  append: append$1,
  empty: 1
};

var Quasigroup$1 = {
  append: append$1
};

var Loop$1 = {
  append: append$1,
  empty: 1
};

var Multiplicative = {
  Magma: Magma$1,
  Medial_Magma: Magma$1,
  Semigroup: Semigroup$1,
  Monoid: Monoid$1,
  Quasigroup: Quasigroup$1,
  Loop: Loop$1
};

function append$2(prim0, prim1) {
  return prim0 - prim1 | 0;
}

var Magma$2 = {
  append: append$2
};

var Quasigroup$2 = {
  append: append$2
};

var Subtractive = {
  Magma: Magma$2,
  Medial_Magma: Magma$2,
  Quasigroup: Quasigroup$2
};

var append$3 = Caml_int32.div;

var Magma$3 = {
  append: append$3
};

var Divisive = {
  Magma: Magma$3
};

var eq = Caml_obj.caml_equal;

var Eq = {
  eq: eq
};

var Ord = {
  eq: eq,
  compare: Bastet__Interface.unsafe_compare
};

var Bounded = {
  eq: eq,
  compare: Bastet__Interface.unsafe_compare,
  top: Stdlib.max_int,
  bottom: Stdlib.min_int
};

function show(prim) {
  return String(prim);
}

var Show = {
  show: show
};

function add(prim0, prim1) {
  return prim0 + prim1 | 0;
}

function multiply(prim0, prim1) {
  return Math.imul(prim0, prim1);
}

var Semiring = {
  add: add,
  zero: 0,
  multiply: multiply,
  one: 1
};

function subtract(prim0, prim1) {
  return prim0 - prim1 | 0;
}

var Ring = {
  add: add,
  zero: 0,
  multiply: multiply,
  one: 1,
  subtract: subtract
};

var Commutative_Ring = {
  add: add,
  zero: 0,
  multiply: multiply,
  one: 1,
  subtract: subtract
};

function degree(a) {
  return Caml.caml_int_min(Stdlib.abs(a), Stdlib.max_int);
}

var divide = Caml_int32.div;

var modulo = Caml_int32.mod_;

var Euclidean_Ring = {
  add: add,
  zero: 0,
  multiply: multiply,
  one: 1,
  subtract: subtract,
  degree: degree,
  divide: divide,
  modulo: modulo
};

var include = Bastet__Infix.Magma(Magma);

var Additive$1 = include;

var include$1 = Bastet__Infix.Magma(Magma$1);

var Multiplicative$1 = include$1;

var include$2 = Bastet__Infix.Eq(Eq);

var include$3 = Bastet__Infix.Ord(Ord);

var include$4 = Bastet__Infix.Euclidean_Ring(Euclidean_Ring);

var Infix_$eq$pipe$eq = include$2.$eq$pipe$eq;

var Infix_$less$pipe$pipe = include$3.$less$pipe$pipe;

var Infix_$pipe$pipe$great = include$3.$pipe$pipe$great;

var Infix_$less$pipe$eq = include$3.$less$pipe$eq;

var Infix_$great$pipe$eq = include$3.$great$pipe$eq;

var Infix_$pipe$plus$pipe = include$4.$pipe$plus$pipe;

var Infix_$pipe$star$pipe = include$4.$pipe$star$pipe;

var Infix_$pipe$$pipe = include$4.$pipe$neg$pipe;

var Infix_$pipe$slash$pipe = include$4.$pipe$slash$pipe;

var Infix_$pipe$percent$pipe = include$4.$pipe$percent$pipe;

var Infix = {
  Additive: Additive$1,
  Multiplicative: Multiplicative$1,
  $eq$pipe$eq: Infix_$eq$pipe$eq,
  $less$pipe$pipe: Infix_$less$pipe$pipe,
  $pipe$pipe$great: Infix_$pipe$pipe$great,
  $less$pipe$eq: Infix_$less$pipe$eq,
  $great$pipe$eq: Infix_$great$pipe$eq,
  $pipe$plus$pipe: Infix_$pipe$plus$pipe,
  $pipe$star$pipe: Infix_$pipe$star$pipe,
  $pipe$neg$pipe: Infix_$pipe$$pipe,
  $pipe$slash$pipe: Infix_$pipe$slash$pipe,
  $pipe$percent$pipe: Infix_$pipe$percent$pipe
};

exports.Additive = Additive;
exports.Multiplicative = Multiplicative;
exports.Subtractive = Subtractive;
exports.Divisive = Divisive;
exports.Eq = Eq;
exports.Ord = Ord;
exports.Bounded = Bounded;
exports.Show = Show;
exports.Semiring = Semiring;
exports.Ring = Ring;
exports.Commutative_Ring = Commutative_Ring;
exports.Euclidean_Ring = Euclidean_Ring;
exports.Infix = Infix;
/* include Not a pure module */
