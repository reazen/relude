// Generated by Melange
'use strict';

var Curry = require("melange.runtime/curry.js");
var Bastet__Infix = require("./Infix.js");

function first(param) {
  return param[0];
}

function second(param) {
  return param[1];
}

function swap(a, b) {
  return [
          b,
          a
        ];
}

function curry(f, a, b) {
  return Curry._1(f, [
              a,
              b
            ]);
}

function uncurry(f, param) {
  return Curry._2(f, param[0], param[1]);
}

function Magma(First, Second) {
  var append = function (param, param$1) {
    return [
            Curry._2(First.append, param[0], param$1[0]),
            Curry._2(Second.append, param[1], param$1[1])
          ];
  };
  return {
          append: append
        };
}

function Semigroup(First, Second) {
  var append = function (param, param$1) {
    return [
            Curry._2(First.append, param[0], param$1[0]),
            Curry._2(Second.append, param[1], param$1[1])
          ];
  };
  return {
          append: append
        };
}

function Monoid(First, Second) {
  var append = function (param, param$1) {
    return [
            Curry._2(First.append, param[0], param$1[0]),
            Curry._2(Second.append, param[1], param$1[1])
          ];
  };
  var empty_0 = First.empty;
  var empty_1 = Second.empty;
  var empty = [
    empty_0,
    empty_1
  ];
  return {
          append: append,
          empty: empty
        };
}

function Functor(T) {
  var map = function (f, param) {
    return [
            param[0],
            Curry._1(f, param[1])
          ];
  };
  return {
          map: map
        };
}

function Apply(S) {
  var map = function (f, param) {
    return [
            param[0],
            Curry._1(f, param[1])
          ];
  };
  var apply = function (param, param$1) {
    return [
            Curry._2(S.append, param[0], param$1[0]),
            Curry._1(param[1], param$1[1])
          ];
  };
  return {
          map: map,
          apply: apply
        };
}

function Applicative(M) {
  var map = function (f, param) {
    return [
            param[0],
            Curry._1(f, param[1])
          ];
  };
  var apply = function (param, param$1) {
    return [
            Curry._2(M.append, param[0], param$1[0]),
            Curry._1(param[1], param$1[1])
          ];
  };
  var pure = function (a) {
    return [
            M.empty,
            a
          ];
  };
  return {
          map: map,
          apply: apply,
          pure: pure
        };
}

function Monad(M) {
  var map = function (f, param) {
    return [
            param[0],
            Curry._1(f, param[1])
          ];
  };
  var apply = function (param, param$1) {
    return [
            Curry._2(M.append, param[0], param$1[0]),
            Curry._1(param[1], param$1[1])
          ];
  };
  var pure = function (a) {
    return [
            M.empty,
            a
          ];
  };
  var flat_map = function (param, f) {
    var match = Curry._1(f, param[1]);
    return [
            Curry._2(M.append, param[0], match[0]),
            match[1]
          ];
  };
  return {
          map: map,
          apply: apply,
          pure: pure,
          flat_map: flat_map
        };
}

function Foldable(T) {
  var fold_left = function (f, init, param) {
    return Curry._2(f, init, param[1]);
  };
  var fold_right = function (f, init, param) {
    return Curry._2(f, param[1], init);
  };
  var fold_map = function (f, param) {
    return Curry._1(f, param[1]);
  };
  var Fold_Map = function (M) {
    return {
            fold_map: fold_map
          };
  };
  var Fold_Map_Plus = function (P) {
    return {
            fold_map: fold_map
          };
  };
  var Fold_Map_Any = function (M) {
    return {
            fold_map: fold_map
          };
  };
  return {
          fold_left: fold_left,
          fold_right: fold_right,
          Fold_Map: Fold_Map,
          Fold_Map_Any: Fold_Map_Any,
          Fold_Map_Plus: Fold_Map_Plus
        };
}

function Traversable(T, A) {
  var map = function (f, param) {
    return [
            param[0],
            Curry._1(f, param[1])
          ];
  };
  var fold_left = function (f, init, param) {
    return Curry._2(f, init, param[1]);
  };
  var fold_right = function (f, init, param) {
    return Curry._2(f, param[1], init);
  };
  var fold_map = function (f, param) {
    return Curry._1(f, param[1]);
  };
  var Fold_Map = function (M) {
    return {
            fold_map: fold_map
          };
  };
  var Fold_Map_Plus = function (P) {
    return {
            fold_map: fold_map
          };
  };
  var Fold_Map_Any = function (M) {
    return {
            fold_map: fold_map
          };
  };
  var traverse = function (f, param) {
    var x = param[0];
    return Curry._2(A.map, (function (z) {
                  return [
                          x,
                          z
                        ];
                }), Curry._1(f, param[1]));
  };
  var sequence = function (param) {
    var x = param[0];
    return Curry._2(A.map, (function (z) {
                  return [
                          x,
                          z
                        ];
                }), param[1]);
  };
  return {
          map: map,
          fold_left: fold_left,
          fold_right: fold_right,
          Fold_Map: Fold_Map,
          Fold_Map_Any: Fold_Map_Any,
          Fold_Map_Plus: Fold_Map_Plus,
          traverse: traverse,
          sequence: sequence
        };
}

function Eq(First, Second) {
  var eq = function (param, param$1) {
    if (Curry._2(First.eq, param[0], param$1[0])) {
      return Curry._2(Second.eq, param[1], param$1[1]);
    } else {
      return false;
    }
  };
  return {
          eq: eq
        };
}

function compose(param, param$1) {
  return [
          param$1[0],
          param[1]
        ];
}

var Semigroupoid = {
  compose: compose
};

function Show(First, Second) {
  var show = function (param) {
    return "(" + (Curry._1(First.show, param[0]) + (", " + (Curry._1(Second.show, param[1]) + ")")));
  };
  return {
          show: show
        };
}

function bimap(f, g, param) {
  return [
          Curry._1(f, param[0]),
          Curry._1(g, param[1])
        ];
}

var Bifunctor = {
  bimap: bimap
};

function biapply(param, param$1) {
  return [
          Curry._1(param[0], param$1[0]),
          Curry._1(param[1], param$1[1])
        ];
}

var Biapply = {
  bimap: bimap,
  biapply: biapply
};

function bipure(a, b) {
  return [
          a,
          b
        ];
}

var Biapplicative = {
  bimap: bimap,
  biapply: biapply,
  bipure: bipure
};

function bifold_left(f, g, init, param) {
  return Curry._2(g, Curry._2(f, init, param[0]), param[1]);
}

function bifold_right(f, g, init, param) {
  return Curry._2(f, param[0], Curry._2(g, param[1], init));
}

function Fold_Map(M) {
  var fold_map = function (f, g, param) {
    return Curry._2(M.append, Curry._1(f, param[0]), Curry._1(g, param[1]));
  };
  return {
          fold_map: fold_map
        };
}

function Fold_Map_Any(M) {
  var fold_map = function (f, g, param) {
    return Curry._2(M.append, Curry._1(f, param[0]), Curry._1(g, param[1]));
  };
  return {
          fold_map: fold_map
        };
}

function Fold_Map_Plus(P) {
  var fold_map = function (f, g, param) {
    return Curry._2(P.alt, Curry._1(f, param[0]), Curry._1(g, param[1]));
  };
  return {
          fold_map: fold_map
        };
}

var Bifoldable = {
  bifold_left: bifold_left,
  bifold_right: bifold_right,
  Fold_Map: Fold_Map,
  Fold_Map_Any: Fold_Map_Any,
  Fold_Map_Plus: Fold_Map_Plus
};

function Bitraversable(A) {
  var I = Bastet__Infix.Apply(A);
  var bitraverse = function (f, g, param) {
    return Curry._2(I.$less$star$great, Curry._2(A.map, (function (a, b) {
                      return [
                              a,
                              b
                            ];
                    }), Curry._1(f, param[0])), Curry._1(g, param[1]));
  };
  var bisequence = function (param) {
    return Curry._2(I.$less$star$great, Curry._2(A.map, (function (a, b) {
                      return [
                              a,
                              b
                            ];
                    }), param[0]), param[1]);
  };
  return {
          bimap: bimap,
          bifold_left: bifold_left,
          bifold_right: bifold_right,
          Fold_Map: Fold_Map,
          Fold_Map_Any: Fold_Map_Any,
          Fold_Map_Plus: Fold_Map_Plus,
          bitraverse: bitraverse,
          bisequence: bisequence
        };
}

var include = Bastet__Infix.Biapply(Biapply);

var Infix = include;

exports.first = first;
exports.second = second;
exports.swap = swap;
exports.curry = curry;
exports.uncurry = uncurry;
exports.Magma = Magma;
exports.Semigroup = Semigroup;
exports.Monoid = Monoid;
exports.Functor = Functor;
exports.Apply = Apply;
exports.Applicative = Applicative;
exports.Monad = Monad;
exports.Foldable = Foldable;
exports.Traversable = Traversable;
exports.Eq = Eq;
exports.Semigroupoid = Semigroupoid;
exports.Show = Show;
exports.Bifunctor = Bifunctor;
exports.Biapply = Biapply;
exports.Biapplicative = Biapplicative;
exports.Bifoldable = Bifoldable;
exports.Bitraversable = Bitraversable;
exports.Infix = Infix;
/* include Not a pure module */
