// Generated by Melange
'use strict';

var Curry = require("melange.runtime/curry.js");
var Bastet__Infix = require("./Infix.js");

function Magma(M) {
  var append = function (a, b) {
    return /* Dual */{
            _0: Curry._2(M.append, b._0, a._0)
          };
  };
  return {
          append: append
        };
}

function Semigroup(S) {
  var append = function (a, b) {
    return /* Dual */{
            _0: Curry._2(S.append, b._0, a._0)
          };
  };
  return {
          append: append
        };
}

function Monoid(M) {
  var append = function (a, b) {
    return /* Dual */{
            _0: Curry._2(M.append, b._0, a._0)
          };
  };
  var empty = /* Dual */{
    _0: M.empty
  };
  return {
          append: append,
          empty: empty
        };
}

function map(f, a) {
  return /* Dual */{
          _0: Curry._1(f, a._0)
        };
}

var Functor = {
  map: map
};

function apply(f, a) {
  return /* Dual */{
          _0: Curry._1(f._0, a._0)
        };
}

function pure(a) {
  return /* Dual */{
          _0: a
        };
}

var Applicative = {
  map: map,
  apply: apply,
  pure: pure
};

function flat_map(a, f) {
  return Curry._1(f, a._0);
}

var Monad = {
  map: map,
  apply: apply,
  pure: pure,
  flat_map: flat_map
};

function Magma_Any(M) {
  var append = function (a, b) {
    return /* Dual */{
            _0: Curry._2(M.append, b._0, a._0)
          };
  };
  return {
          append: append
        };
}

function Semigroup_Any(S) {
  var append = function (a, b) {
    return /* Dual */{
            _0: Curry._2(S.append, b._0, a._0)
          };
  };
  return {
          append: append
        };
}

function Monoid_Any(M) {
  var append = function (a, b) {
    return /* Dual */{
            _0: Curry._2(M.append, b._0, a._0)
          };
  };
  var empty = /* Dual */{
    _0: M.empty
  };
  return {
          append: append,
          empty: empty
        };
}

function fold_left(f, init, x) {
  return Curry._2(f, init, x._0);
}

function fold_right(f, init, x) {
  return Curry._2(f, x._0, init);
}

function fold_map(f, x) {
  return Curry._1(f, x._0);
}

function Fold_Map(M) {
  return {
          fold_map: fold_map
        };
}

function Fold_Map_Any(M) {
  return {
          fold_map: fold_map
        };
}

function Fold_Map_Plus(P) {
  return {
          fold_map: fold_map
        };
}

var Foldable = {
  fold_left: fold_left,
  fold_right: fold_right,
  Fold_Map: Fold_Map,
  Fold_Map_Any: Fold_Map_Any,
  Fold_Map_Plus: Fold_Map_Plus
};

function Traversable(A) {
  var I = Bastet__Infix.Functor(A);
  var traverse = function (f, x) {
    return Curry._2(I.$less$$great, (function (x) {
                  return /* Dual */{
                          _0: x
                        };
                }), Curry._1(f, x._0));
  };
  var sequence = function (x) {
    return Curry._2(I.$less$$great, (function (x) {
                  return /* Dual */{
                          _0: x
                        };
                }), x._0);
  };
  return {
          map: map,
          fold_left: fold_left,
          fold_right: fold_right,
          Fold_Map: Fold_Map,
          Fold_Map_Any: Fold_Map_Any,
          Fold_Map_Plus: Fold_Map_Plus,
          traverse: traverse,
          sequence: sequence
        };
}

var include = Bastet__Infix.Monad(Monad);

var Infix = include;

exports.Magma = Magma;
exports.Semigroup = Semigroup;
exports.Monoid = Monoid;
exports.Functor = Functor;
exports.Applicative = Applicative;
exports.Monad = Monad;
exports.Magma_Any = Magma_Any;
exports.Semigroup_Any = Semigroup_Any;
exports.Monoid_Any = Monoid_Any;
exports.Foldable = Foldable;
exports.Traversable = Traversable;
exports.Infix = Infix;
/* include Not a pure module */
