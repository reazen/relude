// Generated by Melange
'use strict';

var Stdlib = require("melange/./stdlib.js");
var Caml_obj = require("melange.runtime/caml_obj.js");
var Bastet__Infix = require("./Infix.js");
var Bastet__Interface = require("./Interface.js");

function approximately_equal(tolerance, a, b) {
  return Math.abs(a - b) <= tolerance;
}

function append(prim0, prim1) {
  return prim0 + prim1;
}

var Magma = {
  append: append
};

var Semigroup = {
  append: append
};

var Monoid = {
  append: append,
  empty: 0.0
};

var Quasigroup = {
  append: append
};

var Medial_Quasigroup = {
  append: append
};

var Loop = {
  append: append,
  empty: 0.0
};

function inverse(param) {
  return -1.0 * param;
}

var Group = {
  append: append,
  empty: 0.0,
  inverse: inverse
};

var Abelian_Group = {
  append: append,
  empty: 0.0,
  inverse: inverse
};

var Additive = {
  Magma: Magma,
  Medial_Magma: Magma,
  Semigroup: Semigroup,
  Monoid: Monoid,
  Quasigroup: Quasigroup,
  Medial_Quasigroup: Medial_Quasigroup,
  Loop: Loop,
  Group: Group,
  Abelian_Group: Abelian_Group
};

function append$1(prim0, prim1) {
  return prim0 * prim1;
}

var Magma$1 = {
  append: append$1
};

var Semigroup$1 = {
  append: append$1
};

var Monoid$1 = {
  append: append$1,
  empty: 1.0
};

var Quasigroup$1 = {
  append: append$1
};

var Medial_Quasigroup$1 = {
  append: append$1
};

var Loop$1 = {
  append: append$1,
  empty: 1.0
};

var Multiplicative = {
  Magma: Magma$1,
  Medial_Magma: Magma$1,
  Semigroup: Semigroup$1,
  Monoid: Monoid$1,
  Quasigroup: Quasigroup$1,
  Medial_Quasigroup: Medial_Quasigroup$1,
  Loop: Loop$1
};

function append$2(prim0, prim1) {
  return prim0 - prim1;
}

var Magma$2 = {
  append: append$2
};

var Quasigroup$2 = {
  append: append$2
};

var Medial_Quasigroup$2 = {
  append: append$2
};

var Subtractive = {
  Magma: Magma$2,
  Medial_Magma: Magma$2,
  Quasigroup: Quasigroup$2,
  Medial_Quasigroup: Medial_Quasigroup$2
};

function append$3(prim0, prim1) {
  return prim0 / prim1;
}

var Magma$3 = {
  append: append$3
};

var Quasigroup$3 = {
  append: append$3
};

var Medial_Quasigroup$3 = {
  append: append$3
};

var Divisive = {
  Magma: Magma$3,
  Medial_Magma: Magma$3,
  Quasigroup: Quasigroup$3,
  Medial_Quasigroup: Medial_Quasigroup$3
};

var eq = Caml_obj.caml_equal;

var Eq = {
  eq: eq
};

var Ord = {
  eq: eq,
  compare: Bastet__Interface.unsafe_compare
};

var Bounded = {
  eq: eq,
  compare: Bastet__Interface.unsafe_compare,
  top: Stdlib.max_float,
  bottom: Stdlib.min_float
};

var Show = {
  show: Stdlib.string_of_float
};

function add(prim0, prim1) {
  return prim0 + prim1;
}

function multiply(prim0, prim1) {
  return prim0 * prim1;
}

var Semiring = {
  add: add,
  zero: 0.0,
  multiply: multiply,
  one: 1.0
};

function subtract(prim0, prim1) {
  return prim0 - prim1;
}

var Ring = {
  add: add,
  zero: 0.0,
  multiply: multiply,
  one: 1.0,
  subtract: subtract
};

var Commutative_Ring = {
  add: add,
  zero: 0.0,
  multiply: multiply,
  one: 1.0,
  subtract: subtract
};

function reciprocal(a) {
  return 1.0 / a;
}

var Division_Ring = {
  add: add,
  zero: 0.0,
  multiply: multiply,
  one: 1.0,
  subtract: subtract,
  reciprocal: reciprocal
};

function degree(param) {
  return 1;
}

function divide(prim0, prim1) {
  return prim0 / prim1;
}

function modulo(param, param$1) {
  return 0.0;
}

var Euclidean_Ring = {
  add: add,
  zero: 0.0,
  multiply: multiply,
  one: 1.0,
  subtract: subtract,
  degree: degree,
  divide: divide,
  modulo: modulo
};

var Field = {
  degree: degree,
  divide: divide,
  modulo: modulo,
  add: add,
  zero: 0.0,
  multiply: multiply,
  one: 1.0,
  subtract: subtract,
  reciprocal: reciprocal
};

var include = Bastet__Infix.Magma(Magma);

var Additive$1 = include;

var include$1 = Bastet__Infix.Magma(Magma$1);

var Multiplicative$1 = include$1;

var include$2 = Bastet__Infix.Eq(Eq);

var include$3 = Bastet__Infix.Ord(Ord);

var include$4 = Bastet__Infix.Euclidean_Ring(Euclidean_Ring);

var Infix_$eq$pipe$eq = include$2.$eq$pipe$eq;

var Infix_$less$pipe$pipe = include$3.$less$pipe$pipe;

var Infix_$pipe$pipe$great = include$3.$pipe$pipe$great;

var Infix_$less$pipe$eq = include$3.$less$pipe$eq;

var Infix_$great$pipe$eq = include$3.$great$pipe$eq;

var Infix_$pipe$plus$pipe = include$4.$pipe$plus$pipe;

var Infix_$pipe$star$pipe = include$4.$pipe$star$pipe;

var Infix_$pipe$$pipe = include$4.$pipe$neg$pipe;

var Infix_$pipe$slash$pipe = include$4.$pipe$slash$pipe;

var Infix_$pipe$percent$pipe = include$4.$pipe$percent$pipe;

var Infix = {
  Additive: Additive$1,
  Multiplicative: Multiplicative$1,
  $eq$pipe$eq: Infix_$eq$pipe$eq,
  $less$pipe$pipe: Infix_$less$pipe$pipe,
  $pipe$pipe$great: Infix_$pipe$pipe$great,
  $less$pipe$eq: Infix_$less$pipe$eq,
  $great$pipe$eq: Infix_$great$pipe$eq,
  $pipe$plus$pipe: Infix_$pipe$plus$pipe,
  $pipe$star$pipe: Infix_$pipe$star$pipe,
  $pipe$neg$pipe: Infix_$pipe$$pipe,
  $pipe$slash$pipe: Infix_$pipe$slash$pipe,
  $pipe$percent$pipe: Infix_$pipe$percent$pipe
};

exports.approximately_equal = approximately_equal;
exports.Additive = Additive;
exports.Multiplicative = Multiplicative;
exports.Subtractive = Subtractive;
exports.Divisive = Divisive;
exports.Eq = Eq;
exports.Ord = Ord;
exports.Bounded = Bounded;
exports.Show = Show;
exports.Semiring = Semiring;
exports.Ring = Ring;
exports.Commutative_Ring = Commutative_Ring;
exports.Division_Ring = Division_Ring;
exports.Euclidean_Ring = Euclidean_Ring;
exports.Field = Field;
exports.Infix = Infix;
/* include Not a pure module */
