// Generated by Melange
'use strict';

var Jest = require("../node_modules/@glennsl/bs-jest/src/jest.js");
var Curry = require("melange.runtime/curry.js");
var Belt_MapString = require("melange.belt/./belt_MapString.js");
var Relude__Relude_StateT = require("relude/./Relude_StateT.js");
var Relude__Relude_Globals = require("relude/./Relude_Globals.js");
var Relude__Relude_Free_Monad = require("relude/./Relude_Free_Monad.js");

function map(aToB, fa) {
  switch (fa.TAG | 0) {
    case /* Get */0 :
        var getNext = fa._1;
        return {
                TAG: /* Get */0,
                _0: fa._0,
                _1: (function (param) {
                    return Relude__Relude_Globals.$great$great(getNext, aToB, param);
                  })
              };
    case /* Put */1 :
        return {
                TAG: /* Put */1,
                _0: fa._0,
                _1: fa._1,
                _2: Curry._1(aToB, fa._2)
              };
    case /* Delete */2 :
        return {
                TAG: /* Delete */2,
                _0: fa._0,
                _1: Curry._1(aToB, fa._1)
              };
    
  }
}

function WithKeyAndValue(K, V) {
  var Functor = {
    map: map
  };
  var FreeMonad = Relude__Relude_Free_Monad.WithFunctor(Functor);
  var get = function (key) {
    return Curry._1(FreeMonad.liftF, {
                TAG: /* Get */0,
                _0: key,
                _1: (function (a) {
                    return a;
                  })
              });
  };
  var put = function (key, value) {
    return Curry._1(FreeMonad.liftF, {
                TAG: /* Put */1,
                _0: key,
                _1: value,
                _2: undefined
              });
  };
  var $$delete = function (key) {
    return Curry._1(FreeMonad.liftF, {
                TAG: /* Delete */2,
                _0: key,
                _1: undefined
              });
  };
  var include = FreeMonad.Infix;
  return {
          Functor: Functor,
          FreeMonad: FreeMonad,
          get: get,
          put: put,
          $$delete: $$delete,
          FunctorExtensions: include.FunctorExtensions,
          $less$$great: include.$less$$great,
          $less$$$great: include.$less$$$great,
          $less$: include.$less$,
          $$great: include.$$great,
          $less$at$great: include.$less$at$great,
          ApplyExtensions: include.ApplyExtensions,
          $less$star$great: include.$less$star$great,
          $less$star: include.$less$star,
          $star$great: include.$star$great,
          MonadExtensions: include.MonadExtensions,
          $great$great$eq: include.$great$great$eq,
          $eq$less$less: include.$eq$less$less,
          $great$eq$great: include.$great$eq$great,
          $less$eq$less: include.$less$eq$less
        };
}

var StorageF = {
  map: map,
  WithKeyAndValue: WithKeyAndValue
};

var State = Relude__Relude_StateT.State.WithState({});

function getState(key) {
  return /* StateT */{
          _0: (function (s) {
              return [
                      Belt_MapString.get(s, key),
                      s
                    ];
            })
        };
}

function putState(key, value) {
  return /* StateT */{
          _0: (function (s) {
              return [
                      undefined,
                      Belt_MapString.set(s, key, value)
                    ];
            })
        };
}

function deleteState(key) {
  return /* StateT */{
          _0: (function (s) {
              return [
                      undefined,
                      Belt_MapString.remove(s, key)
                    ];
            })
        };
}

var Functor = {
  map: map
};

var FreeMonad = Relude__Relude_Free_Monad.WithFunctor(Functor);

function get(key) {
  return Curry._1(FreeMonad.liftF, {
              TAG: /* Get */0,
              _0: key,
              _1: (function (a) {
                  return a;
                })
            });
}

function put(key, value) {
  return Curry._1(FreeMonad.liftF, {
              TAG: /* Put */1,
              _0: key,
              _1: value,
              _2: undefined
            });
}

function $$delete(key) {
  return Curry._1(FreeMonad.liftF, {
              TAG: /* Delete */2,
              _0: key,
              _1: undefined
            });
}

var include = FreeMonad.Infix;

var FunctorExtensions = include.FunctorExtensions;

var $less$$great = include.$less$$great;

var $less$$$great = include.$less$$$great;

var $less$ = include.$less$;

var $$great = include.$$great;

var $less$at$great = include.$less$at$great;

var ApplyExtensions = include.ApplyExtensions;

var $less$star$great = include.$less$star$great;

var $less$star = include.$less$star;

var $star$great = include.$star$great;

var MonadExtensions = include.MonadExtensions;

var $great$great$eq = include.$great$great$eq;

var $eq$less$less = include.$eq$less$less;

var $great$eq$great = include.$great$eq$great;

var $less$eq$less = include.$less$eq$less;

var StorageFWithKeyAndValue = {
  Functor: Functor,
  FreeMonad: FreeMonad,
  get: get,
  put: put,
  $$delete: $$delete,
  FunctorExtensions: FunctorExtensions,
  $less$$great: $less$$great,
  $less$$$great: $less$$$great,
  $less$: $less$,
  $$great: $$great,
  $less$at$great: $less$at$great,
  ApplyExtensions: ApplyExtensions,
  $less$star$great: $less$star$great,
  $less$star: $less$star,
  $star$great: $star$great,
  MonadExtensions: MonadExtensions,
  $great$great$eq: $great$great$eq,
  $eq$less$less: $eq$less$less,
  $great$eq$great: $great$eq$great,
  $less$eq$less: $less$eq$less
};

function interpreter(storage) {
  switch (storage.TAG | 0) {
    case /* Get */0 :
        var next = storage._1;
        return Curry._2(State.Infix.$less$$$great, getState(storage._0), Curry.__1(next));
    case /* Put */1 :
        var next$1 = storage._2;
        return Curry._2(State.Infix.$less$$$great, putState(storage._0, storage._1), (function (param) {
                      return next$1;
                    }));
    case /* Delete */2 :
        var next$2 = storage._1;
        return Curry._2(State.Infix.$less$$$great, deleteState(storage._0), (function (param) {
                      return next$2;
                    }));
    
  }
}

var include$1 = Curry._1(FreeMonad.WithMonad, State.Monad);

var foldFree = include$1.foldFree;

var StorageAPI = {
  State: State,
  getState: getState,
  putState: putState,
  deleteState: deleteState,
  StorageFWithKeyAndValue: StorageFWithKeyAndValue,
  interpreter: interpreter,
  Functor: Functor,
  FreeMonad: FreeMonad,
  get: get,
  put: put,
  $$delete: $$delete,
  FunctorExtensions: FunctorExtensions,
  $less$$great: $less$$great,
  $less$$$great: $less$$$great,
  $less$: $less$,
  $$great: $$great,
  $less$at$great: $less$at$great,
  ApplyExtensions: ApplyExtensions,
  $less$star$great: $less$star$great,
  $less$star: $less$star,
  $star$great: $star$great,
  MonadExtensions: MonadExtensions,
  $great$great$eq: $great$great$eq,
  $eq$less$less: $eq$less$less,
  $great$eq$great: $great$eq$great,
  $less$eq$less: $less$eq$less,
  foldFree: foldFree
};

Jest.describe("Relude.Free_Monad", (function (param) {
        Jest.describe("StorageAPI", (function (param) {
                Jest.test("StorageState interpreter", (function (param) {
                        var program = Curry._2($great$great$eq, Curry._2($great$great$eq, Curry._2(put, "key1", 42), (function (param) {
                                    return Curry._1(get, "key1");
                                  })), (function (value1) {
                                return Curry._2($great$great$eq, Curry._2($great$great$eq, Curry._2($great$great$eq, Curry._2($great$great$eq, Curry._1($$delete, "key1"), (function (param) {
                                                          return Curry._2(put, "key2", 99);
                                                        })), (function (param) {
                                                      return Curry._2(put, "key1", 5);
                                                    })), (function (param) {
                                                  return Curry._1(get, "key1");
                                                })), (function (value2) {
                                              return Curry._2($less$$$great, Curry._1(get, "key2"), (function (value3) {
                                                            return [
                                                                    value1,
                                                                    value2,
                                                                    value3
                                                                  ];
                                                          }));
                                            }));
                              }));
                        var match = Curry._2(State.runStateT, undefined, Curry._2(foldFree, interpreter, program));
                        return Jest.Expect.toEqual([
                                    42,
                                    5,
                                    99
                                  ], Jest.Expect.expect(match[0]));
                      }));
              }));
      }));

exports.StorageF = StorageF;
exports.StorageAPI = StorageAPI;
/* State Not a pure module */
