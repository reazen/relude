<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>WithSequence (api.Relude_SequenceZipper.WithSequence)</title><link rel="stylesheet" href="../../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../">Up</a> â€“ <a href="../../">api</a> &#x00BB; <a href="../">Relude_SequenceZipper</a> &#x00BB; WithSequence</nav><h1>Module <code>Relude_SequenceZipper.WithSequence</code></h1><p>* Creates a Zipper using the given SEQUENCE as the backing implementation * * Heavily inspired by Queensland Function Programming Lab Haskell implementation, * although without many of the advanced capabilities, like the ListZipperOp stuff. * https://github.com/qfpl/list-zipper/blob/master/src/Data/ListZipper.hs * * See also this very enlightening presentation about zippers for more background: * http://data.tmorris.net/talks/zippers/0a1062fd0526d7ac1f41ade1e4db1465d311b4fd/zippers.pdf</p></header><h3 class="heading">Parameters</h3><ul><li><code>S: Relude_Interface.SEQUENCE</code></li></ul><h3 class="heading">Signature</h3><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t('a)</code><code> = </code><table class="variant"><tr id="type-t.Zipper" class="anchored"><td class="def constructor"><a href="#type-t.Zipper" class="anchor"></a><code>| </code><code><span class="constructor">Zipper</span>(<a href="#argument-1-S">S</a>.t(<span class="type-var">'a</span>), <span class="type-var">'a</span>, <a href="#argument-1-S">S</a>.t(<span class="type-var">'a</span>))</code></td></tr></table>;</dt><dd><p>* A Zipper type contains a sequence on the left (in reverse order, so that the head * of the left sequence is treated as if it's the item immediately to the left of the focus), * a focused item, and a sequence on the right. * * The left sequence is reversed so that moving the focus one item to the left is an O(1) operation * for list-based implementations. Prepending to an array-based implementation might not be O(1), * but list is probably the more common use-case for a zipper since it has ideal performance for moving * the focus to the left or right. The array-backed implementation has the left reversed too, for API consistency.</p></dd></dl><dl><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">let</span> make: a. <a href="#argument-1-S">S</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <a href="#argument-1-S">S</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>);</code></dt><dd><p>* Constructs a Zipper from a left sequence, a focus, and a right sequence. * * NB: the left sequence should be given in reverse - the head of the left sequence * is treated as the item immediately to the left of the focus. The right sequence * is in &quot;natural&quot; order where the head of the right sequence is treated as the item * immediately to the right of the focus.</p></dd></dl><dl><dt class="spec value" id="val-makeWithLeft"><a href="#val-makeWithLeft" class="anchor"></a><code><span class="keyword">let</span> makeWithLeft: a. <a href="#argument-1-S">S</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>);</code></dt><dd><p>* Constructs a Zipper from a left sequence and a focus. * * NB: the left sequence should be given in reverse - the head of the left sequence * is treated as the item immediately to the left of the focus.</p></dd></dl><dl><dt class="spec value" id="val-makeWithRight"><a href="#val-makeWithRight" class="anchor"></a><code><span class="keyword">let</span> makeWithRight: a. <span class="type-var">'a</span> <span>=&gt;</span> <a href="#argument-1-S">S</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>);</code></dt><dd><p>* Constructs a Zipper from a focus and a right sequence. * * NB: * The right sequence is in &quot;natural&quot; order where the head of the right sequence is treated as the item * immediately to the right of the focus.</p></dd></dl><dl><dt class="spec value" id="val-makeWithRightArray"><a href="#val-makeWithRightArray" class="anchor"></a><code><span class="keyword">let</span> makeWithRightArray: a. <span class="type-var">'a</span> <span>=&gt;</span> array(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>);</code></dt><dd><p>* Makes a zipper with a focus at the start and with an array at the tail end</p></dd></dl><dl><dt class="spec value" id="val-makeWithRightList"><a href="#val-makeWithRightList" class="anchor"></a><code><span class="keyword">let</span> makeWithRightList: a. <span class="type-var">'a</span> <span>=&gt;</span> list(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>);</code></dt><dd><p>* Makes a zipper with a focus at the start and with a list at the tail end</p></dd></dl><dl><dt class="spec value" id="val-makeWithFocus"><a href="#val-makeWithFocus" class="anchor"></a><code><span class="keyword">let</span> makeWithFocus: a. <span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>);</code></dt><dd><p>* Constructs a zipper with empty left and right sequence, and a single focus.</p></dd></dl><dl><dt class="spec value" id="val-fromSequence"><a href="#val-fromSequence" class="anchor"></a><code><span class="keyword">let</span> fromSequence: a. <a href="#argument-1-S">S</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> option(<a href="#type-t">t</a>(<span class="type-var">'a</span>));</code></dt><dd><p>* Creates a Zipper from a sequence putting the focus on the first item. If the sequence is empty, * None is returned.</p></dd></dl><dl><dt class="spec value" id="val-fromArray"><a href="#val-fromArray" class="anchor"></a><code><span class="keyword">let</span> fromArray: a. array(<span class="type-var">'a</span>) <span>=&gt;</span> option(<a href="#type-t">t</a>(<span class="type-var">'a</span>));</code></dt><dd><p>* Makes a zipper from a non-empty list. Returns None if empty.</p></dd></dl><dl><dt class="spec value" id="val-fromList"><a href="#val-fromList" class="anchor"></a><code><span class="keyword">let</span> fromList: a. list(<span class="type-var">'a</span>) <span>=&gt;</span> option(<a href="#type-t">t</a>(<span class="type-var">'a</span>));</code></dt><dd><p>* Makes a zipper from a non-empty list. Returns None if empty.</p></dd></dl><dl><dt class="spec value" id="val-fromNonEmptyArray"><a href="#val-fromNonEmptyArray" class="anchor"></a><code><span class="keyword">let</span> fromNonEmptyArray: a. Relude_NonEmpty.Array.t(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>);</code></dt><dd><p>* Makes a zipper from a NonEmptyArray, with the focus on the first item</p></dd></dl><dl><dt class="spec value" id="val-fromNea"><a href="#val-fromNea" class="anchor"></a><code><span class="keyword">let</span> fromNea: Relude_NonEmpty.Array.t(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>);</code></dt><dd><p>* Makes a zipper from a NonEmptyArray, with the focus on the first item * * Alias for fromNonEmptyArray</p></dd></dl><dl><dt class="spec value" id="val-fromNonEmptyList"><a href="#val-fromNonEmptyList" class="anchor"></a><code><span class="keyword">let</span> fromNonEmptyList: a. Relude_NonEmpty.List.t(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>);</code></dt><dd><p>* Makes a zipper from a NonEmptyList, with the focus on the first item</p></dd></dl><dl><dt class="spec value" id="val-fromNel"><a href="#val-fromNel" class="anchor"></a><code><span class="keyword">let</span> fromNel: Relude_NonEmpty.List.t(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>);</code></dt><dd><p>* Makes a zipper from a NonEmptyList, with the focus on the first item * * Alias for fromNonEmptyList</p></dd></dl><dl><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">let</span> map: a b. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'b</span>);</code></dt><dd><p>* Maps a pure function over the values of a Zipper</p></dd></dl><div class="spec module" id="module-Functor"><a href="#module-Functor" class="anchor"></a><code><span class="keyword">module</span> Functor: BsBastet.Interface.FUNCTOR <span class="keyword">with</span> <span class="keyword">type</span> <a href="#module-Functor">Functor</a>.t('a) = <a href="#type-t">t</a>(<span class="type-var">'a</span>);</code></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> { ... }<span class="keyword">;</span></code></span></summary><div class="spec module" id="module-BsFunctorExtensions"><a href="#module-BsFunctorExtensions" class="anchor"></a><code><span class="keyword">module</span> <a href="BsFunctorExtensions">BsFunctorExtensions</a>: { ... };</code></div><dl><dt class="spec value" id="val-flipMap"><a href="#val-flipMap" class="anchor"></a><code><span class="keyword">let</span> flipMap: <a href="#module-Functor">Functor</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#module-Functor">Functor</a>.t(<span class="type-var">'b</span>);</code></dt><dt class="spec value" id="val-void"><a href="#val-void" class="anchor"></a><code><span class="keyword">let</span> void: <a href="#module-Functor">Functor</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#module-Functor">Functor</a>.t(unit);</code></dt><dt class="spec value" id="val-voidRight"><a href="#val-voidRight" class="anchor"></a><code><span class="keyword">let</span> voidRight: <span class="type-var">'a</span> <span>=&gt;</span> <a href="#module-Functor">Functor</a>.t(<span class="type-var">'b</span>) <span>=&gt;</span> <a href="#module-Functor">Functor</a>.t(<span class="type-var">'a</span>);</code></dt><dt class="spec value" id="val-voidLeft"><a href="#val-voidLeft" class="anchor"></a><code><span class="keyword">let</span> voidLeft: <a href="#module-Functor">Functor</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <a href="#module-Functor">Functor</a>.t(<span class="type-var">'b</span>);</code></dt><dt class="spec value" id="val-flap"><a href="#val-flap" class="anchor"></a><code><span class="keyword">let</span> flap: <a href="#module-Functor">Functor</a>.t(<span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span>) <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <a href="#module-Functor">Functor</a>.t(<span class="type-var">'b</span>);</code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-apply"><a href="#val-apply" class="anchor"></a><code><span class="keyword">let</span> apply: a b. <a href="#type-t">t</a>(<span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'b</span>);</code></dt><dd><p>* Maps a Zipper of functions over a Zipper * * Implementation taken from: https://github.com/qfpl/list-zipper/blob/master/src/Data/ListZipper.hs#L151 * At the time of this writing, I don't personally understand why it's implemented this way.</p></dd></dl><div class="spec module" id="module-Apply"><a href="#module-Apply" class="anchor"></a><code><span class="keyword">module</span> Apply: BsBastet.Interface.APPLY <span class="keyword">with</span> <span class="keyword">type</span> <a href="#module-Apply">Apply</a>.t('a) = <a href="#type-t">t</a>(<span class="type-var">'a</span>);</code></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> { ... }<span class="keyword">;</span></code></span></summary><div class="spec module" id="module-BsApplyExtensions"><a href="#module-BsApplyExtensions" class="anchor"></a><code><span class="keyword">module</span> <a href="BsApplyExtensions">BsApplyExtensions</a>: { ... };</code></div><dl><dt class="spec value" id="val-applyFirst"><a href="#val-applyFirst" class="anchor"></a><code><span class="keyword">let</span> applyFirst: <a href="#module-Apply">Apply</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#module-Apply">Apply</a>.t(<span class="type-var">'b</span>) <span>=&gt;</span> <a href="#module-Apply">Apply</a>.t(<span class="type-var">'a</span>);</code></dt><dt class="spec value" id="val-applySecond"><a href="#val-applySecond" class="anchor"></a><code><span class="keyword">let</span> applySecond: <a href="#module-Apply">Apply</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#module-Apply">Apply</a>.t(<span class="type-var">'b</span>) <span>=&gt;</span> <a href="#module-Apply">Apply</a>.t(<span class="type-var">'b</span>);</code></dt><dt class="spec value" id="val-map2"><a href="#val-map2" class="anchor"></a><code><span class="keyword">let</span> map2: <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#module-Apply">Apply</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#module-Apply">Apply</a>.t(<span class="type-var">'b</span>) <span>=&gt;</span> <a href="#module-Apply">Apply</a>.t(<span class="type-var">'c</span>);</code></dt><dt class="spec value" id="val-map3"><a href="#val-map3" class="anchor"></a><code><span class="keyword">let</span> map3: <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span> <span>=&gt;</span> <span class="type-var">'d</span>)</span> <span>=&gt;</span> <a href="#module-Apply">Apply</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#module-Apply">Apply</a>.t(<span class="type-var">'b</span>) <span>=&gt;</span> <a href="#module-Apply">Apply</a>.t(<span class="type-var">'c</span>) <span>=&gt;</span> <a href="#module-Apply">Apply</a>.t(<span class="type-var">'d</span>);</code></dt><dt class="spec value" id="val-map4"><a href="#val-map4" class="anchor"></a><code><span class="keyword">let</span> map4: <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span> <span>=&gt;</span> <span class="type-var">'d</span> <span>=&gt;</span> <span class="type-var">'e</span>)</span> <span>=&gt;</span> <a href="#module-Apply">Apply</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#module-Apply">Apply</a>.t(<span class="type-var">'b</span>) <span>=&gt;</span> <a href="#module-Apply">Apply</a>.t(<span class="type-var">'c</span>) <span>=&gt;</span> <a href="#module-Apply">Apply</a>.t(<span class="type-var">'d</span>) <span>=&gt;</span> <a href="#module-Apply">Apply</a>.t(<span class="type-var">'e</span>);</code></dt><dt class="spec value" id="val-map5"><a href="#val-map5" class="anchor"></a><code><span class="keyword">let</span> map5: <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span> <span>=&gt;</span> <span class="type-var">'d</span> <span>=&gt;</span> <span class="type-var">'e</span> <span>=&gt;</span> <span class="type-var">'f</span>)</span> <span>=&gt;</span> <a href="#module-Apply">Apply</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#module-Apply">Apply</a>.t(<span class="type-var">'b</span>) <span>=&gt;</span> <a href="#module-Apply">Apply</a>.t(<span class="type-var">'c</span>) <span>=&gt;</span> <a href="#module-Apply">Apply</a>.t(<span class="type-var">'d</span>) <span>=&gt;</span> <a href="#module-Apply">Apply</a>.t(<span class="type-var">'e</span>) <span>=&gt;</span> <a href="#module-Apply">Apply</a>.t(<span class="type-var">'f</span>);</code></dt><dt class="spec value" id="val-tuple2"><a href="#val-tuple2" class="anchor"></a><code><span class="keyword">let</span> tuple2: <a href="#module-Apply">Apply</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#module-Apply">Apply</a>.t(<span class="type-var">'b</span>) <span>=&gt;</span> <a href="#module-Apply">Apply</a>.t(<span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span>);</code></dt><dt class="spec value" id="val-tuple3"><a href="#val-tuple3" class="anchor"></a><code><span class="keyword">let</span> tuple3: <a href="#module-Apply">Apply</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#module-Apply">Apply</a>.t(<span class="type-var">'b</span>) <span>=&gt;</span> <a href="#module-Apply">Apply</a>.t(<span class="type-var">'c</span>) <span>=&gt;</span> <a href="#module-Apply">Apply</a>.t(<span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>)</span>);</code></dt><dt class="spec value" id="val-tuple4"><a href="#val-tuple4" class="anchor"></a><code><span class="keyword">let</span> tuple4: <a href="#module-Apply">Apply</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#module-Apply">Apply</a>.t(<span class="type-var">'b</span>) <span>=&gt;</span> <a href="#module-Apply">Apply</a>.t(<span class="type-var">'c</span>) <span>=&gt;</span> <a href="#module-Apply">Apply</a>.t(<span class="type-var">'d</span>) <span>=&gt;</span> <a href="#module-Apply">Apply</a>.t(<span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>)</span>);</code></dt><dt class="spec value" id="val-tuple5"><a href="#val-tuple5" class="anchor"></a><code><span class="keyword">let</span> tuple5: <a href="#module-Apply">Apply</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#module-Apply">Apply</a>.t(<span class="type-var">'b</span>) <span>=&gt;</span> <a href="#module-Apply">Apply</a>.t(<span class="type-var">'c</span>) <span>=&gt;</span> <a href="#module-Apply">Apply</a>.t(<span class="type-var">'d</span>) <span>=&gt;</span> <a href="#module-Apply">Apply</a>.t(<span class="type-var">'e</span>) <span>=&gt;</span> <a href="#module-Apply">Apply</a>.t(<span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>, <span class="type-var">'c</span>, <span class="type-var">'d</span>, <span class="type-var">'e</span>)</span>);</code></dt><dt class="spec value" id="val-mapTuple2"><a href="#val-mapTuple2" class="anchor"></a><code><span class="keyword">let</span> mapTuple2: <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>)</span> <span>=&gt;</span> <span>(<a href="#module-Apply">Apply</a>.t(<span class="type-var">'a</span>), <a href="#module-Apply">Apply</a>.t(<span class="type-var">'b</span>))</span> <span>=&gt;</span> <a href="#module-Apply">Apply</a>.t(<span class="type-var">'c</span>);</code></dt><dt class="spec value" id="val-mapTuple3"><a href="#val-mapTuple3" class="anchor"></a><code><span class="keyword">let</span> mapTuple3: <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span> <span>=&gt;</span> <span class="type-var">'d</span>)</span> <span>=&gt;</span> <span>(<a href="#module-Apply">Apply</a>.t(<span class="type-var">'a</span>), <a href="#module-Apply">Apply</a>.t(<span class="type-var">'b</span>), <a href="#module-Apply">Apply</a>.t(<span class="type-var">'c</span>))</span> <span>=&gt;</span> <a href="#module-Apply">Apply</a>.t(<span class="type-var">'d</span>);</code></dt><dt class="spec value" id="val-mapTuple4"><a href="#val-mapTuple4" class="anchor"></a><code><span class="keyword">let</span> mapTuple4: <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span> <span>=&gt;</span> <span class="type-var">'d</span> <span>=&gt;</span> <span class="type-var">'e</span>)</span> <span>=&gt;</span> <span>(<a href="#module-Apply">Apply</a>.t(<span class="type-var">'a</span>), <a href="#module-Apply">Apply</a>.t(<span class="type-var">'b</span>), <a href="#module-Apply">Apply</a>.t(<span class="type-var">'c</span>), <a href="#module-Apply">Apply</a>.t(<span class="type-var">'d</span>))</span> <span>=&gt;</span> <a href="#module-Apply">Apply</a>.t(<span class="type-var">'e</span>);</code></dt><dt class="spec value" id="val-mapTuple5"><a href="#val-mapTuple5" class="anchor"></a><code><span class="keyword">let</span> mapTuple5: <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span> <span>=&gt;</span> <span class="type-var">'d</span> <span>=&gt;</span> <span class="type-var">'e</span> <span>=&gt;</span> <span class="type-var">'f</span>)</span> <span>=&gt;</span> <span>(<a href="#module-Apply">Apply</a>.t(<span class="type-var">'a</span>), <a href="#module-Apply">Apply</a>.t(<span class="type-var">'b</span>), <a href="#module-Apply">Apply</a>.t(<span class="type-var">'c</span>), <a href="#module-Apply">Apply</a>.t(<span class="type-var">'d</span>), <a href="#module-Apply">Apply</a>.t(<span class="type-var">'e</span>))</span> <span>=&gt;</span> <a href="#module-Apply">Apply</a>.t(<span class="type-var">'f</span>);</code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-pure"><a href="#val-pure" class="anchor"></a><code><span class="keyword">let</span> pure: a. <span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>);</code></dt><dd><p>* Lifts a pure value into a Zipper, as the focused value. * * Alias for `makeWithFocus` * * Note: QFPL implementation has `repeat a` on the left and right sides. * At the time of this writing, I don't understand why it's implemented this way. * I'm not sure if we can implement it this way in a strict language.</p></dd></dl><div class="spec module" id="module-Applicative"><a href="#module-Applicative" class="anchor"></a><code><span class="keyword">module</span> Applicative: BsBastet.Interface.APPLICATIVE <span class="keyword">with</span> <span class="keyword">type</span> <a href="#module-Applicative">Applicative</a>.t('a) = <a href="#type-t">t</a>(<span class="type-var">'a</span>);</code></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> { ... }<span class="keyword">;</span></code></span></summary><div class="spec module" id="module-BsApplicativeExtensions"><a href="#module-BsApplicativeExtensions" class="anchor"></a><code><span class="keyword">module</span> <a href="BsApplicativeExtensions">BsApplicativeExtensions</a>: { ... };</code></div><dl><dt class="spec value" id="val-liftA1"><a href="#val-liftA1" class="anchor"></a><code><span class="keyword">let</span> liftA1: <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <a href="#module-Applicative">Applicative</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#module-Applicative">Applicative</a>.t(<span class="type-var">'b</span>);</code></dt><dt class="spec value" id="val-when_"><a href="#val-when_" class="anchor"></a><code><span class="keyword">let</span> when_: bool <span>=&gt;</span> <a href="#module-Applicative">Applicative</a>.t(unit) <span>=&gt;</span> <a href="#module-Applicative">Applicative</a>.t(unit);</code></dt><dt class="spec value" id="val-unless"><a href="#val-unless" class="anchor"></a><code><span class="keyword">let</span> unless: bool <span>=&gt;</span> <a href="#module-Applicative">Applicative</a>.t(unit) <span>=&gt;</span> <a href="#module-Applicative">Applicative</a>.t(unit);</code></dt><dt class="spec value" id="val-all"><a href="#val-all" class="anchor"></a><code><span class="keyword">let</span> all: list(<a href="#module-Applicative">Applicative</a>.t(<span class="type-var">'a</span>)) <span>=&gt;</span> <a href="#module-Applicative">Applicative</a>.t(list(<span class="type-var">'a</span>));</code></dt></dl></details></div></div></div><dl><dt class="spec value" id="val-foldLeft"><a href="#val-foldLeft" class="anchor"></a><code><span class="keyword">let</span> foldLeft: <span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <span class="type-var">'b</span>;</code></dt><dd><p>* Folds a zipper from left-to-right using an accumulator</p></dd></dl><dl><dt class="spec value" id="val-foldRight"><a href="#val-foldRight" class="anchor"></a><code><span class="keyword">let</span> foldRight: <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'b</span>)</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <span class="type-var">'b</span>;</code></dt><dd><p>* Folds a zipper from right-to-left using an accumulator</p></dd></dl><div class="spec module" id="module-Foldable"><a href="#module-Foldable" class="anchor"></a><code><span class="keyword">module</span> Foldable: BsBastet.Interface.FOLDABLE <span class="keyword">with</span> <span class="keyword">type</span> <a href="#module-Foldable">Foldable</a>.t('a) = <a href="#type-t">t</a>(<span class="type-var">'a</span>);</code></div><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> { ... }<span class="keyword">;</span></code></span></summary><div class="spec module" id="module-BsFoldableExtensions"><a href="#module-BsFoldableExtensions" class="anchor"></a><code><span class="keyword">module</span> <a href="BsFoldableExtensions">BsFoldableExtensions</a>: { ... };</code></div><dl><dt class="spec value" id="val-any"><a href="#val-any" class="anchor"></a><code><span class="keyword">let</span> any: <span>(<span class="type-var">'a</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#module-Foldable">Foldable</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> bool;</code></dt><dt class="spec value" id="val-all"><a href="#val-all" class="anchor"></a><code><span class="keyword">let</span> all: <span>(<span class="type-var">'a</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#module-Foldable">Foldable</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> bool;</code></dt><dt class="spec value" id="val-containsBy"><a href="#val-containsBy" class="anchor"></a><code><span class="keyword">let</span> containsBy: <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <a href="#module-Foldable">Foldable</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> bool;</code></dt><dt class="spec value" id="val-contains"><a href="#val-contains" class="anchor"></a><code><span class="keyword">let</span> contains: <span>(<span class="keyword">module</span> BsBastet.Interface.EQ <span class="keyword">with</span> <span class="keyword">type</span> t = <span class="type-var">'a</span>)</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <a href="#module-Foldable">Foldable</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> bool;</code></dt><dt class="spec value" id="val-indexOfBy"><a href="#val-indexOfBy" class="anchor"></a><code><span class="keyword">let</span> indexOfBy: <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <a href="#module-Foldable">Foldable</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> option(int);</code></dt><dt class="spec value" id="val-indexOf"><a href="#val-indexOf" class="anchor"></a><code><span class="keyword">let</span> indexOf: <span>(<span class="keyword">module</span> BsBastet.Interface.EQ <span class="keyword">with</span> <span class="keyword">type</span> t = <span class="type-var">'a</span>)</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <a href="#module-Foldable">Foldable</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> option(int);</code></dt><dt class="spec value" id="val-minBy"><a href="#val-minBy" class="anchor"></a><code><span class="keyword">let</span> minBy: <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> BsBastet.Interface.ordering)</span> <span>=&gt;</span> <a href="#module-Foldable">Foldable</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> option(<span class="type-var">'a</span>);</code></dt><dt class="spec value" id="val-min"><a href="#val-min" class="anchor"></a><code><span class="keyword">let</span> min: <span>(<span class="keyword">module</span> BsBastet.Interface.ORD <span class="keyword">with</span> <span class="keyword">type</span> t = <span class="type-var">'a</span>)</span> <span>=&gt;</span> <a href="#module-Foldable">Foldable</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> option(<span class="type-var">'a</span>);</code></dt><dt class="spec value" id="val-maxBy"><a href="#val-maxBy" class="anchor"></a><code><span class="keyword">let</span> maxBy: <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> BsBastet.Interface.ordering)</span> <span>=&gt;</span> <a href="#module-Foldable">Foldable</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> option(<span class="type-var">'a</span>);</code></dt><dt class="spec value" id="val-max"><a href="#val-max" class="anchor"></a><code><span class="keyword">let</span> max: <span>(<span class="keyword">module</span> BsBastet.Interface.ORD <span class="keyword">with</span> <span class="keyword">type</span> t = <span class="type-var">'a</span>)</span> <span>=&gt;</span> <a href="#module-Foldable">Foldable</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> option(<span class="type-var">'a</span>);</code></dt><dt class="spec value" id="val-countBy"><a href="#val-countBy" class="anchor"></a><code><span class="keyword">let</span> countBy: <span>(<span class="type-var">'a</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#module-Foldable">Foldable</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> int;</code></dt><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">let</span> length: <a href="#module-Foldable">Foldable</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> int;</code></dt><dt class="spec value" id="val-size"><a href="#val-size" class="anchor"></a><code><span class="keyword">let</span> size: <a href="#module-Foldable">Foldable</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> int;</code></dt><dt class="spec value" id="val-count"><a href="#val-count" class="anchor"></a><code><span class="keyword">let</span> count: <a href="#module-Foldable">Foldable</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> int;</code></dt><dt class="spec value" id="val-forEach"><a href="#val-forEach" class="anchor"></a><code><span class="keyword">let</span> forEach: <span>(<span class="type-var">'a</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> <a href="#module-Foldable">Foldable</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> unit;</code></dt><dt class="spec value" id="val-forEachWithIndex"><a href="#val-forEachWithIndex" class="anchor"></a><code><span class="keyword">let</span> forEachWithIndex: <span>(<span class="type-var">'a</span> <span>=&gt;</span> int <span>=&gt;</span> unit)</span> <span>=&gt;</span> <a href="#module-Foldable">Foldable</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> unit;</code></dt><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">let</span> find: <span>(<span class="type-var">'a</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#module-Foldable">Foldable</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> option(<span class="type-var">'a</span>);</code></dt><dt class="spec value" id="val-findWithIndex"><a href="#val-findWithIndex" class="anchor"></a><code><span class="keyword">let</span> findWithIndex: <span>(<span class="type-var">'a</span> <span>=&gt;</span> int <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#module-Foldable">Foldable</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> option(<span class="type-var">'a</span>);</code></dt><dt class="spec value" id="val-toList"><a href="#val-toList" class="anchor"></a><code><span class="keyword">let</span> toList: <a href="#module-Foldable">Foldable</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> list(<span class="type-var">'a</span>);</code></dt><dt class="spec value" id="val-toArray"><a href="#val-toArray" class="anchor"></a><code><span class="keyword">let</span> toArray: <a href="#module-Foldable">Foldable</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> array(<span class="type-var">'a</span>);</code></dt></dl><div class="spec module" id="module-FoldableSemigroupExtensions"><a href="#module-FoldableSemigroupExtensions" class="anchor"></a><code><span class="keyword">module</span> <a href="FoldableSemigroupExtensions">FoldableSemigroupExtensions</a>:  (<a href="FoldableSemigroupExtensions#argument-1-S">S</a>: BsBastet.Interface.SEMIGROUP) <span>=&gt;</span> { ... };</code></div><div class="spec module" id="module-FoldableMonoidExtensions"><a href="#module-FoldableMonoidExtensions" class="anchor"></a><code><span class="keyword">module</span> <a href="FoldableMonoidExtensions">FoldableMonoidExtensions</a>:  (<a href="FoldableMonoidExtensions#argument-1-M">M</a>: BsBastet.Interface.MONOID) <span>=&gt;</span> { ... };</code></div><dl><dt class="spec value" id="val-foldMap"><a href="#val-foldMap" class="anchor"></a><code><span class="keyword">let</span> foldMap: <span>(<span class="keyword">module</span> BsBastet.Interface.MONOID <span class="keyword">with</span> <span class="keyword">type</span> t = <span class="type-var">'a</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <a href="#module-Foldable">Foldable</a>.t(<span class="type-var">'b</span>) <span>=&gt;</span> <span class="type-var">'a</span>;</code></dt><dt class="spec value" id="val-foldWithMonoid"><a href="#val-foldWithMonoid" class="anchor"></a><code><span class="keyword">let</span> foldWithMonoid: <span>(<span class="keyword">module</span> BsBastet.Interface.MONOID <span class="keyword">with</span> <span class="keyword">type</span> t = <span class="type-var">'a</span>)</span> <span>=&gt;</span> <a href="#module-Foldable">Foldable</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> <span class="type-var">'a</span>;</code></dt><dt class="spec value" id="val-intercalate"><a href="#val-intercalate" class="anchor"></a><code><span class="keyword">let</span> intercalate: <span>(<span class="keyword">module</span> BsBastet.Interface.MONOID <span class="keyword">with</span> <span class="keyword">type</span> t = <span class="type-var">'a</span>)</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <a href="#module-Foldable">Foldable</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> <span class="type-var">'a</span>;</code></dt></dl><div class="spec module" id="module-FoldableApplicativeExtensions"><a href="#module-FoldableApplicativeExtensions" class="anchor"></a><code><span class="keyword">module</span> <a href="FoldableApplicativeExtensions">FoldableApplicativeExtensions</a>:  (<a href="FoldableApplicativeExtensions#argument-1-A">A</a>: BsBastet.Interface.APPLICATIVE) <span>=&gt;</span> { ... };</code></div><div class="spec module" id="module-FoldableMonadExtensions"><a href="#module-FoldableMonadExtensions" class="anchor"></a><code><span class="keyword">module</span> <a href="FoldableMonadExtensions">FoldableMonadExtensions</a>:  (<a href="FoldableMonadExtensions#argument-1-M">M</a>: BsBastet.Interface.MONAD) <span>=&gt;</span> { ... };</code></div><div class="spec module" id="module-FoldableEqExtensions"><a href="#module-FoldableEqExtensions" class="anchor"></a><code><span class="keyword">module</span> <a href="FoldableEqExtensions">FoldableEqExtensions</a>:  (<a href="FoldableEqExtensions#argument-1-E">E</a>: BsBastet.Interface.EQ) <span>=&gt;</span> { ... };</code></div><div class="spec module" id="module-FoldableOrdExtensions"><a href="#module-FoldableOrdExtensions" class="anchor"></a><code><span class="keyword">module</span> <a href="FoldableOrdExtensions">FoldableOrdExtensions</a>:  (<a href="FoldableOrdExtensions#argument-1-O">O</a>: BsBastet.Interface.ORD) <span>=&gt;</span> { ... };</code></div></details></div></div></div><div class="spec module-type" id="module-type-TRAVERSABLE_F"><a href="#module-type-TRAVERSABLE_F" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> TRAVERSABLE_F =  (<a href="module-type-TRAVERSABLE_F#argument-1-A">A</a>: BsBastet.Interface.APPLICATIVE) <span>=&gt;</span> BsBastet.Interface.TRAVERSABLE <span class="keyword">with</span> <span class="keyword">type</span> <a href="#module-type-TRAVERSABLE_F">TRAVERSABLE_F</a>.t('a) = <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span class="keyword">and</span> <span class="keyword">type</span> <a href="#module-type-TRAVERSABLE_F">TRAVERSABLE_F</a>.applicative_t('a) = <a href="module-type-TRAVERSABLE_F#argument-1-A">A</a>.t(<span class="type-var">'a</span>);</code></div><div class="spec module" id="module-Traversable"><a href="#module-Traversable" class="anchor"></a><code><span class="keyword">module</span> Traversable: <a href="#module-type-TRAVERSABLE_F">TRAVERSABLE_F</a>;</code></div><dl><dt class="spec value" id="val-toSequence"><a href="#val-toSequence" class="anchor"></a><code><span class="keyword">let</span> toSequence: a. <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#argument-1-S">S</a>.t(<span class="type-var">'a</span>);</code></dt><dd><p>* Converts the Zipper into a Sequence</p></dd></dl><dl><dt class="spec value" id="val-toArray"><a href="#val-toArray" class="anchor"></a><code><span class="keyword">let</span> toArray: a. <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> array(<span class="type-var">'a</span>);</code></dt><dd><p>* Converts the Zipper into an array * * TODO: not needed with Foldable extensions</p></dd></dl><dl><dt class="spec value" id="val-toList"><a href="#val-toList" class="anchor"></a><code><span class="keyword">let</span> toList: a. <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> list(<span class="type-var">'a</span>);</code></dt><dd><p>* Converts the Zipper into a list * * TODO: not needed with Foldable extensions</p></dd></dl><dl><dt class="spec value" id="val-toNonEmptyArray"><a href="#val-toNonEmptyArray" class="anchor"></a><code><span class="keyword">let</span> toNonEmptyArray: a. <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> Relude_NonEmpty.Array.t(<span class="type-var">'a</span>);</code></dt><dd><p>* Converts the Zipper into a NonEmptyArray</p></dd></dl><dl><dt class="spec value" id="val-toNea"><a href="#val-toNea" class="anchor"></a><code><span class="keyword">let</span> toNea: a. <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> Relude_NonEmpty.Array.t(<span class="type-var">'a</span>);</code></dt><dd><p>* Converts the Zipper into a NonEmptyArray * * Alias for toNonEmptyArray</p></dd></dl><dl><dt class="spec value" id="val-toNonEmptyList"><a href="#val-toNonEmptyList" class="anchor"></a><code><span class="keyword">let</span> toNonEmptyList: a. <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> Relude_NonEmpty.List.t(<span class="type-var">'a</span>);</code></dt><dd><p>* Converts the Zipper into a NonEmptyList</p></dd></dl><dl><dt class="spec value" id="val-toNel"><a href="#val-toNel" class="anchor"></a><code><span class="keyword">let</span> toNel: a. <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> Relude_NonEmpty.List.t(<span class="type-var">'a</span>);</code></dt><dd><p>* Converts the Zipper into a NonEmptyList * * Alias for toNonEmptyList</p></dd></dl><dl><dt class="spec value" id="val-concatWithKeepLeftFocus"><a href="#val-concatWithKeepLeftFocus" class="anchor"></a><code><span class="keyword">let</span> concatWithKeepLeftFocus: <span>prefix:<a href="#type-t">t</a>(<span class="type-var">'a</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>);</code></dt><dd><p>* Concatenates two Zippers, keeping the focus from the left Zipper</p></dd></dl><dl><dt class="spec value" id="val-concat"><a href="#val-concat" class="anchor"></a><code><span class="keyword">let</span> concat: <span>prefix:<a href="#type-t">t</a>(<span class="type-var">'a</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>);</code></dt><dd><p>* Concatenates two Zippers, keeping the focus from the left Zipper * * Alias for `concatWithKeepLeftFocus`</p></dd></dl><dl><dt class="spec value" id="val-concatWithKeepRightFocus"><a href="#val-concatWithKeepRightFocus" class="anchor"></a><code><span class="keyword">let</span> concatWithKeepRightFocus: <span>prefix:<a href="#type-t">t</a>(<span class="type-var">'a</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>);</code></dt><dd><p>* Concatenates two Zippers, keeping the focus from the right Zipper</p></dd></dl><div class="spec module" id="module-Semigroup_Any"><a href="#module-Semigroup_Any" class="anchor"></a><code><span class="keyword">module</span> Semigroup_Any: BsBastet.Interface.SEMIGROUP_ANY <span class="keyword">with</span> <span class="keyword">type</span> <a href="#module-Semigroup_Any">Semigroup_Any</a>.t('a) = <a href="#type-t">t</a>(<span class="type-var">'a</span>);</code></div><dl><dt class="spec value" id="val-reverse"><a href="#val-reverse" class="anchor"></a><code><span class="keyword">let</span> reverse: a. <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>);</code></dt><dd><p>* Reverses the Zipper</p></dd></dl><dl><dt class="spec value" id="val-zipWith"><a href="#val-zipWith" class="anchor"></a><code><span class="keyword">let</span> zipWith: a b c. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'c</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'b</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'c</span>);</code></dt><dd><p>* Zips two zippers together pair-wise using the given function</p></dd></dl><dl><dt class="spec value" id="val-zip"><a href="#val-zip" class="anchor"></a><code><span class="keyword">let</span> zip: a b. <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'b</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span>(<span class="type-var">'a</span>, <span class="type-var">'b</span>)</span>);</code></dt><dd><p>* Zips two zippers together in pairs.</p></dd></dl><dl><dt class="spec value" id="val-zipWithIndex"><a href="#val-zipWithIndex" class="anchor"></a><code><span class="keyword">let</span> zipWithIndex: a. <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span>(<span class="type-var">'a</span>, int)</span>);</code></dt><dd><p>* Pairs each item in the zipper with it's index as if the zipper was converted to a list or array</p></dd></dl><dl><dt class="spec value" id="val-getFocus"><a href="#val-getFocus" class="anchor"></a><code><span class="keyword">let</span> getFocus: a. <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <span class="type-var">'a</span>;</code></dt><dd><p>* Gets the item at the focus</p></dd></dl><dl><dt class="spec value" id="val-setFocusBy"><a href="#val-setFocusBy" class="anchor"></a><code><span class="keyword">let</span> setFocusBy: a. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>);</code></dt><dd><p>* Modifies the focus value with the given function</p></dd></dl><dl><dt class="spec value" id="val-setFocus"><a href="#val-setFocus" class="anchor"></a><code><span class="keyword">let</span> setFocus: a. <span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>);</code></dt><dd><p>* Sets a new value at the focus</p></dd></dl><dl><dt class="spec value" id="val-getLeft"><a href="#val-getLeft" class="anchor"></a><code><span class="keyword">let</span> getLeft: a. <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#argument-1-S">S</a>.t(<span class="type-var">'a</span>);</code></dt><dd><p>* Gets the sequence to the left of the focus (in the unchanged reverse order in which its stored)</p></dd></dl><dl><dt class="spec value" id="val-setLeft"><a href="#val-setLeft" class="anchor"></a><code><span class="keyword">let</span> setLeft: a. <a href="#argument-1-S">S</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>);</code></dt><dd><p>* Sets the sequence to the left of the focus. Note: the given sequence should be in reverse so that the * head of the sequence is the item that should immediately to the left of the focus.</p></dd></dl><dl><dt class="spec value" id="val-getLeftInOrder"><a href="#val-getLeftInOrder" class="anchor"></a><code><span class="keyword">let</span> getLeftInOrder: a. <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#argument-1-S">S</a>.t(<span class="type-var">'a</span>);</code></dt><dd><p>* Gets the sequence to the left of the focus (in its sequential order, i.e. reversed from how its stored in the zipper)</p></dd></dl><dl><dt class="spec value" id="val-setLeftFromInOrder"><a href="#val-setLeftFromInOrder" class="anchor"></a><code><span class="keyword">let</span> setLeftFromInOrder: a. <a href="#argument-1-S">S</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>);</code></dt><dd><p>* Sets the sequence to the left of the focus from an in-order sequence. I.e. the given sequence will be reversed by this function when stored in the new zipper.</p></dd></dl><dl><dt class="spec value" id="val-getRight"><a href="#val-getRight" class="anchor"></a><code><span class="keyword">let</span> getRight: a. <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#argument-1-S">S</a>.t(<span class="type-var">'a</span>);</code></dt><dd><p>* Gets the sequence to the right of the focus (order is in order, i.e. not changed)</p></dd></dl><dl><dt class="spec value" id="val-setRight"><a href="#val-setRight" class="anchor"></a><code><span class="keyword">let</span> setRight: a. <a href="#argument-1-S">S</a>.t(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>);</code></dt><dd><p>* Sets the sequence to the right of the focus (order is not changed)</p></dd></dl><dl><dt class="spec value" id="val-peekLeft"><a href="#val-peekLeft" class="anchor"></a><code><span class="keyword">let</span> peekLeft: a. <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> option(<span class="type-var">'a</span>);</code></dt><dd><p>* Gets the item to the immediate left of the focus</p></dd></dl><dl><dt class="spec value" id="val-peekRight"><a href="#val-peekRight" class="anchor"></a><code><span class="keyword">let</span> peekRight: a. <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> option(<span class="type-var">'a</span>);</code></dt><dd><p>* Gets the item to the immediate right of the focus</p></dd></dl><dl><dt class="spec value" id="val-isAtStart"><a href="#val-isAtStart" class="anchor"></a><code><span class="keyword">let</span> isAtStart: a. <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> bool;</code></dt><dd><p>* Indicates if the focus is at the start of the zipper</p></dd></dl><dl><dt class="spec value" id="val-isAtEnd"><a href="#val-isAtEnd" class="anchor"></a><code><span class="keyword">let</span> isAtEnd: a. <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> bool;</code></dt><dd><p>* Indicates if the focus is at the end of the zipper</p></dd></dl><dl><dt class="spec value" id="val-isAtIndex"><a href="#val-isAtIndex" class="anchor"></a><code><span class="keyword">let</span> isAtIndex: a. int <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> bool;</code></dt><dd><p>* Indicates if the focus is at the given index of the zipper</p></dd></dl><dl><dt class="spec value" id="val-isAtItemBy"><a href="#val-isAtItemBy" class="anchor"></a><code><span class="keyword">let</span> isAtItemBy: a. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> bool;</code></dt><dd><p>* Indicates if the focus is at the item, based on the given equality function</p></dd></dl><dl><dt class="spec value" id="val-isAtItem"><a href="#val-isAtItem" class="anchor"></a><code><span class="keyword">let</span> isAtItem: <span>(<span class="keyword">module</span> BsBastet.Interface.EQ <span class="keyword">with</span> <span class="keyword">type</span> t = <span class="type-var">'a</span>)</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> bool;</code></dt><dd><p>* Indicates if the focus is at the item, based on the given EQ module</p></dd></dl><dl><dt class="spec value" id="val-moveLeft"><a href="#val-moveLeft" class="anchor"></a><code><span class="keyword">let</span> moveLeft: a. <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> option(<a href="#type-t">t</a>(<span class="type-var">'a</span>));</code></dt><dd><p>* Moves the focus one item to the left. If there are no items to the left, returns None.</p></dd></dl><dl><dt class="spec value" id="val-moveRight"><a href="#val-moveRight" class="anchor"></a><code><span class="keyword">let</span> moveRight: a. <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> option(<a href="#type-t">t</a>(<span class="type-var">'a</span>));</code></dt><dd><p>* Moves the focus one item to the right. If there are no items to the right, returns None.</p></dd></dl><dl><dt class="spec value" id="val-moveLeftWithClamp"><a href="#val-moveLeftWithClamp" class="anchor"></a><code><span class="keyword">let</span> moveLeftWithClamp: a. <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>);</code></dt><dd><p>* Moves the focus one item to the left, unless we are at the start.</p></dd></dl><dl><dt class="spec value" id="val-moveRightWithClamp"><a href="#val-moveRightWithClamp" class="anchor"></a><code><span class="keyword">let</span> moveRightWithClamp: a. <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>);</code></dt><dd><p>* Moves the focus one item to the right, unless we are at the end.</p></dd></dl><dl><dt class="spec value" id="val-moveStart"><a href="#val-moveStart" class="anchor"></a><code><span class="keyword">let</span> moveStart: a. <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>);</code></dt><dd><p>* Moves the focus to the start of the zipper</p></dd></dl><dl><dt class="spec value" id="val-moveEnd"><a href="#val-moveEnd" class="anchor"></a><code><span class="keyword">let</span> moveEnd: a. <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>);</code></dt><dd><p>* Moves the focus to the end of the zipper</p></dd></dl><dl><dt class="spec value" id="val-moveLeftWithWrap"><a href="#val-moveLeftWithWrap" class="anchor"></a><code><span class="keyword">let</span> moveLeftWithWrap: a. <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>);</code></dt><dd><p>* Moves the focus one item to the left, wrapping to the end if we are currently at the start.</p></dd></dl><dl><dt class="spec value" id="val-moveRightWithWrap"><a href="#val-moveRightWithWrap" class="anchor"></a><code><span class="keyword">let</span> moveRightWithWrap: a. <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>);</code></dt><dd><p>* Moves the focus one item to the right, wrapping to the start if we are currently at the end.</p></dd></dl><dl><dt class="spec value" id="val-moveLeftTimes"><a href="#val-moveLeftTimes" class="anchor"></a><code><span class="keyword">let</span> moveLeftTimes: a. int <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> option(<a href="#type-t">t</a>(<span class="type-var">'a</span>));</code></dt><dd><p>* Moves the focus a number of times to the left. If the count is out of range, None is returned</p></dd></dl><dl><dt class="spec value" id="val-moveRightTimes"><a href="#val-moveRightTimes" class="anchor"></a><code><span class="keyword">let</span> moveRightTimes: a. int <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> option(<a href="#type-t">t</a>(<span class="type-var">'a</span>));</code></dt><dd><p>* Moves the focus a number of times to the right. If the count is out of range, None is returned</p></dd></dl><dl><dt class="spec value" id="val-moveLeftTimesWithClamp"><a href="#val-moveLeftTimesWithClamp" class="anchor"></a><code><span class="keyword">let</span> moveLeftTimesWithClamp: a. int <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>);</code></dt><dd><p>* Moves the focus a number of times to the left. If the count is out of range, the focus is moved to the start.</p></dd></dl><dl><dt class="spec value" id="val-moveRightTimesWithClamp"><a href="#val-moveRightTimesWithClamp" class="anchor"></a><code><span class="keyword">let</span> moveRightTimesWithClamp: a. int <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>);</code></dt><dd><p>* Moves the focus a number of times to the right. If the count is out of range, the focus is moved to the start.</p></dd></dl><dl><dt class="spec value" id="val-moveToIndex"><a href="#val-moveToIndex" class="anchor"></a><code><span class="keyword">let</span> moveToIndex: a. int <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> option(<a href="#type-t">t</a>(<span class="type-var">'a</span>));</code></dt><dd><p>* Moves the focus to the given index. If the index is out of range, None is returned.</p></dd></dl><dl><dt class="spec value" id="val-moveToIndexWithMod"><a href="#val-moveToIndexWithMod" class="anchor"></a><code><span class="keyword">let</span> moveToIndexWithMod: a. int <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>);</code></dt><dd><p>* Moves the focus to the given index modulus the length of the zipper.</p></dd></dl><dl><dt class="spec value" id="val-moveToIndexWithClamp"><a href="#val-moveToIndexWithClamp" class="anchor"></a><code><span class="keyword">let</span> moveToIndexWithClamp: a. int <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>);</code></dt><dd><p>* Moves the focus to the given index, but no farther than the start or end if the index is out of range in either direction.</p></dd></dl><dl><dt class="spec value" id="val-findLeftBy"><a href="#val-findLeftBy" class="anchor"></a><code><span class="keyword">let</span> findLeftBy: <span>?&#8288;checkFocus:bool</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> Relude_Option.Monad.t(<a href="#type-t">t</a>(<span class="type-var">'a</span>));</code></dt><dd><p>* Finds the first item that satisfies the given predicate, and returns a zipper focused on that item. * Only searches the focus and the left side of the zipper.</p></dd></dl><dl><dt class="spec value" id="val-findRightBy"><a href="#val-findRightBy" class="anchor"></a><code><span class="keyword">let</span> findRightBy: <span>?&#8288;checkFocus:bool</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> Relude_Option.Monad.t(<a href="#type-t">t</a>(<span class="type-var">'a</span>));</code></dt><dd><p>* Finds the first item that satisfies the given predicate, and returns a zipper focused on that item. * Only searches the focus and the right side of the zipper.</p></dd></dl><dl><dt class="spec value" id="val-findBy"><a href="#val-findBy" class="anchor"></a><code><span class="keyword">let</span> findBy: <span>?&#8288;checkFocus:bool</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> option(<a href="#type-t">t</a>(<span class="type-var">'a</span>));</code></dt><dd><p>* Finds the first item that satisfies the given predicate, and returns a zipper focused on that itme. * The left side is searched first, then the right.</p></dd></dl><dl><dt class="spec value" id="val-findItemLeftBy"><a href="#val-findItemLeftBy" class="anchor"></a><code><span class="keyword">let</span> findItemLeftBy: <span>?&#8288;checkFocus:bool</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> option(<a href="#type-t">t</a>(<span class="type-var">'a</span>));</code></dt><dd><p>* Finds the given item at the focus or to the left, using the given eq function.</p></dd></dl><dl><dt class="spec value" id="val-findItemRightBy"><a href="#val-findItemRightBy" class="anchor"></a><code><span class="keyword">let</span> findItemRightBy: <span>?&#8288;checkFocus:bool</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> option(<a href="#type-t">t</a>(<span class="type-var">'a</span>));</code></dt><dd><p>* Finds the given item at the focus or to the right, using the given eq function.</p></dd></dl><dl><dt class="spec value" id="val-findItemBy"><a href="#val-findItemBy" class="anchor"></a><code><span class="keyword">let</span> findItemBy: <span>?&#8288;checkFocus:bool</span> <span>=&gt;</span> <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> option(<a href="#type-t">t</a>(<span class="type-var">'a</span>));</code></dt><dd><p>* Finds the given item using the given eq function. Searches the left side first, then the right.</p></dd></dl><dl><dt class="spec value" id="val-findItemLeft"><a href="#val-findItemLeft" class="anchor"></a><code><span class="keyword">let</span> findItemLeft: <span>(<span class="keyword">module</span> BsBastet.Interface.EQ <span class="keyword">with</span> <span class="keyword">type</span> t = <span class="type-var">'a</span>)</span> <span>=&gt;</span> <span>?&#8288;checkFocus:bool</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> option(<a href="#type-t">t</a>(<span class="type-var">'a</span>));</code></dt><dd><p>* Finds the given item in the left side, using the given EQ module.</p></dd></dl><dl><dt class="spec value" id="val-findItemRight"><a href="#val-findItemRight" class="anchor"></a><code><span class="keyword">let</span> findItemRight: <span>(<span class="keyword">module</span> BsBastet.Interface.EQ <span class="keyword">with</span> <span class="keyword">type</span> t = <span class="type-var">'a</span>)</span> <span>=&gt;</span> <span>?&#8288;checkFocus:bool</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> option(<a href="#type-t">t</a>(<span class="type-var">'a</span>));</code></dt><dd><p>* Finds the given item in the right side, using the given EQ module.</p></dd></dl><dl><dt class="spec value" id="val-findItem"><a href="#val-findItem" class="anchor"></a><code><span class="keyword">let</span> findItem: <span>(<span class="keyword">module</span> BsBastet.Interface.EQ <span class="keyword">with</span> <span class="keyword">type</span> t = <span class="type-var">'a</span>)</span> <span>=&gt;</span> <span>?&#8288;checkFocus:bool</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> option(<a href="#type-t">t</a>(<span class="type-var">'a</span>));</code></dt><dd><p>* Finds the given item using the given EQ module. * The left side is searched first, then the right.</p></dd></dl><dl><dt class="spec value" id="val-insertWithPushLeft"><a href="#val-insertWithPushLeft" class="anchor"></a><code><span class="keyword">let</span> insertWithPushLeft: a. <span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>);</code></dt><dd><p>* Inserts a new item at the focus, and pushes the previous focus to the left side</p></dd></dl><dl><dt class="spec value" id="val-insertWithPushRight"><a href="#val-insertWithPushRight" class="anchor"></a><code><span class="keyword">let</span> insertWithPushRight: a. <span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>);</code></dt><dd><p>* Inserts a new item at the focus, and pushes the previous focus to the right side</p></dd></dl><dl><dt class="spec value" id="val-deleteWithPullLeft"><a href="#val-deleteWithPullLeft" class="anchor"></a><code><span class="keyword">let</span> deleteWithPullLeft: a. <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> option(<a href="#type-t">t</a>(<span class="type-var">'a</span>));</code></dt><dd><p>* Deletes the item at the focus, and pulls a value from the left side into focus. * * If there is no value on the left, None is returned.</p></dd></dl><dl><dt class="spec value" id="val-deleteWithPullRight"><a href="#val-deleteWithPullRight" class="anchor"></a><code><span class="keyword">let</span> deleteWithPullRight: a. <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> option(<a href="#type-t">t</a>(<span class="type-var">'a</span>));</code></dt><dd><p>* Deletes the item at the focus, and pulls a value from the right side into focus. * * If there is no value on the right, None is returned.</p></dd></dl><dl><dt class="spec value" id="val-deleteWithPullLeftOrRight"><a href="#val-deleteWithPullLeftOrRight" class="anchor"></a><code><span class="keyword">let</span> deleteWithPullLeftOrRight: a. <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> option(<a href="#type-t">t</a>(<span class="type-var">'a</span>));</code></dt><dd><p>* Deletes the item at the focus, and tries to pull an item from the left into focus. If there is no * item on the left, it tries to pull an item from the right. If there is no item on the right, None is returned.</p></dd></dl><dl><dt class="spec value" id="val-showBy"><a href="#val-showBy" class="anchor"></a><code><span class="keyword">let</span> showBy: a. <span>(<span class="type-var">'a</span> <span>=&gt;</span> string)</span> <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> string;</code></dt><dd><p>* Converts a Zipper to a string using the given function</p></dd></dl><dl><dt class="spec value" id="val-show"><a href="#val-show" class="anchor"></a><code><span class="keyword">let</span> show: <span>(<span class="keyword">module</span> BsBastet.Interface.SHOW <span class="keyword">with</span> <span class="keyword">type</span> t = <span class="type-var">'a</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> string;</code></dt><dd><p>* Converts a Zipper to a string using the given SHOW module</p></dd></dl><div class="spec module" id="module-Show"><a href="#module-Show" class="anchor"></a><code><span class="keyword">module</span> <a href="Show">Show</a>:  (<a href="Show#argument-1-ShowA">ShowA</a>: BsBastet.Interface.SHOW) <span>=&gt;</span> { ... };</code></div><dl><dt class="spec value" id="val-eqBy"><a href="#val-eqBy" class="anchor"></a><code><span class="keyword">let</span> eqBy: a. <span>(<span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> bool;</code></dt><dd><p>* Compares two Zippers for length and pair-wise equality</p></dd></dl><dl><dt class="spec value" id="val-eq"><a href="#val-eq" class="anchor"></a><code><span class="keyword">let</span> eq: <span>(<span class="keyword">module</span> BsBastet.Interface.EQ <span class="keyword">with</span> <span class="keyword">type</span> t = <span class="type-var">'a</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a>(<span class="type-var">'a</span>) <span>=&gt;</span> bool;</code></dt><dd><p>* Compares two lists for length and pair-wise equality using the given EQ module</p></dd></dl><div class="spec module" id="module-Eq"><a href="#module-Eq" class="anchor"></a><code><span class="keyword">module</span> <a href="Eq">Eq</a>:  (<a href="Eq#argument-1-EqA">EqA</a>: BsBastet.Interface.EQ) <span>=&gt;</span> { ... };</code></div><div class="spec module" id="module-Infix"><a href="#module-Infix" class="anchor"></a><code><span class="keyword">module</span> <a href="Infix">Infix</a>: { ... };</code></div></div></body></html>