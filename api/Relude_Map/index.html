<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Relude_Map (api.Relude_Map)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../">Up</a> – <a href="../">api</a> &#x00BB; Relude_Map</nav><h1>Module <code>Relude_Map</code></h1></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t('key, 'value, 'id)</code><code> = Belt.Map.t<span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span></code>;</dt></dl><dl><dt class="spec value" id="val-make"><a href="#val-make" class="anchor"></a><code><span class="keyword">let</span> make: Belt.Id.comparable<span>(<span class="type-var">'key</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>* Construct a new, empty map.</p></dd></dl><dl><dt class="spec value" id="val-set"><a href="#val-set" class="anchor"></a><code><span class="keyword">let</span> set: <span class="type-var">'key</span> <span>=&gt;</span> <span class="type-var">'value</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>* Set the value to the provided value at the given key in the map. This will * add a new key if the map doesn't currently have the provided key, or it * will replace the value if the key exists. * * As with other operations that &quot;change&quot; a map, the original map is not * mutated; instead a new immutable copy is returned.</p></dd></dl><dl><dt class="spec value" id="val-singleton"><a href="#val-singleton" class="anchor"></a><code><span class="keyword">let</span> singleton: Belt.Id.comparable<span>(<span class="type-var">'key</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <span class="type-var">'key</span> <span>=&gt;</span> <span class="type-var">'value</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>* Contruct a new map from the provided key and value.</p></dd></dl><dl><dt class="spec value" id="val-isEmpty"><a href="#val-isEmpty" class="anchor"></a><code><span class="keyword">let</span> isEmpty: <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> bool;</code></dt><dd><p>* Determine whether a map is empty.</p></dd></dl><dl><dt class="spec value" id="val-contains"><a href="#val-contains" class="anchor"></a><code><span class="keyword">let</span> contains: <span class="type-var">'key</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> bool;</code></dt><dd><p>* Determine whether a map contains a given key.</p></dd></dl><dl><dt class="spec value" id="val-compareInt"><a href="#val-compareInt" class="anchor"></a><code><span class="keyword">let</span> compareInt: <span>(<span class="type-var">'value</span> <span>=&gt;</span> <span class="type-var">'value</span> <span>=&gt;</span> int)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> int;</code></dt><dd><p>* Compare the ordering of two maps, given a comparator function capable of * comparing each value in the map. `compareInt` expects the provided function * to return an int representing the comparison, and `compareInt` intself will * return an int.</p></dd></dl><dl><dt class="spec value" id="val-compareBy"><a href="#val-compareBy" class="anchor"></a><code><span class="keyword">let</span> compareBy: <span>(<span class="type-var">'value</span> <span>=&gt;</span> <span class="type-var">'value</span> <span>=&gt;</span> BsBastet.Interface.ordering)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> BsBastet.Interface.ordering;</code></dt><dd><p>* Compare the ordering of two maps, given a comparator function capable of * comparing each value in the map. `compare` expects the provided function to * return an `ordering` representing the comparison, and `compare` itself will * return an `ordering` value.</p></dd></dl><dl><dt class="spec value" id="val-eqBy"><a href="#val-eqBy" class="anchor"></a><code><span class="keyword">let</span> eqBy: <span>(<span class="type-var">'value</span> <span>=&gt;</span> <span class="type-var">'value</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> bool;</code></dt><dd><p>* Given an equality function capable of testing values for equality, * determine whether two maps are equal by checking whether they have equal * keys, and equal values at each key.</p></dd></dl><dl><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">let</span> find: <span>(<span class="type-var">'key</span> <span>=&gt;</span> <span class="type-var">'value</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> option(<span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>)</span>);</code></dt><dd><p>* Find (optionally) the first key/value pair in a map matching the provided * predicate function.</p></dd></dl><dl><dt class="spec value" id="val-forEach"><a href="#val-forEach" class="anchor"></a><code><span class="keyword">let</span> forEach: <span>(<span class="type-var">'key</span> <span>=&gt;</span> <span class="type-var">'value</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> unit;</code></dt><dd><p>* Iterate over each key/value pair in the map, calling the provided function * that probably performs some side effect and returns `unit`. Prefer `map` or * `foldLeft` in most cases.</p></dd></dl><dl><dt class="spec value" id="val-foldLeft"><a href="#val-foldLeft" class="anchor"></a><code><span class="keyword">let</span> foldLeft: <span>(<span class="type-var">'acc</span> <span>=&gt;</span> <span class="type-var">'key</span> <span>=&gt;</span> <span class="type-var">'value</span> <span>=&gt;</span> <span class="type-var">'acc</span>)</span> <span>=&gt;</span> <span class="type-var">'acc</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <span class="type-var">'acc</span>;</code></dt><dd><p>* Accumulate a map of key/value pairs into a single value.</p></dd></dl><dl><dt class="spec value" id="val-all"><a href="#val-all" class="anchor"></a><code><span class="keyword">let</span> all: <span>(<span class="type-var">'key</span> <span>=&gt;</span> <span class="type-var">'value</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> bool;</code></dt><dd><p>* Given a predicate function to be called with key/value pairs, determine * whether every pair in the map satisfies the predicate. This will always * return `true` for empty maps.</p></dd></dl><dl><dt class="spec value" id="val-any"><a href="#val-any" class="anchor"></a><code><span class="keyword">let</span> any: <span>(<span class="type-var">'key</span> <span>=&gt;</span> <span class="type-var">'value</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> bool;</code></dt><dd><p>* Given a predicate function to be called with key/value pairs, determine * whether at least one pair in the map satisfies the predicate. This will * always return `false` for empty maps.</p></dd></dl><dl><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">let</span> length: <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> int;</code></dt><dd><p>* The count of keys in the map.</p></dd></dl><dl><dt class="spec value" id="val-toArray"><a href="#val-toArray" class="anchor"></a><code><span class="keyword">let</span> toArray: <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> array(<span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>)</span>);</code></dt><dd><p>* Convert a map to an array of key/value pairs. Note that the resulting array * will be sorted by the ordering of the key type, not necessarily the order * in which values were added to the map.</p></dd></dl><dl><dt class="spec value" id="val-fromArray"><a href="#val-fromArray" class="anchor"></a><code><span class="keyword">let</span> fromArray: Belt.Id.comparable<span>(<span class="type-var">'key</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> array(<span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>)</span>) <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>* Convert an associated array (an array of (key, value) tuples) into a map.</p></dd></dl><dl><dt class="spec value" id="val-fromValueArray"><a href="#val-fromValueArray" class="anchor"></a><code><span class="keyword">let</span> fromValueArray: Belt.Id.comparable<span>(<span class="type-var">'key</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'value</span> <span>=&gt;</span> <span class="type-var">'key</span>)</span> <span>=&gt;</span> array(<span class="type-var">'value</span>) <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>* Convert an array of values into a map, using the provided function from * value to key. This is useful when your value type can already be uniquely * identified (and that identifier can be ordered).</p></dd></dl><dl><dt class="spec value" id="val-toList"><a href="#val-toList" class="anchor"></a><code><span class="keyword">let</span> toList: <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> list(<span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>)</span>);</code></dt><dd><p>* Convert a map to an associated list (a list of key/value tuples). Note that * the resulting list will be sorted according to the ordering of the key * type, not necessarily in the order in which values were added to the map.</p></dd></dl><dl><dt class="spec value" id="val-fromList"><a href="#val-fromList" class="anchor"></a><code><span class="keyword">let</span> fromList: Belt.Id.comparable<span>(<span class="type-var">'key</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> list(<span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>)</span>) <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>* Convert an associated list (a list of (key, value) tuples) into a map.</p></dd></dl><dl><dt class="spec value" id="val-fromValueList"><a href="#val-fromValueList" class="anchor"></a><code><span class="keyword">let</span> fromValueList: Belt.Id.comparable<span>(<span class="type-var">'key</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'value</span> <span>=&gt;</span> <span class="type-var">'key</span>)</span> <span>=&gt;</span> list(<span class="type-var">'value</span>) <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>* Convert a list of values into a map, using the provided function from * value to key. This is useful when your value type can already be uniquely * identified (and that identifier can be ordered).</p></dd></dl><dl><dt class="spec value" id="val-keyArray"><a href="#val-keyArray" class="anchor"></a><code><span class="keyword">let</span> keyArray: <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> array(<span class="type-var">'key</span>);</code></dt><dd><p>* Return a sorted array containing each key in the map.</p></dd></dl><dl><dt class="spec value" id="val-keys"><a href="#val-keys" class="anchor"></a><code><span class="keyword">let</span> keys: <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> list(<span class="type-var">'key</span>);</code></dt><dd><p>* Return a sorted list containing each key in the map</p></dd></dl><dl><dt class="spec value" id="val-valueArray"><a href="#val-valueArray" class="anchor"></a><code><span class="keyword">let</span> valueArray: <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> array(<span class="type-var">'value</span>);</code></dt><dd><p>* Return an array of each value (sorted by key) in the map.</p></dd></dl><dl><dt class="spec value" id="val-values"><a href="#val-values" class="anchor"></a><code><span class="keyword">let</span> values: <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> list(<span class="type-var">'value</span>);</code></dt><dd><p>* Return a list of each value (sorted by key) in the map.</p></dd></dl><dl><dt class="spec value" id="val-minKey"><a href="#val-minKey" class="anchor"></a><code><span class="keyword">let</span> minKey: <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> option(<span class="type-var">'key</span>);</code></dt><dd><p>* Optionally find the smallest key, using the key ordering.</p></dd></dl><dl><dt class="spec value" id="val-maxKey"><a href="#val-maxKey" class="anchor"></a><code><span class="keyword">let</span> maxKey: <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> option(<span class="type-var">'key</span>);</code></dt><dd><p>* Optionally find the largest key, using the key ordering.</p></dd></dl><dl><dt class="spec value" id="val-min"><a href="#val-min" class="anchor"></a><code><span class="keyword">let</span> min: <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> option(<span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>)</span>);</code></dt><dd><p>* Optionally find the smallest key/value pair, using the key ordering.</p></dd></dl><dl><dt class="spec value" id="val-max"><a href="#val-max" class="anchor"></a><code><span class="keyword">let</span> max: <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> option(<span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>)</span>);</code></dt><dd><p>* Optionally find the largest key/value pair, using the key ordering.</p></dd></dl><dl><dt class="spec value" id="val-get"><a href="#val-get" class="anchor"></a><code><span class="keyword">let</span> get: <span class="type-var">'key</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> option(<span class="type-var">'value</span>);</code></dt><dd><p>* Attempt to find a value in a map, given a key.</p></dd></dl><dl><dt class="spec value" id="val-getOrElse"><a href="#val-getOrElse" class="anchor"></a><code><span class="keyword">let</span> getOrElse: <span class="type-var">'key</span> <span>=&gt;</span> <span class="type-var">'value</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <span class="type-var">'value</span>;</code></dt><dd><p>* Attempt to find a value in a map, given a key. Use the provided fallback * value if the key is not in the map.</p></dd></dl><dl><dt class="spec value" id="val-remove"><a href="#val-remove" class="anchor"></a><code><span class="keyword">let</span> remove: <span class="type-var">'key</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>* Return a new copy of a map, with the provided key removed. Like other map * functions that &quot;change&quot; a value, this returns an immutable copy. The * original map is unchanged.</p></dd></dl><dl><dt class="spec value" id="val-removeMany"><a href="#val-removeMany" class="anchor"></a><code><span class="keyword">let</span> removeMany: array(<span class="type-var">'key</span>) <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>* Given a list of keys, remove each from the map, returning a new copy.</p></dd></dl><dl><dt class="spec value" id="val-update"><a href="#val-update" class="anchor"></a><code><span class="keyword">let</span> update: <span class="type-var">'key</span> <span>=&gt;</span> <span>(option(<span class="type-var">'value</span>) <span>=&gt;</span> option(<span class="type-var">'value</span>))</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>* At the given key, set or remove the value using the provided update * function. The function will be called with the current value, if any. It * may return `Some(newValue)` which will perform a `set`, or it can return * `None`, which will perform a `remove`.</p></dd></dl><dl><dt class="spec value" id="val-merge"><a href="#val-merge" class="anchor"></a><code><span class="keyword">let</span> merge: <span>(<span class="type-var">'key</span> <span>=&gt;</span> option(<span class="type-var">'value</span>) <span>=&gt;</span> option(<span class="type-var">'value</span>) <span>=&gt;</span> option(<span class="type-var">'value</span>))</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>* Combine two existing maps using the provided merge function. The merge * function will be called with the key being merged as well as the two * possible values from the existing maps. The provided merge function should * return `None` to remove a key, or `Some(newValue)` to keep the key. * * The value types of the two original maps don't need to be the same, nor * does the value type returned by the provided merge function.</p></dd></dl><dl><dt class="spec value" id="val-mergeMany"><a href="#val-mergeMany" class="anchor"></a><code><span class="keyword">let</span> mergeMany: array(<span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>)</span>) <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>* Given an array of key/value pairs and an existin map, add each key and * value in the array to the map. * * TODO: it's not clear from the Belt docs what happens in the case of key * conflicts.</p></dd></dl><dl><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">let</span> filter: <span>(<span class="type-var">'key</span> <span>=&gt;</span> <span class="type-var">'value</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>* Remove each key/value pair that doesn't pass the given predicate function.</p></dd></dl><dl><dt class="spec value" id="val-keep"><a href="#val-keep" class="anchor"></a><code><span class="keyword">let</span> keep: <span>(<span class="type-var">'key</span> <span>=&gt;</span> <span class="type-var">'value</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>* Alias of filter</p></dd></dl><dl><dt class="spec value" id="val-filterNot"><a href="#val-filterNot" class="anchor"></a><code><span class="keyword">let</span> filterNot: <span>(<span class="type-var">'key</span> <span>=&gt;</span> <span class="type-var">'value</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>* Remove each key/value pair that passes the given predicate function</p></dd></dl><dl><dt class="spec value" id="val-reject"><a href="#val-reject" class="anchor"></a><code><span class="keyword">let</span> reject: <span>(<span class="type-var">'key</span> <span>=&gt;</span> <span class="type-var">'value</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>* Alias of filterNot</p></dd></dl><dl><dt class="spec value" id="val-partition"><a href="#val-partition" class="anchor"></a><code><span class="keyword">let</span> partition: <span>(<span class="type-var">'key</span> <span>=&gt;</span> <span class="type-var">'value</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <span>(<a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>, <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>)</span>;</code></dt><dt class="spec value" id="val-map"><a href="#val-map" class="anchor"></a><code><span class="keyword">let</span> map: <span>(<span class="type-var">'v1</span> <span>=&gt;</span> <span class="type-var">'v2</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'v1</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'v2</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>* Transform each value in the map to a new value using the provided function.</p></dd></dl><dl><dt class="spec value" id="val-mapWithKey"><a href="#val-mapWithKey" class="anchor"></a><code><span class="keyword">let</span> mapWithKey: <span>(<span class="type-var">'key</span> <span>=&gt;</span> <span class="type-var">'v1</span> <span>=&gt;</span> <span class="type-var">'v2</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'v1</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, <span class="type-var">'v2</span>, <span class="type-var">'id</span>)</span>;</code></dt><dt class="spec value" id="val-groupListBy"><a href="#val-groupListBy" class="anchor"></a><code><span class="keyword">let</span> groupListBy: Belt.Id.comparable<span>(<span class="type-var">'key</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'value</span> <span>=&gt;</span> <span class="type-var">'key</span>)</span> <span>=&gt;</span> list(<span class="type-var">'value</span>) <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, list(<span class="type-var">'value</span>), <span class="type-var">'id</span>)</span>;</code></dt><dt class="spec value" id="val-groupArrayBy"><a href="#val-groupArrayBy" class="anchor"></a><code><span class="keyword">let</span> groupArrayBy: Belt.Id.comparable<span>(<span class="type-var">'key</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <span>(<span class="type-var">'value</span> <span>=&gt;</span> <span class="type-var">'key</span>)</span> <span>=&gt;</span> array(<span class="type-var">'value</span>) <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'key</span>, array(<span class="type-var">'value</span>), <span class="type-var">'id</span>)</span>;</code></dt></dl><div class="spec module-type" id="module-type-MAP"><a href="#module-type-MAP" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-MAP">MAP</a> = { ... };</code></div><div class="spec module" id="module-WithOrd"><a href="#module-WithOrd" class="anchor"></a><code><span class="keyword">module</span> <a href="WithOrd">WithOrd</a>:  (<a href="WithOrd#argument-1-M">M</a>: BsBastet.Interface.ORD) <span>=&gt;</span> <a href="#module-type-MAP">MAP</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="WithOrd#type-key">key</a> = <a href="WithOrd#argument-1-M">M</a>.t;</code></div></div></body></html>