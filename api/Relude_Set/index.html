<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Relude_Set (api.Relude_Set)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../">Up</a> – <a href="../">api</a> &#x00BB; Relude_Set</nav><h1>Module <code>Relude_Set</code></h1></header><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t('value, 'id)</code><code> = Belt.Set.t<span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span></code>;</dt></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">let</span> empty: <span>(<span class="keyword">module</span> Belt.Id.Comparable <span class="keyword">with</span> <span class="keyword">type</span> identity = <span class="type-var">'id</span> <span class="keyword">and</span> <span class="keyword">type</span> t = <span class="type-var">'value</span>)</span> <span>=&gt;</span> Belt.Set.t<span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>* Construct a new, empty set.</p></dd></dl><dl><dt class="spec value" id="val-fromArray"><a href="#val-fromArray" class="anchor"></a><code><span class="keyword">let</span> fromArray: <span>(<span class="keyword">module</span> Belt.Id.Comparable <span class="keyword">with</span> <span class="keyword">type</span> identity = <span class="type-var">'id</span> <span class="keyword">and</span> <span class="keyword">type</span> t = <span class="type-var">'value</span>)</span> <span>=&gt;</span> array(<span class="type-var">'value</span>) <span>=&gt;</span> Belt.Set.t<span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>* `fromArray((module Comparable), array(value))` * converts an array of values into a new set of those values, * ordered by the comparator function `Comparable.cmp`.</p></dd></dl><dl><dt class="spec value" id="val-fromList"><a href="#val-fromList" class="anchor"></a><code><span class="keyword">let</span> fromList: <span>(<span class="keyword">module</span> Belt.Id.Comparable <span class="keyword">with</span> <span class="keyword">type</span> identity = <span class="type-var">'id</span> <span class="keyword">and</span> <span class="keyword">type</span> t = <span class="type-var">'value</span>)</span> <span>=&gt;</span> list(<span class="type-var">'value</span>) <span>=&gt;</span> Belt.Set.t<span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>* `fromList((module Comparable), list(value))` * converts a list of values into a new set of those values, * ordered by the comparator function `Comparable.cmp`.</p></dd></dl><dl><dt class="spec value" id="val-isEmpty"><a href="#val-isEmpty" class="anchor"></a><code><span class="keyword">let</span> isEmpty: <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> bool;</code></dt><dd><p>* Determine whether a set is empty.</p></dd></dl><dl><dt class="spec value" id="val-contains"><a href="#val-contains" class="anchor"></a><code><span class="keyword">let</span> contains: <span class="type-var">'value</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> bool;</code></dt><dd><p>* Determine whether a set contains a given value.</p></dd></dl><dl><dt class="spec value" id="val-add"><a href="#val-add" class="anchor"></a><code><span class="keyword">let</span> add: <span class="type-var">'value</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>* Immutably add a value to a set. If the value already exists * in the set, the original set (physical reference) is returned * unchanged. Otherwise, a new copy of the set is returned * containing the value.</p></dd></dl><dl><dt class="spec value" id="val-mergeMany"><a href="#val-mergeMany" class="anchor"></a><code><span class="keyword">let</span> mergeMany: array(<span class="type-var">'value</span>) <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>* Immutably merge an array of values into a set. Note: unlike `add` * If the set already contains all the values in the array, the * return value **may or may not be a new reference**. Otherwise, * a new set reference is returned.</p></dd></dl><dl><dt class="spec value" id="val-remove"><a href="#val-remove" class="anchor"></a><code><span class="keyword">let</span> remove: <span class="type-var">'value</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>* Immutably remove a value from a set. If the value is not found * in the set, the original set (physical reference) is returned * unchanged. Otherwise, a new set is returned containing the value.</p></dd></dl><dl><dt class="spec value" id="val-removeMany"><a href="#val-removeMany" class="anchor"></a><code><span class="keyword">let</span> removeMany: array(<span class="type-var">'value</span>) <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>* Immutably remove multiple values from a set. Note: unlike `remove` * If none of the values in the array are found in the set, the * return value **may or may not be a new reference**. Otherwise, a * new set reference is returned.</p></dd></dl><dl><dt class="spec value" id="val-update"><a href="#val-update" class="anchor"></a><code><span class="keyword">let</span> update: <span class="type-var">'value</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>* Immutably update a set with a new value. If an equivalent value * already exists in the set, it will be immutably removed before * adding the new value. In ether case, a new physical reference * to the set will be returned. **Note: unlike `add`, `update` * guarantees that the value's physical reference will be added to * the set.**</p></dd></dl><dl><dt class="spec value" id="val-toggle"><a href="#val-toggle" class="anchor"></a><code><span class="keyword">let</span> toggle: <span class="type-var">'value</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>* Immutably add a value to a set if it does not already exist. * If an equivalent value already exists in the set, it will be * removed. In either case, a new physical reference to the set * will be returned.</p></dd></dl><dl><dt class="spec value" id="val-union"><a href="#val-union" class="anchor"></a><code><span class="keyword">let</span> union: <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>* Returns a new set representing the union of two sets. E.g.: * ``` * let s1 = fromList(<code>1, 3, 4, 5, 2, 1</code>); * let s2 = fromList(<code>1, 0, 3, 2, 9</code>); * let result = union(s1, s2) |&gt; toList; * // result: <code>0, 1, 2, 3, 4, 5, 9</code> * ```</p></dd></dl><dl><dt class="spec value" id="val-intersect"><a href="#val-intersect" class="anchor"></a><code><span class="keyword">let</span> intersect: <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>* Returns a new set representing the intersection of two sets. * E.g.: * ``` * let s1 = fromList(<code>0, 1, 2, 3, 4, 1</code>); * let s2 = fromList(<code>0, 3, 9, 8, 10</code>); * let result = intersect(s1, s2) |&gt; toList; * // result: <code>0, 3</code> * ```</p></dd></dl><dl><dt class="spec value" id="val-diff"><a href="#val-diff" class="anchor"></a><code><span class="keyword">let</span> diff: <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>* Returns a new set which contains all the elements of the first * set that are not present in the second set. **Note: The argument order * is significant for this function**. * E.g.: * ``` * let s1 = fromList(<code>0, 1, 2, 3, 4, 1</code>); * let s2 = fromList(<code>0, 3, 9, 8, 10</code>); * * let result1 = diff(s1, s2) |&gt; toList; * // result: <code>1, 2, 4</code>; * * let result2 = diff(s2, s1) |&gt; toList; * // result: <code>8, 9, 10</code>; * ```</p></dd></dl><dl><dt class="spec value" id="val-subset"><a href="#val-subset" class="anchor"></a><code><span class="keyword">let</span> subset: <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> bool;</code></dt><dd><p>* `subset(s1, s2)` will return `true` if `s2` is a subset of `s1`. * **Note: The argument order is significant for this function**.</p></dd></dl><dl><dt class="spec value" id="val-compare"><a href="#val-compare" class="anchor"></a><code><span class="keyword">let</span> compare: <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> int;</code></dt><dd><p>* Returns an integer value of `-1 | 0 | 1`, representing the total * ordering between two sets. This can be used as a comparator function * to determine the ordering of nested sets (e.g. `Set.t(Set.t('a))`); * **Note: The argument order is significant for this function**. E.g.: * * ``` * let s0 = Test1.fromList(<code>1, 2, 3, 4</code>); * let s1 = Test1.fromList(<code>1, 2, 3, 4</code>); * let s2 = Test1.fromList(<code>2, 3, 4, 5, 6</code>); * let s3 = Test1.fromList(<code>100, 0</code>); * compare(s0, s1); // 0; * compare(s0, s2); // -1; * compare(s0, s3); // 1; * compare(s1, s2); // -1 * compare(s1, s3); // 1 * compare(s2, s3); // 1 * ```</p></dd></dl><dl><dt class="spec value" id="val-eq"><a href="#val-eq" class="anchor"></a><code><span class="keyword">let</span> eq: <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> bool;</code></dt><dd><p>* Determine whether two sets are equivalent.</p></dd></dl><dl><dt class="spec value" id="val-forEach"><a href="#val-forEach" class="anchor"></a><code><span class="keyword">let</span> forEach: <span>(<span class="type-var">'value</span> <span>=&gt;</span> unit)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> unit;</code></dt><dd><p>* Apply a function to each element of a set, in increasing * order.</p></dd></dl><dl><dt class="spec value" id="val-foldLeft"><a href="#val-foldLeft" class="anchor"></a><code><span class="keyword">let</span> foldLeft: <span>(<span class="type-var">'acc</span> <span>=&gt;</span> <span class="type-var">'value</span> <span>=&gt;</span> <span class="type-var">'acc</span>)</span> <span>=&gt;</span> <span class="type-var">'acc</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <span class="type-var">'acc</span>;</code></dt><dd><p>* Iterate over the values of a set in increasing order, * accumulating a final value of an arbitraty type.</p></dd></dl><dl><dt class="spec value" id="val-foldRight"><a href="#val-foldRight" class="anchor"></a><code><span class="keyword">let</span> foldRight: <span>(<span class="type-var">'b</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'b</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <span class="type-var">'a</span>;</code></dt><dd><p>* TODO: optimize foldRight for sets. This remains unimplemented * in `Belt`'s API, but it exists in PureScript/Haskell, since `Set` * implements `Foldable`.</p></dd></dl><dl><dt class="spec value" id="val-all"><a href="#val-all" class="anchor"></a><code><span class="keyword">let</span> all: <span>(<span class="type-var">'value</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> bool;</code></dt><dd><p>* Determine whether a given predicate holds true for all values * in a given set.</p></dd></dl><dl><dt class="spec value" id="val-any"><a href="#val-any" class="anchor"></a><code><span class="keyword">let</span> any: <span>(<span class="type-var">'value</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> bool;</code></dt><dd><p>* Determine whether a given predicate holds true for at least * one value in a given set.</p></dd></dl><dl><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">let</span> filter: <span>(<span class="type-var">'value</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>* Create a new set from another set containing only the values * which pass a given test (the predicate function).</p></dd></dl><dl><dt class="spec value" id="val-keep"><a href="#val-keep" class="anchor"></a><code><span class="keyword">let</span> keep: <span>(<span class="type-var">'value</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>* Alias of filter</p></dd></dl><dl><dt class="spec value" id="val-filterNot"><a href="#val-filterNot" class="anchor"></a><code><span class="keyword">let</span> filterNot: <span>(<span class="type-var">'value</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>* Creates a new set from another set containing only the values * which do *not* pass a given test (the predicate function)</p></dd></dl><dl><dt class="spec value" id="val-reject"><a href="#val-reject" class="anchor"></a><code><span class="keyword">let</span> reject: <span>(<span class="type-var">'value</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>;</code></dt><dd><p>* Alias of filterNot</p></dd></dl><dl><dt class="spec value" id="val-partition"><a href="#val-partition" class="anchor"></a><code><span class="keyword">let</span> partition: <span>(<span class="type-var">'value</span> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <span>(<a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>, <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>)</span>;</code></dt><dd><p>* Immutably divide a set into a tuple of two sets, where the first * set contains all the values which pass the predicate function test, * and the second one contains all the values which fail.</p></dd></dl><dl><dt class="spec value" id="val-length"><a href="#val-length" class="anchor"></a><code><span class="keyword">let</span> length: <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> int;</code></dt><dd><p>* Returns the total number of elements in a set.</p></dd></dl><dl><dt class="spec value" id="val-toArray"><a href="#val-toArray" class="anchor"></a><code><span class="keyword">let</span> toArray: <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> array(<span class="type-var">'value</span>);</code></dt><dd><p>* Creates a new array containing all elements of the set in * ascending order based on the associated comparator function.</p></dd></dl><dl><dt class="spec value" id="val-toList"><a href="#val-toList" class="anchor"></a><code><span class="keyword">let</span> toList: <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> list(<span class="type-var">'value</span>);</code></dt><dd><p>* Creates a new list containing all elements of the set in * ascending order based on the associated comparator function.</p></dd></dl><dl><dt class="spec value" id="val-minimum"><a href="#val-minimum" class="anchor"></a><code><span class="keyword">let</span> minimum: <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> option(<span class="type-var">'value</span>);</code></dt><dd><p>* Optionally returns the lowest ordered element in a given set. * Returns `None` if the set is empty.</p></dd></dl><dl><dt class="spec value" id="val-maximum"><a href="#val-maximum" class="anchor"></a><code><span class="keyword">let</span> maximum: <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> option(<span class="type-var">'value</span>);</code></dt><dd><p>* Optionally returns the highest ordered element in a given set. * Returns `None` if the set is empty.</p></dd></dl><dl><dt class="spec value" id="val-get"><a href="#val-get" class="anchor"></a><code><span class="keyword">let</span> get: <span class="type-var">'value</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> option(<span class="type-var">'value</span>);</code></dt><dd><p>* Optionally returns an equivalent element from a set. * Returns `None` if no equivalent element is found, or the * set is empty.</p></dd></dl><dl><dt class="spec value" id="val-getOrElse"><a href="#val-getOrElse" class="anchor"></a><code><span class="keyword">let</span> getOrElse: <span class="type-var">'value</span> <span>=&gt;</span> <span class="type-var">'value</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <span class="type-var">'value</span>;</code></dt><dd><p>* Returns an equivalent element from a set if one exists, * or else returns a specified default value.</p></dd></dl><dl><dt class="spec value" id="val-split"><a href="#val-split" class="anchor"></a><code><span class="keyword">let</span> split: <span class="type-var">'value</span> <span>=&gt;</span> <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span> <span>=&gt;</span> <span>(<span>(<a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>, <a href="#type-t">t</a><span>(<span class="type-var">'value</span>, <span class="type-var">'id</span>)</span>)</span>, bool)</span>;</code></dt><dd><p>* TODO: Needs documentation. Belt doesn't provide much description.</p></dd></dl><div class="spec module-type" id="module-type-SET"><a href="#module-type-SET" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-SET">SET</a> = { ... };</code></div><div class="spec module" id="module-WithOrd"><a href="#module-WithOrd" class="anchor"></a><code><span class="keyword">module</span> <a href="WithOrd">WithOrd</a>:  (<a href="WithOrd#argument-1-M">M</a>: BsBastet.Interface.ORD) <span>=&gt;</span> <a href="#module-type-SET">SET</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="WithOrd#type-value">value</a> = <a href="WithOrd#argument-1-M">M</a>.t;</code></div></div></body></html>