<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Relude_Interface (api.Relude_Interface)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../">Up</a> â€“ <a href="../">api</a> &#x00BB; Relude_Interface</nav><h1>Module <code>Relude_Interface</code></h1></header><dl><dt class="spec module-type" id="module-type-TYPE_ANY"><a href="#module-type-TYPE_ANY" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-TYPE_ANY">TYPE_ANY</a> = { ... };</code></dt><dd><p>* Module type signature for a type constructor with a single type hole.</p></dd></dl><dl><dt class="spec module-type" id="module-type-FUNCTION_1"><a href="#module-type-FUNCTION_1" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-FUNCTION_1">FUNCTION_1</a> = { ... };</code></dt><dd><p>* Module type which captures a simple a =&gt; b function</p></dd></dl><dl><dt class="spec module-type" id="module-type-FUNCTION_1_F"><a href="#module-type-FUNCTION_1_F" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-FUNCTION_1_F">FUNCTION_1_F</a> =  (<a href="module-type-FUNCTION_1_F#argument-1-A">A</a>: BsBastet.Interface.TYPE) <span>=&gt;</span>  (<a href="module-type-FUNCTION_1_F#argument-2-B">B</a>: BsBastet.Interface.TYPE) <span>=&gt;</span> <a href="#module-type-FUNCTION_1">FUNCTION_1</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-FUNCTION_1_F#type-a">a</a> = <a href="module-type-FUNCTION_1_F#argument-1-A">A</a>.t <span class="keyword">and</span> <span class="keyword">type</span> <a href="module-type-FUNCTION_1_F#type-b">b</a> = <a href="module-type-FUNCTION_1_F#argument-2-B">B</a>.t;</code></dt><dd><p>* Module type functor which captures a simple a =&gt; b function</p></dd></dl><dl><dt class="spec module-type" id="module-type-NATURAL_TRANSFORMATION"><a href="#module-type-NATURAL_TRANSFORMATION" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-NATURAL_TRANSFORMATION">NATURAL_TRANSFORMATION</a> = { ... };</code></dt><dd><p>* Captures a natural tranformation * * It seems surprisingly hard to do `forall a. f a -&gt; g a` in OCaml, but maybe I'm missing something. * See the Relude_Free_Applicative for an example usage.</p></dd></dl><dl><dt class="spec module-type" id="module-type-SEQUENCE"><a href="#module-type-SEQUENCE" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-SEQUENCE">SEQUENCE</a> = { ... };</code></dt><dd><p>* Module type signature for a module that represents a sequence of values and related functions.</p></dd></dl><dl><dt class="spec module-type" id="module-type-ISO_ARRAY"><a href="#module-type-ISO_ARRAY" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-ISO_ARRAY">ISO_ARRAY</a> = { ... };</code></dt><dd><p>* Module type signature for a module that is isomorphic with an array</p></dd></dl><dl><dt class="spec module-type" id="module-type-ISO_LIST"><a href="#module-type-ISO_LIST" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-ISO_LIST">ISO_LIST</a> = { ... };</code></dt><dd><p>* Module type signature for a module that is isomorphic with a list</p></dd></dl><dl><dt class="spec module-type" id="module-type-SEMIALIGN"><a href="#module-type-SEMIALIGN" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-SEMIALIGN">SEMIALIGN</a> = { ... };</code></dt><dd><p>* Module type signature for Ior-based zipping and unzipping</p></dd></dl><dl><dt class="spec module-type" id="module-type-ALIGN"><a href="#module-type-ALIGN" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-ALIGN">ALIGN</a> = { ... };</code></dt><dd><p>* Module type signature for an extension of ALIGN that adds an empty `nil` value. * * Note that this has a parallel to the applicative typeclasses: * * APPLY/APPLICATIVE/TRAVERSABLE * * SEMIALIGN/ALIGN/CROSSWALK (or maybe ALIGNABLE?)</p></dd></dl><dl><dt class="spec module-type" id="module-type-MONAD_THROW"><a href="#module-type-MONAD_THROW" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-MONAD_THROW">MONAD_THROW</a> = { ... };</code></dt><dd><p>* Module type signature for a Monad that can produce an error in a monadic context</p></dd></dl><dl><dt class="spec module-type" id="module-type-MONAD_ERROR"><a href="#module-type-MONAD_ERROR" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-MONAD_ERROR">MONAD_ERROR</a> = { ... };</code></dt><dd><p>* Module type signature for a Monad that can handle an error by creating a new monadic value.</p></dd></dl><dl><dt class="spec module-type" id="module-type-LOWER_BOUNDED"><a href="#module-type-LOWER_BOUNDED" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-LOWER_BOUNDED">LOWER_BOUNDED</a> = { ... };</code></dt><dd><p>* Represents types that have a lower bound, like strings or positive ints</p></dd></dl><dl><dt class="spec module-type" id="module-type-UPPER_BOUNDED"><a href="#module-type-UPPER_BOUNDED" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-UPPER_BOUNDED">UPPER_BOUNDED</a> = { ... };</code></dt><dd><p>* Represents types that have an upper bound</p></dd></dl><dl><dt class="spec module-type" id="module-type-ENUM"><a href="#module-type-ENUM" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-ENUM">ENUM</a> = { ... };</code></dt><dd><p>* Module type which describes a type that can be ordered and for which we can determine * a lawful chain of successors and predecessors</p></dd></dl><dl><dt class="spec module-type" id="module-type-BOUNDED_ENUM"><a href="#module-type-BOUNDED_ENUM" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-BOUNDED_ENUM">BOUNDED_ENUM</a> = { ... };</code></dt><dd><p>* Module type which describes a type that can be ordered and for which we can determine * a lawful chain of successors and predecessors, and there is a top and bottom bound.</p></dd></dl></div></body></html>