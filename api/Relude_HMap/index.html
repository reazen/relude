<!DOCTYPE html>
<html xmlns="http://www.w3.org/1999/xhtml"><head><title>Relude_HMap (api.Relude_HMap)</title><link rel="stylesheet" href="../../odoc.css"/><meta charset="utf-8"/><meta name="generator" content="odoc 1.5.0"/><meta name="viewport" content="width=device-width,initial-scale=1.0"/><script src="../../highlight.pack.js"></script><script>hljs.initHighlightingOnLoad();</script></head><body><div class="content"><header><nav><a href="../">Up</a> – <a href="../">api</a> &#x00BB; Relude_HMap</nav><h1>Module <code>Relude_HMap</code></h1></header><dl><dt class="spec module" id="module-Witness"><a href="#module-Witness" class="anchor"></a><code><span class="keyword">module</span> <a href="Witness">Witness</a>: { ... };</code></dt><dd><p>* Witness contains a type t with an existential type variable - a type that we * capture, but lose knowledge of once captured. * `t(_)` is an extensible variant type, indicated by the `..`. This is used below in WITNESS * so that we can add new cases to the Witness.t(_) type on demand, so that we can create witnesses * for any new types we encounter going forward. * https://caml.inria.fr/pub/docs/manual-ocaml/manual037.html</p></dd></dl><dl><dt class="spec module-type" id="module-type-WITNESS"><a href="#module-type-WITNESS" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-WITNESS">WITNESS</a> = { ... };</code></dt><dd><p>* WITNESS captures a type `t` with a `Witness` module for that type. * Because Witness.t(_) is an extensible variant, we use `+=` to add a constructor * to that type. * This is useful because the type t is unified with the type t hidden inside the * Witness module.</p></dd></dl><dl><dt class="spec type" id="type-witness"><a href="#type-witness" class="anchor"></a><code><span class="keyword">type</span> witness('a)</code><code> = <span>(<span class="keyword">module</span> <a href="module-type-WITNESS">WITNESS</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-WITNESS#type-t">t</a> = <span class="type-var">'a</span>)</span></code>;</dt><dd><p>* witness('a) is a type which captures a WITNESS module for the given type 'a.</p></dd></dl><dl><dt class="spec value" id="val-makeWitness"><a href="#val-makeWitness" class="anchor"></a><code><span class="keyword">let</span> makeWitness: unit <span>=&gt;</span> <span>(<span class="keyword">module</span> <a href="module-type-WITNESS">WITNESS</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="module-type-WITNESS#type-t">t</a> = <span class="type-var">'a</span>)</span>;</code></dt><dd><p>* makeWitness makes a Witness module for the given type a</p></dd></dl><dl><dt class="spec type" id="type-typeEq"><a href="#type-typeEq" class="anchor"></a><code><span class="keyword">type</span> typeEq('a, 'b)</code><code> = </code><table class="variant"><tr id="type-typeEq.TypeEq" class="anchored"><td class="def constructor"><a href="#type-typeEq.TypeEq" class="anchor"></a><code>| </code><code><span class="constructor">TypeEq</span> : <a href="#type-typeEq">typeEq</a><span>(<span class="type-var">'a</span>, <span class="type-var">'a</span>)</span></code></td></tr></table>;</dt><dd><p>* typeEq('a, 'b) contains a single constructor TypeEq which can only be constructed if 'a and 'b are the same types. * This is used for a type-level type equality check.</p></dd></dl><dl><dt class="spec value" id="val-typeEq"><a href="#val-typeEq" class="anchor"></a><code><span class="keyword">let</span> typeEq: l r. <a href="#type-witness">witness</a>(<span class="type-var">'l</span>) <span>=&gt;</span> <a href="#type-witness">witness</a>(<span class="type-var">'r</span>) <span>=&gt;</span> option(<a href="#type-typeEq">typeEq</a><span>(<span class="type-var">'l</span>, <span class="type-var">'r</span>)</span>);</code></dt><dd><p>* eq checks whether the give witness types are equal</p></dd></dl><dl><dt class="spec module-type" id="module-type-KEY_META"><a href="#module-type-KEY_META" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-KEY_META">KEY_META</a> = { ... };</code></dt><dd><p>* KEY_TYPE is a module type signature which captures the type of a map key</p></dd></dl><dl><dt class="spec module-type" id="module-type-HMAP_TYPE"><a href="#module-type-HMAP_TYPE" class="anchor"></a><code><span class="keyword">module</span> <span class="keyword">type</span> <a href="module-type-HMAP_TYPE">HMAP_TYPE</a> = { ... };</code></dt><dd><p>* MAP_TYPE is a module type signature which captures the types and functions exposed * by the HMap</p></dd></dl><dl><dt class="spec module" id="module-WithKeyMeta"><a href="#module-WithKeyMeta" class="anchor"></a><code><span class="keyword">module</span> <a href="WithKeyMeta">WithKeyMeta</a>:  (<a href="WithKeyMeta/argument-1-KeyMeta">KeyMeta</a>: <a href="#module-type-KEY_META">KEY_META</a>) <span>=&gt;</span> <a href="#module-type-HMAP_TYPE">HMAP_TYPE</a> <span class="keyword">with</span> <span class="keyword">type</span> <a href="WithKeyMeta/Key#type-keyMeta">Key.keyMeta</a>('a) = <a href="WithKeyMeta/argument-1-KeyMeta#type-t">KeyMeta.t</a>(<span class="type-var">'a</span>);</code></dt><dd><p>* Make creates a Map module for the given KEY_META. * * KEY_META contains extra information to store with the key, like labels, and functions for * operating on the values contained with each key-value pair.</p></dd></dl><dl><dt class="spec module" id="module-WithKeyMetaUnit"><a href="#module-WithKeyMetaUnit" class="anchor"></a><code><span class="keyword">module</span> <a href="WithKeyMetaUnit">WithKeyMetaUnit</a>: { ... };</code></dt><dd><p>* We include a default HMap implementation which uses `unit` as it's key meta type. * Note that this default map type will not work in a type-safe way for functions that * iterate over the map with keyValue functions, like fold, all, any, etc. * * In order to use the iterating functions, use a custom HMap with the key metadata functions * needed to convert the existential 'a into a useful value.</p></dd></dl><div><div class="spec include"><div class="doc"><details open="open"><summary><span class="def"><code><span class="keyword">include</span> <a href="#module-WithKeyMetaUnit">WithKeyMetaUnit</a><span class="keyword">;</span></code></span></summary><dl><dt class="spec type" id="type-keyImpl"><a href="#type-keyImpl" class="anchor"></a><code><span class="keyword">type</span> keyImpl('a)</code>;</dt><dd><p>* An abstract type for map keys</p></dd></dl><dl><dt class="spec module" id="module-Key"><a href="#module-Key" class="anchor"></a><code><span class="keyword">module</span> Key = <a href="WithKeyMetaUnit#module-Key">WithKeyMetaUnit.Key</a>;</code></dt><dd><p>* Key-related types and operations for an HMap</p></dd></dl><dl><dt class="spec type" id="type-t"><a href="#type-t" class="anchor"></a><code><span class="keyword">type</span> t</code>;</dt><dd><p>* The abstract type of the HMap</p></dd></dl><dl><dt class="spec value" id="val-empty"><a href="#val-empty" class="anchor"></a><code><span class="keyword">let</span> empty: <a href="#type-t">t</a>;</code></dt><dd><p>* An empty HMap</p></dd></dl><dl><dt class="spec value" id="val-isEmpty"><a href="#val-isEmpty" class="anchor"></a><code><span class="keyword">let</span> isEmpty: <a href="#type-t">t</a> <span>=&gt;</span> bool;</code></dt><dd><p>* Indicates if the HMap is empty</p></dd></dl><dl><dt class="spec value" id="val-hasKey"><a href="#val-hasKey" class="anchor"></a><code><span class="keyword">let</span> hasKey: <a href="#type-keyImpl">keyImpl</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a> <span>=&gt;</span> bool;</code></dt><dd><p>* Indicates if the HMap has a value for the given key</p></dd></dl><dl><dt class="spec value" id="val-add"><a href="#val-add" class="anchor"></a><code><span class="keyword">let</span> add: <a href="#type-keyImpl">keyImpl</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a> <span>=&gt;</span> <a href="#type-t">t</a>;</code></dt><dd><p>* Adds the given key/value pair to the HMap</p></dd></dl><dl><dt class="spec value" id="val-singleton"><a href="#val-singleton" class="anchor"></a><code><span class="keyword">let</span> singleton: <a href="#type-keyImpl">keyImpl</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a>;</code></dt><dd><p>* Creates an HMap with the given key/value pair</p></dd></dl><dl><dt class="spec value" id="val-remove"><a href="#val-remove" class="anchor"></a><code><span class="keyword">let</span> remove: <a href="#type-keyImpl">keyImpl</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a> <span>=&gt;</span> <a href="#type-t">t</a>;</code></dt><dd><p>* Creates a new HMap that does not contain a value for the given key</p></dd></dl><dl><dt class="spec value" id="val-find"><a href="#val-find" class="anchor"></a><code><span class="keyword">let</span> find: <a href="#type-keyImpl">keyImpl</a>(<span class="type-var">'a</span>) <span>=&gt;</span> <a href="#type-t">t</a> <span>=&gt;</span> option(<span class="type-var">'a</span>);</code></dt><dd><p>* Looks up a value in the HMap for the given key</p></dd></dl><dl><dt class="spec type" id="type-keyValue"><a href="#type-keyValue" class="anchor"></a><code><span class="keyword">type</span> keyValue</code><code> = </code><table class="variant"><tr id="type-keyValue.KeyValue" class="anchored"><td class="def constructor"><a href="#type-keyValue.KeyValue" class="anchor"></a><code>| </code><code><span class="constructor">KeyValue</span>(<a href="#type-keyImpl">keyImpl</a>(<span class="type-var">'a</span>), <span class="type-var">'a</span>) : <a href="#type-keyValue">keyValue</a></code></td></tr></table>;</dt><dd><p>* The type of a key/value pair in the HMap. The key captures the type of the corresponding value.</p></dd></dl><dl><dt class="spec value" id="val-forEach"><a href="#val-forEach" class="anchor"></a><code><span class="keyword">let</span> forEach: <span>(<a href="#type-keyValue">keyValue</a> <span>=&gt;</span> unit)</span> <span>=&gt;</span> <a href="#type-t">t</a> <span>=&gt;</span> unit;</code></dt><dd><p>* Runs a side effect for each key/value pair in the HMap. Note: the KEY_META must provide appropriate * functions for converting the existentially typed values into values of a known type.</p></dd></dl><dl><dt class="spec value" id="val-fold"><a href="#val-fold" class="anchor"></a><code><span class="keyword">let</span> fold: <span>(<a href="#type-keyValue">keyValue</a> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <span class="type-var">'a</span>)</span> <span>=&gt;</span> <span class="type-var">'a</span> <span>=&gt;</span> <a href="#type-t">t</a> <span>=&gt;</span> <span class="type-var">'a</span>;</code></dt><dd><p>* Folds the HMap into a value. Note the KEY_META must provide appropriate functions for manipulating * the values stored for each key.</p></dd></dl><dl><dt class="spec value" id="val-all"><a href="#val-all" class="anchor"></a><code><span class="keyword">let</span> all: <span>(<a href="#type-keyValue">keyValue</a> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a> <span>=&gt;</span> bool;</code></dt><dd><p>* Indicates if all key/value pairs in the HMap satisfy the given predicate. Note the KEY_META must * provide appropriate functions for manipulating the values stored for each key.</p></dd></dl><dl><dt class="spec value" id="val-any"><a href="#val-any" class="anchor"></a><code><span class="keyword">let</span> any: <span>(<a href="#type-keyValue">keyValue</a> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a> <span>=&gt;</span> bool;</code></dt><dd><p>* Indicates if any key/value pairs in the HMap satisfy the given predicate. Note the KEY_META must * provide appropriate functions for manipulating the values stored for each key.</p></dd></dl><dl><dt class="spec value" id="val-filter"><a href="#val-filter" class="anchor"></a><code><span class="keyword">let</span> filter: <span>(<a href="#type-keyValue">keyValue</a> <span>=&gt;</span> bool)</span> <span>=&gt;</span> <a href="#type-t">t</a> <span>=&gt;</span> <a href="#type-t">t</a>;</code></dt><dd><p>* Creates a new HMap that only contains the key/value pairs that satisfy the given predicate. Note the KEY_META must * provide appropriate functions for manipulating the values stored for each key.</p></dd></dl><dl><dt class="spec value" id="val-size"><a href="#val-size" class="anchor"></a><code><span class="keyword">let</span> size: <a href="#type-t">t</a> <span>=&gt;</span> int;</code></dt><dd><p>* Gets the number of key/value pairs stored in this HMap.</p></dd></dl></details></div></div></div></div></body></html>